function nowIso() {
  return new Date().toISOString();
}

function isDebugEnabled(request) {
  try {
    return (request && request.headers && (request.headers.get("X-Eikon-Debug") || "") === "1");
  } catch (e) {
    return false;
  }
}

function jsonResponse(data, status = 200, extraHeaders = {}) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Cache-Control": "no-store",
      "Pragma": "no-cache",
      ...extraHeaders
    }
  });
}

function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, (c) => ({
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }[c]));
}

function parseAllowedOrigins(env) {
  const raw = (env.ALLOWED_ORIGINS || "").trim();
  if (!raw) return [];
  return raw.split(",").map(s => s.trim()).filter(Boolean);
}

function corsHeadersForRequest(request, env) {
  const origin = request.headers.get("Origin") || "";
  const allowed = parseAllowedOrigins(env);
  const selfOrigin = new URL(request.url).origin;

  // If Origin is missing (same-origin requests often omit it), allow.
  if (!origin) {
    return { ok: true, headers: { "Vary": "Origin" } };
  }

  // Always allow same-origin
  if (origin === selfOrigin) {
    return {
      ok: true,
      headers: {
        "Access-Control-Allow-Origin": origin,
        "Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS,HEAD",
        "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Eikon-Debug, X-Eikon-Report-Pass, X-Eikon-Edit-Pass",
        "Access-Control-Max-Age": "86400",
        "Vary": "Origin"
      }
    };
  }

  if (allowed.length === 0) {
    return { ok: false, headers: { "Vary": "Origin" } };
  }

  const matched = allowed.includes(origin);
  if (!matched) {
    return { ok: false, headers: { "Vary": "Origin" } };
  }

  return {
    ok: true,
    headers: {
      "Access-Control-Allow-Origin": origin,
      "Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS,HEAD",
      "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Eikon-Debug, X-Eikon-Report-Pass, X-Eikon-Edit-Pass",
      "Access-Control-Max-Age": "86400",
      "Vary": "Origin"
    }
  };
}

function base64FromBytes(bytes) {
  let binary = "";
  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

function bytesFromBase64(b64) {
  const bin = atob(b64);
  const out = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
  return out;
}

function base64UrlFromBytes(bytes) {
  return base64FromBytes(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function constantTimeEqual(a, b) {
  if (a.length !== b.length) return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++) diff |= (a[i] ^ b[i]);
  return diff === 0;
}

async function sha256B64FromString(s) {
  const enc = new TextEncoder();
  const digest = await crypto.subtle.digest("SHA-256", enc.encode(s));
  return base64FromBytes(new Uint8Array(digest));
}

async function pbkdf2Hash(password, saltBytes, iterations) {
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    { name: "PBKDF2" },
    false,
    ["deriveBits"]
  );

  const bits = await crypto.subtle.deriveBits(
    {
      name: "PBKDF2",
      hash: "SHA-256",
      salt: saltBytes,
      iterations
    },
    keyMaterial,
    256
  );

  return new Uint8Array(bits);
}

function htmlResponse(html, status = 200, extraHeaders = {}) {
  return new Response(html, {
    status,
    headers: {
      "Content-Type": "text/html; charset=utf-8",
      "Cache-Control": "no-store",
      "Pragma": "no-cache",
      ...extraHeaders
    }
  });
}

function isSuperuser(authUser, env) {
  // Superuser is an admin whose email is allowlisted in env.SUPERUSER_EMAILS (comma-separated).
  const list = String(env.SUPERUSER_EMAILS || "").split(",").map(s => s.trim().toLowerCase()).filter(Boolean);
  if (!authUser) return false;
  if (authUser.role !== "admin") return false;
  if (list.length === 0) return false; // explicit allowlist required
  return list.includes(String(authUser.email || "").toLowerCase());
}

async function requireSuperuser(request, env, extraHeaders = {}) {
  const authUser = await authFromRequest(request, env);
  if (!authUser) return { ok: false, res: jsonResponse({ ok: false, error: "Unauthorized" }, 401, extraHeaders) };
  if (!isSuperuser(authUser, env)) return { ok: false, res: jsonResponse({ ok: false, error: "Forbidden" }, 403, extraHeaders) };
  return { ok: true, authUser };
}

async function handleSuPage(request, env) {
  // Public page; actions require Bearer token of a superuser.
  const html = `<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Superuser Admin</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#f6f7fb;color:#111}
    header{padding:16px 20px;background:#111;color:#fff}
    main{padding:18px 20px;max-width:1100px;margin:0 auto}
    .card{background:#fff;border:1px solid #e6e8ef;border-radius:14px;padding:14px 14px;margin:12px 0;box-shadow:0 1px 3px rgba(0,0,0,.05)}
    h2{margin:0 0 10px 0;font-size:18px}
    label{display:block;font-size:12px;margin:10px 0 6px 0;color:#333}
    input,select,button,textarea{font:inherit}
    input,select,textarea{width:100%;padding:10px;border:1px solid #d6d9e6;border-radius:10px;background:#fff}
    textarea{min-height:80px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px}
    .actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    button{border:0;border-radius:10px;padding:10px 12px;background:#111;color:#fff;cursor:pointer}
    button.secondary{background:#394150}
    button.danger{background:#b42318}
    button.ghost{background:#fff;color:#111;border:1px solid #d6d9e6}
    .err{color:#b42318;font-weight:600;margin-top:8px;white-space:pre-wrap}
    .ok{color:#067647;font-weight:600;margin-top:8px;white-space:pre-wrap}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{border-bottom:1px solid #eee;padding:8px 6px;text-align:left;font-size:13px;vertical-align:top}
    th{font-size:12px;color:#555}
    .small{font-size:12px;color:#555}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef2ff;font-size:12px}
    .muted{color:#666}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
  </style>
</head>
<body>
<header>
  <div style="max-width:1100px;margin:0 auto;">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
      <div>
        <div style="font-weight:800;font-size:16px">Eikon Superuser Admin</div>
        <div class="small">Create / update / delete users, orgs, locations, wipe location data (superuser only)</div>
      </div>
      <div class="small">Endpoint: <span class="mono">${new URL(request.url).origin}</span></div>
    </div>
  </div>
</header>

<main>
  <div class="card">
    <h2>1) Login (superuser)</h2>
    <div class="row">
      <div>
        <label>Email</label>
        <input id="loginEmail" placeholder="you@example.com" />
      </div>
      <div>
        <label>Password</label>
        <input id="loginPassword" type="password" placeholder="••••••••" />
      </div>
    </div>
    <div class="actions">
      <button id="btnLogin">Login</button>
      <button class="ghost" id="btnLogout">Logout</button>
      <button class="secondary" id="btnRefresh">Refresh tables</button>
    </div>
    <div id="loginMsg" class="small muted"></div>
  </div>

  <div class="card">
    <h2>2) Create new account (Org + Location + Admin/User)</h2>
    <div class="small muted">This creates (optionally) an org (with chosen ID), a location (with chosen ID), and a user tied to that location/org.</div>

    <div class="row3">
      <div>
        <label>Org ID (existing or new)</label>
        <input id="newOrgId" placeholder="e.g. 4" />
        <div class="small muted">Leave blank to auto-pick next available.</div>
      </div>
      <div>
        <label>Org name (if creating new org)</label>
        <input id="newOrgName" placeholder="e.g. Stella Maris Pharmacy" />
      </div>
      <div>
        <label>Location ID (new)</label>
        <input id="newLocationId" placeholder="e.g. 10" />
        <div class="small muted">Leave blank to auto-pick next available.</div>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Location name</label>
        <input id="newLocationName" placeholder="e.g. Stella Maris Pharmacy" />
      </div>
      <div>
        <label>Active (1/0)</label>
        <input id="newActive" value="1" />
      </div>
    </div>

    <div class="row3">
      <div>
        <label>User email</label>
        <input id="newEmail" placeholder="noelpace89@gmail.com" />
      </div>
      <div>
        <label>User password</label>
        <input id="newPassword" type="password" placeholder="Set a password" />
      </div>
      <div>
        <label>Role (admin/user)</label>
        <select id="newRole">
          <option value="admin">admin</option>
          <option value="user">user</option>
        </select>
      </div>
    </div>

    <div class="actions">
      <button id="btnCreateAccount">Create account</button>
      <button class="ghost" id="btnPrefillIds">Prefill next IDs</button>
    </div>
    <div id="createMsg"></div>
  </div>

  <div class="card">
    <h2>3) Orgs</h2>
    <div class="small muted">Orgs are tenants/owners. Locations and users belong to one org.</div>
    <div id="orgsWrap"></div>
  </div>

  <div class="card">
    <h2>4) Locations</h2>
    <div class="small muted">Edit location name/org, wipe all data for a location, or delete a location.</div>
    <div id="locationsWrap"></div>
  </div>

  <div class="card">
    <h2>5) Users</h2>
    <div class="small muted">Edit user details, hold/unhold (active), reset password, or delete.</div>
    <div id="usersWrap"></div>
  </div>

</main>

<script>
  const $ = (id) => document.getElementById(id);

  function getToken(){ return localStorage.getItem("su_token") || ""; }
  function setToken(t){ localStorage.setItem("su_token", t); }
  function clearToken(){ localStorage.removeItem("su_token"); }

  function hdrs(){
    const t = getToken();
    return t ? { "Authorization": "Bearer " + t } : {};
  }

  function showMsg(el, ok, msg){
    el.className = ok ? "ok" : "err";
    el.textContent = msg;
  }

  async function api(path, opts={}){
    const res = await fetch(path, {
      ...opts,
      headers: {
        "Content-Type": "application/json",
        ...hdrs(),
        ...(opts.headers||{})
      }
    });
    const data = await res.json().catch(()=>({}));
    if(!res.ok || data.ok === false){
      const err = data && data.error ? data.error : ("HTTP " + res.status);
      throw new Error(err);
    }
    return data;
  }

  async function login(){
    const email = $("loginEmail").value.trim().toLowerCase();
    const password = $("loginPassword").value;
    $("loginMsg").textContent = "Logging in...";
    const res = await fetch("/auth/login", {
      method: "POST",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify({ email, password })
    });
    const data = await res.json().catch(()=>({}));
    if(!res.ok || !data.ok){
      $("loginMsg").textContent = "Login failed: " + (data.error || ("HTTP " + res.status));
      return;
    }
    setToken(data.token);
    $("loginMsg").textContent = "Logged in. Token stored locally. Refresh tables.";
  }

  async function prefillIds(){
    try{
      const data = await api("/su/api/overview", { method:"GET" });
      $("newOrgId").value = data.next_org_id;
      $("newLocationId").value = data.next_location_id;
      $("createMsg").textContent = "Prefilled next IDs.";
      $("createMsg").className = "ok";
    }catch(e){
      showMsg($("createMsg"), false, e.message);
    }
  }

  function renderTable(rows, cols){
    if(!rows || rows.length===0) return "<div class='small muted'>No data.</div>";
    const thead = "<tr>" + cols.map(c=>"<th>"+c.label+"</th>").join("") + "</tr>";
    const tbody = rows.map(r=>{
      return "<tr>" + cols.map(c=>{
        const v = (typeof c.render==="function") ? c.render(r) : (r[c.key] ?? "");
        return "<td>"+v+"</td>";
      }).join("") + "</tr>";
    }).join("");
    return "<table><thead>"+thead+"</thead><tbody>"+tbody+"</tbody></table>";
  }

  async function refresh(){
    try{
      const data = await api("/su/api/overview", { method:"GET" });
      // Orgs
      $("orgsWrap").innerHTML = renderTable(data.orgs, [
        {label:"ID", key:"id"},
        {label:"Name", key:"name"},
        {label:"Created", key:"created_at"},
        {label:"Actions", render:(r)=> (
          '<button class="ghost" onclick="editOrg(' + r.id + ')">Edit</button> ' +
          '<button class="danger" onclick="deleteOrg(' + r.id + ', 0)">Delete</button> ' +
          '<button class="danger" onclick="deleteOrg(' + r.id + ', 1)">Force delete</button>'
        )}
      ]);

      // Locations
      $("locationsWrap").innerHTML = renderTable(data.locations, [
        {label:"ID", key:"id"},
        {label:"Org", key:"org_id"},
        {label:"Name", key:"name"},
        {label:"Created", key:"created_at"},
        {label:"Actions", render:(r)=>(
          '<button class="ghost" onclick="editLocation(' + r.id + ')">Edit</button> ' +
          '<button class="secondary" onclick="wipeLocation(' + r.id + ')">Wipe data</button> ' +
          '<button class="danger" onclick="deleteLocation(' + r.id + ')">Delete</button>'
        )}
      ]);

      // Users
      $("usersWrap").innerHTML = renderTable(data.users, [
        {label:"ID", key:"id"},
        {label:"Email", key:"email"},
        {label:"Name", key:"full_name"},
        {label:"Role", key:"role"},
        {label:"Active", key:"is_active"},
        {label:"Org", key:"org_id"},
        {label:"Default Location", render:(r)=>String(r.default_location_id) + " - " + (r.location_name || "")},
        {label:"Created", key:"created_at"},
        {label:"Actions", render:(r)=>(
          '<button class="ghost" onclick="editUser(' + r.id + ')">Edit</button> ' +
          '<button class="secondary" onclick="resetPassword(' + r.id + ')">Reset password</button> ' +
          '<button class="secondary" onclick="toggleHold(' + r.id + ', ' + r.is_active + ')">' + (r.is_active ? "Hold" : "Unhold") + '</button> ' +
          '<button class="danger" onclick="deleteUser(' + r.id + ')">Delete</button>'
        )}
      ]);

      $("loginMsg").textContent = "Loaded " + data.users.length + " user(s), " + data.locations.length + " location(s), " + data.orgs.length + " org(s).";
    }catch(e){
      $("loginMsg").textContent = "Refresh failed: " + e.message;
    }
  }

  async function createAccount(){
    const body = {
      org_id: $("newOrgId").value.trim(),
      org_name: $("newOrgName").value.trim(),
      location_id: $("newLocationId").value.trim(),
      location_name: $("newLocationName").value.trim(),
      email: $("newEmail").value.trim().toLowerCase(),
      password: $("newPassword").value,
      role: $("newRole").value,
      is_active: $("newActive").value.trim()
    };
    try{
      const data = await api("/su/api/account", { method:"POST", body: JSON.stringify(body) });
      showMsg($("createMsg"), true, "Created. Org " + data.org_id + ", Location " + data.location_id + ", User " + data.user_id);
      await refresh();
    }catch(e){
      showMsg($("createMsg"), false, e.message);
    }
  }

  async function editUser(userId){
    const data = await api("/su/api/users/" + userId, { method:"GET" });
    const u = data.user;
    const email = prompt("Email:", u.email) ?? "";
    if(email === "") return;
    const full_name = prompt("Full name:", u.full_name) ?? "";
    const role = prompt("Role (admin/user):", u.role) ?? "";
    const is_active = prompt("Active (1/0):", String(u.is_active)) ?? "";
    const org_id = prompt("Org ID:", String(u.org_id)) ?? "";
    const default_location_id = prompt("Default location ID:", String(u.default_location_id)) ?? "";
    try{
      await api("/su/api/users/" + userId, { method:"PUT", body: JSON.stringify({ email, full_name, role, is_active, org_id, default_location_id }) });
      await refresh();
    }catch(e){ alert(e.message); }
  }

  async function resetPassword(userId){
    const pw = prompt("Enter NEW password (will overwrite):");
    if(!pw) return;
    try{
      await api("/su/api/users/" + userId + "/password", { method:"POST", body: JSON.stringify({ password: pw }) });
      alert("Password updated.");
    }catch(e){ alert(e.message); }
  }

  async function toggleHold(userId, isActive){
    const newVal = isActive ? 0 : 1;
    try{
      await api("/su/api/users/" + userId, { method:"PUT", body: JSON.stringify({ is_active: String(newVal) }) });
      await refresh();
    }catch(e){ alert(e.message); }
  }

  async function deleteUser(userId){
    if(!confirm("Delete user " + userId + "? This cannot be undone.")) return;
    try{
      await api("/su/api/users/" + userId, { method:"DELETE" });
      await refresh();
    }catch(e){ alert(e.message); }
  }


  async function editOrg(orgId){
    try{
      const data = await api("/su/api/orgs/" + orgId, { method:"GET" });
      const o = data.org;
      const name = prompt("Org name:", o.name) ?? "";
      if(name === "") return;
      await api("/su/api/orgs/" + orgId, { method:"PUT", body: JSON.stringify({ name }) });
      await refresh();
    }catch(e){ alert(e.message); }
  }

  async function deleteOrg(orgId, force){
    const token = force ? "DELETE ALL" : "DELETE";
    const msg = force
      ? ("Type " + token + " to permanently DELETE org_id=" + orgId + " and ALL data (locations, users, and module rows).")
      : ("Type " + token + " to delete org_id=" + orgId + " (only works if it has no locations/users).");
    const confirmText = prompt(msg);
    if(confirmText !== token) return;
    try{
      const url = "/su/api/orgs/" + orgId + (force ? "?force=1" : "");
      await api(url, { method:"DELETE", body: JSON.stringify({ confirm: confirmText }) });
      await refresh();
    }catch(e){ alert(e.message); }
  }

  async function editLocation(locationId){
    const data = await api("/su/api/locations/" + locationId, { method:"GET" });
    const l = data.location;
    const name = prompt("Location name:", l.name) ?? "";
    if(name === "") return;
    const org_id = prompt("Org ID:", String(l.org_id)) ?? "";
    try{
      await api("/su/api/locations/" + locationId, { method:"PUT", body: JSON.stringify({ name, org_id }) });
      await refresh();
    }catch(e){ alert(e.message); }
  }

  async function wipeLocation(locationId){
    const confirmText = prompt("Type WIPE to delete ALL rows for location_id="+locationId+" (all module tables).");
    if(confirmText !== "WIPE") return;
    const alsoUsers = confirm("Also delete users whose default_location_id = " + locationId + " ? (OK = yes, Cancel = no)");
    try{
      await api("/su/api/locations/" + locationId + "/wipe", { method:"POST", body: JSON.stringify({ delete_users: alsoUsers ? 1 : 0 }) });
      await refresh();
      alert("Wipe completed.");
    }catch(e){ alert(e.message); }
  }

  async function deleteLocation(locationId){
    const confirmText = prompt("Type DELETE to delete location_id="+locationId+" (location row). This may fail if foreign keys exist.");
    if(confirmText !== "DELETE") return;
    try{
      await api("/su/api/locations/" + locationId, { method:"DELETE" });
      await refresh();
      alert("Location deleted.");
    }catch(e){ alert(e.message); }
  }

  $("btnLogin").onclick = login;
  $("btnLogout").onclick = ()=>{ clearToken(); $("loginMsg").textContent="Logged out (token cleared)."; };
  $("btnRefresh").onclick = refresh;
  $("btnCreateAccount").onclick = createAccount;
  $("btnPrefillIds").onclick = prefillIds;

  // Auto-refresh if token exists
  if(getToken()) refresh();
</script>
</body>
</html>`;
  return htmlResponse(html, 200, { "Cache-Control":"no-store" });
}

async function suNextIds(env) {
  const orgMax = await dbFirst(env, "SELECT IFNULL(MAX(id), 0) AS m FROM orgs", []);
  const locMax = await dbFirst(env, "SELECT IFNULL(MAX(id), 0) AS m FROM locations", []);
  return { next_org_id: (orgMax?.m || 0) + 1, next_location_id: (locMax?.m || 0) + 1 };
}

async function handleSuOverview(request, env, extraHeaders) {
  const orgs = await dbAll(env, "SELECT id, name, created_at FROM orgs ORDER BY id", []);
  const locations = await dbAll(env, "SELECT id, org_id, name, created_at FROM locations ORDER BY id", []);
  const users = await dbAll(env, `
    SELECT u.id, u.email, u.full_name, u.role, u.is_active, u.org_id, u.default_location_id, u.created_at,
           l.name AS location_name
    FROM users u
    LEFT JOIN locations l ON l.id = u.default_location_id
    ORDER BY u.id
  `, []);
  const ids = await suNextIds(env);
  return jsonResponse({ ok: true, ...ids, orgs, locations, users }, 200, extraHeaders);
}


async function handleSuGetOrg(request, env, extraHeaders, orgId) {
  const org = await dbFirst(env, "SELECT id, name, created_at FROM orgs WHERE id=?", [orgId]);
  if (!org) return jsonResponse({ ok:false, error:"org not found" }, 404, extraHeaders);
  return jsonResponse({ ok:true, org }, 200, extraHeaders);
}

async function handleSuUpdateOrg(request, env, extraHeaders, orgId) {
  const body = await readJson(request);
  const name = String(body.name || "").trim();
  if (!name) return jsonResponse({ ok:false, error:"name is required" }, 400, extraHeaders);

  const org = await dbFirst(env, "SELECT id FROM orgs WHERE id=?", [orgId]);
  if (!org) return jsonResponse({ ok:false, error:"org not found" }, 404, extraHeaders);

  await dbRun(env, "UPDATE orgs SET name=? WHERE id=?", [name, orgId]);
  return jsonResponse({ ok:true }, 200, extraHeaders);
}

async function handleSuDeleteOrg(request, env, extraHeaders, orgId, force) {
  const body = await readJson(request);
  const confirm = String(body.confirm || "").trim();

  const org = await dbFirst(env, "SELECT id, name FROM orgs WHERE id=?", [orgId]);
  if (!org) return jsonResponse({ ok:false, error:"org not found" }, 404, extraHeaders);

  if (!force) {
    if (confirm !== "DELETE") return jsonResponse({ ok:false, error:"confirm must be DELETE" }, 400, extraHeaders);

    const locCount = await dbFirst(env, "SELECT COUNT(1) AS c FROM locations WHERE org_id=?", [orgId]);
    const userCount = await dbFirst(env, "SELECT COUNT(1) AS c FROM users WHERE org_id=?", [orgId]);
    const lc = locCount?.c || 0;
    const uc = userCount?.c || 0;
    if (lc > 0 || uc > 0) {
      return jsonResponse({ ok:false, error:"org not empty", locations: lc, users: uc }, 400, extraHeaders);
    }
    await dbRun(env, "DELETE FROM orgs WHERE id=?", [orgId]);
    return jsonResponse({ ok:true }, 200, extraHeaders);
  }

  // Force delete: wipes all module tables for all locations under the org, deletes users/sessions, deletes locations, then deletes org.
  if (confirm !== "DELETE ALL") return jsonResponse({ ok:false, error:"confirm must be DELETE ALL" }, 400, extraHeaders);

  const locs = await dbAll(env, "SELECT id FROM locations WHERE org_id=? ORDER BY id", [orgId]);
  const tables = await suTablesWithLocationId(env);

  // Wipe module tables per location
  for (const l of locs) {
    const locationId = l.id;
    for (const t of tables) {
      try { await dbRun(env, `DELETE FROM ${t} WHERE location_id=?`, [locationId]); } catch {}
    }
    // Remove users tied to that location (and sessions)
    try { await dbRun(env, "DELETE FROM sessions WHERE user_id IN (SELECT id FROM users WHERE default_location_id=?)", [locationId]); } catch {}
    try { await dbRun(env, "DELETE FROM users WHERE default_location_id=?", [locationId]); } catch {}
  }

  // Also delete any remaining sessions/users in the org (belt and braces)
  try { await dbRun(env, "DELETE FROM sessions WHERE user_id IN (SELECT id FROM users WHERE org_id=?)", [orgId]); } catch {}
  try { await dbRun(env, "DELETE FROM users WHERE org_id=?", [orgId]); } catch {}

  // Delete locations then org
  await dbRun(env, "DELETE FROM locations WHERE org_id=?", [orgId]);
  await dbRun(env, "DELETE FROM orgs WHERE id=?", [orgId]);

  return jsonResponse({ ok:true, deleted_locations: locs.length, wiped_tables: tables }, 200, extraHeaders);
}


function parseIntOrNull(v) {
  if (v === null || v === undefined) return null;
  const s = String(v).trim();
  if (!s) return null;
  const n = Number(s);
  if (!Number.isInteger(n) || n < 0) return null;
  return n;
}

async function handleSuCreateAccount(request, env, extraHeaders) {
  const body = await readJson(request);
  const email = String(body.email || "").trim().toLowerCase();
  const password = String(body.password || "");
  const role = String(body.role || "user").trim().toLowerCase();
  const isActive = parseIntOrNull(body.is_active);
  const orgIdRequested = parseIntOrNull(body.org_id);
  const orgName = String(body.org_name || "").trim();
  const locationIdRequested = parseIntOrNull(body.location_id);
  const locationName = String(body.location_name || "").trim();

  if (!email) return jsonResponse({ ok:false, error:"email is required" }, 400, extraHeaders);
  if (!password) return jsonResponse({ ok:false, error:"password is required" }, 400, extraHeaders);
  if (role !== "admin" && role !== "user") return jsonResponse({ ok:false, error:"role must be admin or user" }, 400, extraHeaders);
  if (!locationName) return jsonResponse({ ok:false, error:"location_name is required" }, 400, extraHeaders);

  const ids = await suNextIds(env);
  const orgId = orgIdRequested || ids.next_org_id;
  const locationId = locationIdRequested || ids.next_location_id;

  // Ensure email is unique
  const exists = await dbFirst(env, "SELECT id FROM users WHERE lower(email)=lower(?)", [email]);
  if (exists) return jsonResponse({ ok:false, error:"email already exists" }, 409, extraHeaders);

  // Ensure org exists or create it
  const orgRow = await dbFirst(env, "SELECT id FROM orgs WHERE id=?", [orgId]);
  if (!orgRow) {
    const name = orgName || locationName;
    // try to insert with explicit id
    await dbRun(env, "INSERT INTO orgs (id, name, created_at) VALUES (?, ?, datetime('now'))", [orgId, name]);
  }

  // Ensure location id unused
  const locRow = await dbFirst(env, "SELECT id FROM locations WHERE id=?", [locationId]);
  if (locRow) return jsonResponse({ ok:false, error:"location_id already exists" }, 409, extraHeaders);

  await dbRun(env, "INSERT INTO locations (id, org_id, name, created_at) VALUES (?, ?, ?, datetime('now'))", [locationId, orgId, locationName]);

  // Hash password (PBKDF2)
  const iters = 100000;
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const hash = await pbkdf2Hash(password, salt, iters);
  const saltB64 = base64FromBytes(salt);
  const hashB64 = base64FromBytes(hash);

  const fullName = String(body.full_name || "").trim() || email;
  const activeVal = (isActive === null) ? 1 : (isActive ? 1 : 0);

  const userRow = await dbFirst(
    env,
    `INSERT INTO users (org_id, email, full_name, role, pass_salt_b64, pass_hash_b64, pass_iters, is_active, default_location_id, created_at)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
     RETURNING id`,
    [orgId, email, fullName, role, saltB64, hashB64, iters, activeVal, locationId]
  );

  return jsonResponse({ ok:true, org_id: orgId, location_id: locationId, user_id: userRow?.id }, 200, extraHeaders);
}

async function handleSuGetUser(request, env, extraHeaders, userId) {
  const row = await dbFirst(env, `
    SELECT u.id, u.email, u.full_name, u.role, u.is_active, u.org_id, u.default_location_id, u.created_at,
           u.pass_salt_b64, u.pass_hash_b64, u.pass_iters
    FROM users u WHERE u.id=?
  `, [userId]);
  if (!row) return jsonResponse({ ok:false, error:"user not found" }, 404, extraHeaders);
  return jsonResponse({ ok:true, user: row }, 200, extraHeaders);
}

async function handleSuUpdateUser(request, env, extraHeaders, userId) {
  const body = await readJson(request);
  const existing = await dbFirst(env, "SELECT * FROM users WHERE id=?", [userId]);
  if (!existing) return jsonResponse({ ok:false, error:"user not found" }, 404, extraHeaders);

  const email = body.email !== undefined ? String(body.email).trim().toLowerCase() : existing.email;
  const full_name = body.full_name !== undefined ? String(body.full_name).trim() : existing.full_name;
  const role = body.role !== undefined ? String(body.role).trim().toLowerCase() : existing.role;
  const is_active = body.is_active !== undefined ? (parseIntOrNull(body.is_active) ? 1 : 0) : existing.is_active;
  const org_id = body.org_id !== undefined ? parseIntOrNull(body.org_id) : existing.org_id;
  const default_location_id = body.default_location_id !== undefined ? parseIntOrNull(body.default_location_id) : existing.default_location_id;

  if (!email) return jsonResponse({ ok:false, error:"email is required" }, 400, extraHeaders);
  if (role !== "admin" && role !== "user") return jsonResponse({ ok:false, error:"role must be admin or user" }, 400, extraHeaders);
  if (!org_id) return jsonResponse({ ok:false, error:"org_id is required" }, 400, extraHeaders);
  if (!default_location_id) return jsonResponse({ ok:false, error:"default_location_id is required" }, 400, extraHeaders);

  // Ensure org exists
  const orgRow = await dbFirst(env, "SELECT id FROM orgs WHERE id=?", [org_id]);
  if (!orgRow) return jsonResponse({ ok:false, error:"org_id does not exist" }, 400, extraHeaders);

  // Ensure location exists and belongs to org
  const locRow = await dbFirst(env, "SELECT id, org_id FROM locations WHERE id=?", [default_location_id]);
  if (!locRow) return jsonResponse({ ok:false, error:"default_location_id does not exist" }, 400, extraHeaders);
  if (Number(locRow.org_id) !== Number(org_id)) return jsonResponse({ ok:false, error:"default_location_id not in org" }, 400, extraHeaders);

  // Ensure email unique
  const dupe = await dbFirst(env, "SELECT id FROM users WHERE lower(email)=lower(?) AND id<>?", [email, userId]);
  if (dupe) return jsonResponse({ ok:false, error:"email already exists" }, 409, extraHeaders);

  await dbRun(env, `
    UPDATE users
    SET email=?, full_name=?, role=?, is_active=?, org_id=?, default_location_id=?
    WHERE id=?
  `, [email, full_name, role, is_active, org_id, default_location_id, userId]);

  return jsonResponse({ ok:true }, 200, extraHeaders);
}

async function handleSuResetPassword(request, env, extraHeaders, userId) {
  const body = await readJson(request);
  const password = String(body.password || "");
  if (!password) return jsonResponse({ ok:false, error:"password is required" }, 400, extraHeaders);

  const user = await dbFirst(env, "SELECT id FROM users WHERE id=?", [userId]);
  if (!user) return jsonResponse({ ok:false, error:"user not found" }, 404, extraHeaders);

  const iters = 100000;
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const hash = await pbkdf2Hash(password, salt, iters);
  const saltB64 = base64FromBytes(salt);
  const hashB64 = base64FromBytes(hash);

  await dbRun(env, "UPDATE users SET pass_salt_b64=?, pass_hash_b64=?, pass_iters=? WHERE id=?", [saltB64, hashB64, iters, userId]);
  // Best-effort: clear sessions for that user if sessions table exists
  try { await dbRun(env, "DELETE FROM sessions WHERE user_id=?", [userId]); } catch {}
  return jsonResponse({ ok:true }, 200, extraHeaders);
}

async function handleSuDeleteUser(request, env, extraHeaders, userId) {
  const user = await dbFirst(env, "SELECT id FROM users WHERE id=?", [userId]);
  if (!user) return jsonResponse({ ok:false, error:"user not found" }, 404, extraHeaders);
  try { await dbRun(env, "DELETE FROM sessions WHERE user_id=?", [userId]); } catch {}
  await dbRun(env, "DELETE FROM users WHERE id=?", [userId]);
  return jsonResponse({ ok:true }, 200, extraHeaders);
}

async function handleSuGetLocation(request, env, extraHeaders, locationId) {
  const row = await dbFirst(env, "SELECT id, org_id, name, created_at FROM locations WHERE id=?", [locationId]);
  if (!row) return jsonResponse({ ok:false, error:"location not found" }, 404, extraHeaders);
  return jsonResponse({ ok:true, location: row }, 200, extraHeaders);
}

async function handleSuUpdateLocation(request, env, extraHeaders, locationId) {
  const body = await readJson(request);
  const existing = await dbFirst(env, "SELECT id, org_id, name FROM locations WHERE id=?", [locationId]);
  if (!existing) return jsonResponse({ ok:false, error:"location not found" }, 404, extraHeaders);

  const name = body.name !== undefined ? String(body.name).trim() : existing.name;
  const org_id = body.org_id !== undefined ? parseIntOrNull(body.org_id) : existing.org_id;

  if (!name) return jsonResponse({ ok:false, error:"name is required" }, 400, extraHeaders);
  if (!org_id) return jsonResponse({ ok:false, error:"org_id is required" }, 400, extraHeaders);

  const orgRow = await dbFirst(env, "SELECT id FROM orgs WHERE id=?", [org_id]);
  if (!orgRow) return jsonResponse({ ok:false, error:"org_id does not exist" }, 400, extraHeaders);

  // If moving org, ensure no users in other org reference this location as default unless you also move them.
  const usersUsing = await dbFirst(env, "SELECT COUNT(*) AS c FROM users WHERE default_location_id=?", [locationId]);
  const count = Number(usersUsing?.c || 0);
  if (count > 0) {
    // Enforce: users pointing to location must be moved to same org
    await dbRun(env, "UPDATE users SET org_id=? WHERE default_location_id=?", [org_id, locationId]);
  }

  await dbRun(env, "UPDATE locations SET org_id=?, name=? WHERE id=?", [org_id, name, locationId]);
  return jsonResponse({ ok:true }, 200, extraHeaders);
}

async function suTablesWithLocationId(env) {
  // Enumerate all user tables that contain a location_id column.
  const tables = await dbAll(env, "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'", []);
  const out = [];
  for (const t of tables) {
    const name = t.name;
    if (["orgs","locations","users"].includes(name)) continue;
    try {
      const cols = await dbAll(env, `PRAGMA table_info(${name})`, []);
      const hasLoc = cols.some(c => c.name === "location_id");
      if (hasLoc) out.push(name);
    } catch {}
  }
  return out;
}

async function handleSuWipeLocation(request, env, extraHeaders, locationId) {
  const body = await readJson(request);
  const deleteUsers = parseIntOrNull(body.delete_users) ? 1 : 0;

  const loc = await dbFirst(env, "SELECT id, org_id FROM locations WHERE id=?", [locationId]);
  if (!loc) return jsonResponse({ ok:false, error:"location not found" }, 404, extraHeaders);

  const tables = await suTablesWithLocationId(env);
  for (const t of tables) {
    // delete rows scoped to location
    try { await dbRun(env, `DELETE FROM ${t} WHERE location_id=?`, [locationId]); } catch {}
  }
  if (deleteUsers) {
    try { await dbRun(env, "DELETE FROM sessions WHERE user_id IN (SELECT id FROM users WHERE default_location_id=?)", [locationId]); } catch {}
    await dbRun(env, "DELETE FROM users WHERE default_location_id=?", [locationId]);
  }
  return jsonResponse({ ok:true, wiped_tables: tables }, 200, extraHeaders);
}

async function handleSuDeleteLocation(request, env, extraHeaders, locationId) {
  const loc = await dbFirst(env, "SELECT id FROM locations WHERE id=?", [locationId]);
  if (!loc) return jsonResponse({ ok:false, error:"location not found" }, 404, extraHeaders);
  // This may fail if foreign keys exist; caller can wipe first.
  await dbRun(env, "DELETE FROM locations WHERE id=?", [locationId]);
  return jsonResponse({ ok:true }, 200, extraHeaders);
}

async function readJson(request) {
  const ct = request.headers.get("Content-Type") || "";
  if (!ct.toLowerCase().includes("application/json")) {
    throw new Error("Expected application/json");
  }
  return await request.json();
}

async function dbFirst(env, sql, bind = []) {
  const stmt = env.DB.prepare(sql);
  const res = bind.length ? await stmt.bind(...bind).first() : await stmt.first();
  return res || null;
}

async function dbAll(env, sql, bind = []) {
  const stmt = env.DB.prepare(sql);
  const res = bind.length ? await stmt.bind(...bind).all() : await stmt.all();
  return res.results || [];
}

async function dbRun(env, sql, bind = []) {
  const stmt = env.DB.prepare(sql);
  const res = bind.length ? await stmt.bind(...bind).run() : await stmt.run();
  return res;
}

async function writeAudit(env, orgId, userId, action, entityType, entityId, detailsObj) {
  const detailsJson = JSON.stringify(detailsObj || {});
  await dbRun(
    env,
    `INSERT INTO audit_log (org_id, user_id, action, entity_type, entity_id, details_json, created_at)
     VALUES (?, ?, ?, ?, ?, ?, datetime('now'))`,
    [orgId, userId || null, action, entityType, entityId || "", detailsJson]
  );
}

function requireRole(user, roles) {
  return user && roles.includes(user.role);
}

async function authFromRequest(request, env) {
  const auth = request.headers.get("Authorization") || "";
  const m = auth.match(/^Bearer\s+(.+)$/i);
  if (!m) return null;

  const token = m[1].trim();
  if (!token) return null;

  const tokenHashB64 = await sha256B64FromString(token);

  const sess = await dbFirst(
    env,
    `SELECT
       s.id AS session_id,
       s.user_id,
       s.expires_at,
       u.org_id,
       u.email,
       u.full_name,
       u.role,
       u.is_active,
       u.default_location_id
     FROM sessions s
     JOIN users u ON u.id = s.user_id
     WHERE s.token_hash_b64 = ?`,
    [tokenHashB64]
  );

  if (!sess) return null;
  if (sess.is_active !== 1) return null;

  const now = new Date();
  const exp = new Date(sess.expires_at);
  if (!(exp > now)) return null;

  const locId = sess.default_location_id ? Number(sess.default_location_id) : null;
  if (!locId) return null;

  const loc = await dbFirst(env, "SELECT id, name FROM locations WHERE id = ? AND org_id = ?", [locId, sess.org_id]);
  if (!loc) return null;

  const org = await dbFirst(env, "SELECT id, name FROM orgs WHERE id = ?", [sess.org_id]);

  return {
    session_id: sess.session_id,
    user_id: sess.user_id,
    org_id: sess.org_id,
    org_name: org ? org.name : "",
    email: sess.email,
    full_name: sess.full_name,
    role: sess.role,
    location_id: loc.id,
    location_name: loc.name
  };
}

function htmlPage(title, bodyHtml) {
  return new Response(
    `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>${escapeHtml(title)}</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;max-width:820px;margin:40px auto;padding:0 16px;}
  .card{border:1px solid #ddd;border-radius:12px;padding:18px;margin-top:16px;}
  label{display:block;margin-top:10px;font-weight:700;}
  input{width:100%;padding:10px;border:1px solid #ccc;border-radius:10px;margin-top:6px;}
  button{margin-top:16px;padding:10px 14px;border:0;border-radius:10px;background:#111;color:#fff;font-weight:800;cursor:pointer;}
  code{background:#f6f6f6;padding:2px 6px;border-radius:6px;}
  .ok{color:green;font-weight:800;}
  .err{color:#b00020;font-weight:800;}
</style>
</head>
<body>
${bodyHtml}
</body>
</html>`,
    { headers: { "Content-Type": "text/html; charset=utf-8" } }
  );
}

async function parseForm(request) {
  const ct = (request.headers.get("Content-Type") || "").toLowerCase();
  if (!ct.includes("application/x-www-form-urlencoded") && !ct.includes("multipart/form-data")) {
    return null;
  }
  const form = await request.formData();
  const obj = {};
  for (const [k, v] of form.entries()) obj[k] = String(v);
  return obj;
}

async function handleBootstrapGet(request, env) {
  const usersCountRow = await dbFirst(env, "SELECT COUNT(*) AS c FROM users", []);
  const hasUsers = usersCountRow && usersCountRow.c > 0;

  const body = `
<h1>Eikon API Bootstrap</h1>
<div class="card">
  <p>This creates the <b>first</b> org, location, and admin user.</p>
  <p>Status: ${hasUsers ? `<span class="err">Bootstrap disabled (users already exist)</span>` : `<span class="ok">Ready</span>`}</p>
  <form method="POST" action="/bootstrap">
    <label>Bootstrap Token</label>
    <input name="bootstrap_token" required />
    <label>Org / Client Name</label>
    <input name="org_name" required value="Demo Pharmacy"/>
    <label>Default Location Name</label>
    <input name="location_name" required value="Main Branch"/>
    <label>Admin Email</label>
    <input name="admin_email" required value="admin@example.com"/>
    <label>Admin Full Name</label>
    <input name="admin_full_name" required value="Admin"/>
    <label>Admin Password</label>
    <input name="admin_password" type="password" required />
    <button type="submit" ${hasUsers ? "disabled" : ""}>Create Admin</button>
  </form>
  <p style="margin-top:12px;color:#555;">Note: location is tied to account (no switching).</p>
</div>`;
  return htmlPage("Bootstrap", body);
}

async function handleBootstrapPost(request, env) {
  try {
    const usersCountRow = await dbFirst(env, "SELECT COUNT(*) AS c FROM users", []);
    const hasUsers = usersCountRow && usersCountRow.c > 0;
    if (hasUsers) {
      return htmlPage("Bootstrap", `<h1>Bootstrap disabled</h1><p class="err">Users already exist.</p>`);
    }

    let payload = await parseForm(request);
    if (!payload) {
      try { payload = await readJson(request); } catch { payload = {}; }
    }

    const bootstrapToken = (payload.bootstrap_token || "").trim();
    const orgName = (payload.org_name || "").trim();
    const locationName = (payload.location_name || "").trim();
    const adminEmail = (payload.admin_email || "").trim().toLowerCase();
    const adminFullName = (payload.admin_full_name || "").trim();
    const adminPassword = (payload.admin_password || "").trim();

    if (!bootstrapToken || !orgName || !locationName || !adminEmail || !adminPassword) {
      return htmlPage("Bootstrap error", `<h1>Bootstrap error</h1><p class="err">Missing required fields.</p>`);
    }

    if ((env.BOOTSTRAP_TOKEN || "").trim() !== bootstrapToken) {
      return htmlPage("Bootstrap error", `<h1>Bootstrap error</h1><p class="err">Invalid bootstrap token.</p>`);
    }

    const orgRow = await dbFirst(
      env,
      "INSERT INTO orgs (name, created_at) VALUES (?, datetime('now')) RETURNING id",
      [orgName]
    );
    const orgId = orgRow.id;

    const locRow = await dbFirst(
      env,
      "INSERT INTO locations (org_id, name, created_at) VALUES (?, ?, datetime('now')) RETURNING id",
      [orgId, locationName]
    );
    const locationId = locRow.id;

    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iters = 100000;
    const hash = await pbkdf2Hash(adminPassword, salt, iters);
    const saltB64 = base64FromBytes(salt);
    const hashB64 = base64FromBytes(hash);

    const userRow = await dbFirst(
      env,
      `INSERT INTO users (org_id, email, full_name, role, pass_salt_b64, pass_hash_b64, pass_iters, is_active, default_location_id, created_at)
       VALUES (?, ?, ?, 'admin', ?, ?, ?, 1, ?, datetime('now'))
       RETURNING id`,
      [orgId, adminEmail, adminFullName, saltB64, hashB64, iters, locationId]
    );
    const userId = userRow.id;

    await writeAudit(env, orgId, userId, "BOOTSTRAP_CREATE", "org", String(orgId), { org_name: orgName });
    await writeAudit(env, orgId, userId, "BOOTSTRAP_CREATE", "location", String(locationId), { location_name: locationName });
    await writeAudit(env, orgId, userId, "BOOTSTRAP_CREATE", "user", String(userId), { email: adminEmail, role: "admin", default_location_id: locationId });

    return htmlPage(
      "Bootstrap complete",
      `<h1>Bootstrap complete</h1>
<div class="card">
  <p class="ok">Created org, location, and admin user.</p>
  <p><b>Org ID:</b> ${orgId}</p>
  <p><b>Location ID:</b> ${locationId}</p>
  <p><b>Admin Email:</b> ${escapeHtml(adminEmail)}</p>
  <p>Next: log in via <code>POST /auth/login</code>.</p>
</div>`
    );
  } catch (e) {
    return htmlPage(
      "Bootstrap error",
      `<h1>Bootstrap error</h1>
<p class="err">The Worker caught an exception.</p>
<pre style="white-space:pre-wrap;background:#f6f6f6;padding:12px;border-radius:10px;border:1px solid #ddd;">${escapeHtml(e && (e.stack || e.message || String(e)))}</pre>`
    );
  }
}

async function handleLogin(request, env, corsOkHeaders) {
  const body = await readJson(request);
  const email = (body.email || "").trim().toLowerCase();
  const password = (body.password || "").trim();

  if (!email || !password) {
    return jsonResponse({ ok: false, error: "Missing email or password" }, 400, corsOkHeaders);
  }

  const user = await dbFirst(
    env,
    `SELECT id, org_id, email, full_name, role, pass_salt_b64, pass_hash_b64, pass_iters, is_active, default_location_id
     FROM users WHERE email = ?`,
    [email]
  );

  if (!user || user.is_active !== 1) {
    return jsonResponse({ ok: false, error: "Invalid credentials" }, 401, corsOkHeaders);
  }

  const saltBytes = bytesFromBase64(user.pass_salt_b64);
  const derived = await pbkdf2Hash(password, saltBytes, user.pass_iters);
  const stored = bytesFromBase64(user.pass_hash_b64);

  if (!constantTimeEqual(derived, stored)) {
    return jsonResponse({ ok: false, error: "Invalid credentials" }, 401, corsOkHeaders);
  }

  const locId = user.default_location_id ? Number(user.default_location_id) : null;
  if (!locId) return jsonResponse({ ok: false, error: "Account has no assigned location" }, 403, corsOkHeaders);

  const loc = await dbFirst(env, "SELECT id, name FROM locations WHERE id = ? AND org_id = ?", [locId, user.org_id]);
  if (!loc) return jsonResponse({ ok: false, error: "Assigned location invalid" }, 403, corsOkHeaders);

  const ttl = parseInt(env.SESSION_TTL_SECONDS || "2592000", 10);
  const tokenRaw = crypto.getRandomValues(new Uint8Array(32));
  const token = base64UrlFromBytes(tokenRaw);
  const tokenHashB64 = await sha256B64FromString(token);
  const exp = new Date(Date.now() + ttl * 1000).toISOString();

  await dbRun(
    env,
    "INSERT INTO sessions (user_id, token_hash_b64, expires_at, created_at) VALUES (?, ?, ?, datetime('now'))",
    [user.id, tokenHashB64, exp]
  );

  await writeAudit(env, user.org_id, user.id, "LOGIN", "user", String(user.id), { email: user.email });

  return jsonResponse(
    {
      ok: true,
      token,
      user: {
        id: user.id,
        org_id: user.org_id,
        email: user.email,
        full_name: user.full_name,
        role: user.role,
        location_id: loc.id,
        location_name: loc.name,
        org_name: (await dbFirst(env, "SELECT name FROM orgs WHERE id = ?", [user.org_id]))?.name || ""
      }
    },
    200,
    corsOkHeaders
  );
}

async function handleMe(env, corsOkHeaders, authUser) {
  return jsonResponse({ ok: true, user: authUser }, 200, corsOkHeaders);
}

function isValidYmd(s) {
  return /^\d{4}-\d{2}-\d{2}$/.test(String(s || "").trim());
}

function isValidYm(s) {
  return /^\d{4}-\d{2}$/.test(String(s || "").trim());
}

function isValidHm(s) {
  return /^([01]\d|2[0-3]):[0-5]\d$/.test(String(s || "").trim());
}

async function ensureEndOfDaySchema(env) { await dbRun(env, "CREATE TABLE IF NOT EXISTS end_of_day (id INTEGER PRIMARY KEY AUTOINCREMENT, org_id INTEGER NOT NULL, location_id INTEGER NOT NULL, eod_date TEXT NOT NULL, time_of_day TEXT NOT NULL DEFAULT 'AM', staff_name TEXT NOT NULL, float_amount REAL NOT NULL DEFAULT 500, x_json TEXT NOT NULL DEFAULT '[]', epos_json TEXT NOT NULL DEFAULT '[]', cheques_json TEXT NOT NULL DEFAULT '[]', paid_outs_json TEXT NOT NULL DEFAULT '[]', cash_json TEXT NOT NULL DEFAULT '{}', bov_deposit_json TEXT NOT NULL DEFAULT '{}', bov_bag_number TEXT NOT NULL DEFAULT '', bov_contact_id INTEGER, notes TEXT NOT NULL DEFAULT '', saved_at TEXT, locked_at TEXT, created_at TEXT NOT NULL DEFAULT (datetime('now')), updated_at TEXT NOT NULL DEFAULT (datetime('now')), created_by INTEGER, updated_by INTEGER, UNIQUE(org_id, location_id, eod_date))", []); await dbRun(env, "CREATE TABLE IF NOT EXISTS end_of_day_contacts (id INTEGER PRIMARY KEY AUTOINCREMENT, org_id INTEGER NOT NULL, location_id INTEGER NOT NULL, display_name TEXT NOT NULL, phone TEXT NOT NULL DEFAULT '', email TEXT NOT NULL DEFAULT '', is_active INTEGER NOT NULL DEFAULT 1, created_at TEXT NOT NULL DEFAULT (datetime('now')), updated_at TEXT NOT NULL DEFAULT (datetime('now')), created_by INTEGER, updated_by INTEGER, UNIQUE(org_id, location_id, display_name))", []); await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_end_of_day_org_loc_date ON end_of_day (org_id, location_id, eod_date)", []); await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_end_of_day_contacts_org_loc_active ON end_of_day_contacts (org_id, location_id, is_active, display_name)", []); try { await dbRun(env, "ALTER TABLE end_of_day_contacts ADD COLUMN email TEXT NOT NULL DEFAULT ''", []); } catch (e) { /* column may already exist */ } }

function clampToOneDecimal(n) {
  if (n === null || n === undefined) return null;
  if (n === "") return null;
  const v = Number(n);
  if (!Number.isFinite(v)) return null;
  return Math.round(v * 10) / 10;
}

function monthRange(yyyyMm) {
  const m = String(yyyyMm || "").trim();
  if (!/^\d{4}-\d{2}$/.test(m)) return null;
  const [y, mo] = m.split("-").map(n => parseInt(n, 10));
  const start = new Date(Date.UTC(y, mo - 1, 1));
  const end = new Date(Date.UTC(y, mo, 1));
  return {
    startStr: start.toISOString().slice(0, 10),
    endStr: end.toISOString().slice(0, 10)
  };
}

async function ensureDefaultTempDevicesIfMissing(env, authUser) {
  const existing = await dbAll(
    env,
    "SELECT id FROM temperature_devices WHERE org_id = ? AND location_id = ? AND active = 1",
    [authUser.org_id, authUser.location_id]
  );
  if (existing.length > 0) return;

  if (!requireRole(authUser, ["admin"])) return;

  const defaults = [
    { name: "Pharmacy", device_type: "room", min_limit: 15, max_limit: 25 },
    { name: "Pharmacy Fridge", device_type: "fridge", min_limit: 2, max_limit: 8 }
  ];

  for (const d of defaults) {
    await dbRun(
      env,
      `INSERT INTO temperature_devices (org_id, location_id, name, device_type, min_limit, max_limit, active, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, 1, datetime('now'), datetime('now'))`,
      [authUser.org_id, authUser.location_id, d.name, d.device_type, d.min_limit, d.max_limit]
    );
  }

  await writeAudit(env, authUser.org_id, authUser.user_id, "TEMP_DEFAULT_DEVICES_CREATE", "location", String(authUser.location_id), {});
}

async function handleTempDevicesList(request, env, corsOkHeaders, authUser) {
  await ensureDefaultTempDevicesIfMissing(env, authUser);

  const includeInactive = (new URL(request.url)).searchParams.get("include_inactive") === "1";

  const devices = await dbAll(
    env,
    `SELECT id, name, device_type, min_limit, max_limit, active, created_at, updated_at
     FROM temperature_devices
     WHERE org_id = ? AND location_id = ?
       ${includeInactive ? "" : "AND active = 1"}
     ORDER BY active DESC, id ASC`,
    [authUser.org_id, authUser.location_id]
  );

  return jsonResponse({ ok: true, devices }, 200, corsOkHeaders);
}

async function handleTempDevicesCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const body = await readJson(request);
  const name = (body.name || "").trim();
  const deviceType = (body.device_type || "other").trim();
  const minLimit = body.min_limit === null || body.min_limit === undefined ? null : Number(body.min_limit);
  const maxLimit = body.max_limit === null || body.max_limit === undefined ? null : Number(body.max_limit);

  if (!name) return jsonResponse({ ok: false, error: "Missing name" }, 400, corsOkHeaders);
  if (!["room", "fridge", "other"].includes(deviceType)) return jsonResponse({ ok: false, error: "Invalid device_type" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO temperature_devices (org_id, location_id, name, device_type, min_limit, max_limit, active, created_at, updated_at)
     VALUES (?, ?, ?, ?, ?, ?, 1, datetime('now'), datetime('now'))
     RETURNING id`,
    [authUser.org_id, authUser.location_id, name, deviceType, minLimit, maxLimit]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "TEMP_DEVICE_CREATE", "temperature_devices", String(row.id), { name, device_type: deviceType });

  return jsonResponse({ ok: true, device_id: row.id }, 200, corsOkHeaders);
}

async function handleTempDevicesUpdate(request, env, corsOkHeaders, authUser, deviceId) {
  if (!requireRole(authUser, ["admin"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const body = await readJson(request);
  const name = body.name !== undefined ? String(body.name || "").trim() : undefined;
  const deviceType = body.device_type !== undefined ? String(body.device_type || "").trim() : undefined;
  const minLimit = body.min_limit !== undefined ? (body.min_limit === null ? null : Number(body.min_limit)) : undefined;
  const maxLimit = body.max_limit !== undefined ? (body.max_limit === null ? null : Number(body.max_limit)) : undefined;
  const active = body.active !== undefined ? (body.active ? 1 : 0) : undefined;

  const existing = await dbFirst(
    env,
    `SELECT id, name, device_type, min_limit, max_limit, active
     FROM temperature_devices
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [deviceId, authUser.org_id, authUser.location_id]
  );
  if (!existing) {
    const wantDebug = (request.headers.get("X-Eikon-Debug") || "") === "1";
    const payload = { ok: false, error: "Not found" };
    if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
    return jsonResponse(payload, 404, corsOkHeaders);
  }

  const newName = name !== undefined ? name : existing.name;
  const newType = deviceType !== undefined ? deviceType : existing.device_type;
  const newMin = minLimit !== undefined ? minLimit : existing.min_limit;
  const newMax = maxLimit !== undefined ? maxLimit : existing.max_limit;
  const newActive = active !== undefined ? active : existing.active;

  if (!newName) return jsonResponse({ ok: false, error: "Name cannot be empty" }, 400, corsOkHeaders);
  if (!["room", "fridge", "other"].includes(newType)) return jsonResponse({ ok: false, error: "Invalid device_type" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE temperature_devices
     SET name = ?, device_type = ?, min_limit = ?, max_limit = ?, active = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [newName, newType, newMin, newMax, newActive, deviceId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "TEMP_DEVICE_UPDATE", "temperature_devices", String(deviceId), {
    name: newName,
    device_type: newType,
    min_limit: newMin,
    max_limit: newMax,
    active: newActive
  });

  const out = { ok: true };
  if (isDebugEnabled(request)) out.debug = { entryId: entryId };
  return jsonResponse(out, 200, corsOkHeaders);
}

async function assertDeviceBelongsActive(env, orgId, locationId, deviceId) {
  const row = await dbFirst(
    env,
    `SELECT id, name, device_type, min_limit, max_limit, active
     FROM temperature_devices
     WHERE id = ? AND org_id = ? AND location_id = ? AND active = 1`,
    [deviceId, orgId, locationId]
  );
  return row || null;
}

async function handleTempEntriesList(request, env, corsOkHeaders, authUser, url) {
  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const entries = await dbAll(
    env,
    `SELECT
       e.id,
       e.entry_date,
       e.min_temp,
       e.max_temp,
       e.notes,
       e.created_by,
       e.created_at,
       e.updated_at,
       d.id AS device_id,
       d.name AS device_name,
       d.device_type,
       d.min_limit,
       d.max_limit,
       d.active AS device_active
     FROM temperature_entries e
     JOIN temperature_devices d ON d.id = e.device_id
     WHERE e.org_id = ?
       AND e.location_id = ?
       AND e.entry_date >= ?
       AND e.entry_date < ?
     ORDER BY e.entry_date DESC, d.id ASC`,
    [authUser.org_id, authUser.location_id, range.startStr, range.endStr]
  );

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleTempEntriesUpsert(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDefaultTempDevicesIfMissing(env, authUser);

  const body = await readJson(request);
  const deviceId = parseInt(body.device_id, 10);
  const entryDate = (body.entry_date || "").trim();
  const minTemp = clampToOneDecimal(body.min_temp);
  const maxTemp = clampToOneDecimal(body.max_temp);
  const notes = (body.notes || "").trim();

  if (!deviceId) return jsonResponse({ ok: false, error: "Missing device_id" }, 400, corsOkHeaders);
  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);

  const dev = await assertDeviceBelongsActive(env, authUser.org_id, authUser.location_id, deviceId);
  if (!dev) return jsonResponse({ ok: false, error: "Invalid device" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO temperature_entries
       (org_id, location_id, device_id, entry_date, min_temp, max_temp, notes, created_by, created_at, updated_at)
     VALUES
       (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     ON CONFLICT(org_id, location_id, device_id, entry_date)
     DO UPDATE SET
       min_temp = excluded.min_temp,
       max_temp = excluded.max_temp,
       notes = excluded.notes,
       updated_at = datetime('now')
     RETURNING id`,
    [authUser.org_id, authUser.location_id, deviceId, entryDate, minTemp, maxTemp, notes, authUser.user_id]
  );

  await dbRun(
    env,
    `INSERT INTO sync_jobs (org_id, module, op, payload_json, status, attempts, next_run_at, created_at, updated_at)
     VALUES (?, 'temperature', 'upsert_entry', ?, 'pending', 0, datetime('now'), datetime('now'), datetime('now'))`,
    [authUser.org_id, JSON.stringify({ entry_id: row.id })]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "TEMP_ENTRY_UPSERT", "temperature_entries", String(row.id), {
    entry_date: entryDate,
    device_id: deviceId,
    min_temp: minTemp,
    max_temp: maxTemp
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleTempEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const existing = await dbFirst(
    env,
    `SELECT id, device_id, entry_date
     FROM temperature_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM temperature_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await dbRun(
    env,
    `INSERT INTO sync_jobs (org_id, module, op, payload_json, status, attempts, next_run_at, created_at, updated_at)
     VALUES (?, 'temperature', 'delete_entry', ?, 'pending', 0, datetime('now'), datetime('now'), datetime('now'))`,
    [authUser.org_id, JSON.stringify({ entry_id: entryId })]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "TEMP_ENTRY_DELETE", "temperature_entries", String(entryId), {
    entry_date: existing.entry_date,
    device_id: existing.device_id
  });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleTempReport(request, env, corsOkHeaders, authUser, url) {
  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();
  if (!isValidYmd(from) || !isValidYmd(to)) {
    return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (to < from) {
    return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
  }

  const devices = await dbAll(
    env,
    `SELECT d.id, d.name, d.device_type, d.min_limit, d.max_limit, d.active
     FROM temperature_devices d
     WHERE d.org_id = ? AND d.location_id = ?
       AND (
         d.active = 1
         OR EXISTS (
           SELECT 1 FROM temperature_entries e
           WHERE e.device_id = d.id
             AND e.org_id = d.org_id
             AND e.location_id = d.location_id
             AND e.entry_date >= ?
             AND e.entry_date <= ?
         )
       )
     ORDER BY d.id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  const entries = await dbAll(
    env,
    `SELECT id, entry_date, device_id, min_temp, max_temp, notes
     FROM temperature_entries
     WHERE org_id = ? AND location_id = ?
       AND entry_date >= ?
       AND entry_date <= ?
     ORDER BY entry_date ASC, device_id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  return jsonResponse(
    {
      ok: true,
      org_name: authUser.org_name,
      location_name: authUser.location_name,
      from,
      to,
      devices,
      entries
    },
    200,
    corsOkHeaders
  );
}

function ymFromYmd(ymd) {
  return String(ymd || "").slice(0, 7);
}

function htmlReportPage(title, htmlBody) {
  return new Response(
    `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>${escapeHtml(title)}</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:22px;color:#111;}
  h1{margin:0 0 6px 0;font-size:20px;}
  .meta{color:#444;margin:0 0 16px 0;font-size:13px;}
  h2{margin:18px 0 8px 0;font-size:16px;}
  table{width:100%;border-collapse:collapse;margin-top:8px;}
  th,td{border:1px solid #bbb;padding:6px 8px;font-size:12px;vertical-align:top;}
  th{background:#f2f2f2;}
  .small{font-size:11px;color:#444;}
  @media print{
    .no-print{display:none;}
    body{margin:0;}
  }
</style>
</head>
<body>
<div class="no-print" style="margin-bottom:10px;">
  <button onclick="window.print()" style="padding:8px 12px;font-weight:700;">Print</button>
</div>
${htmlBody}
</body>
</html>`,
    {
      headers: {
        "Content-Type": "text/html; charset=utf-8",
        "Cache-Control": "no-store"
      }
    }
  );
}

async function handleTempReportHtml(request, env, corsOkHeaders, authUser, url) {
  const out = await handleTempReport(request, env, corsOkHeaders, authUser, url);
  const data = await out.json();

  if (!data.ok) return out;

  const devices = data.devices || [];
  const entries = data.entries || [];

  // Build map by date -> device_id -> {min,max}
  const map = new Map(); // date -> Map(device_id -> cell)
  for (const e of entries) {
    const d = e.entry_date;
    if (!map.has(d)) map.set(d, new Map());
    map.get(d).set(Number(e.device_id), {
      min: e.min_temp,
      max: e.max_temp
    });
  }

  // Group dates by month
  const dates = Array.from(map.keys()).sort();
  const byMonth = new Map();
  for (const d of dates) {
    const ym = ymFromYmd(d);
    if (!byMonth.has(ym)) byMonth.set(ym, []);
    byMonth.get(ym).push(d);
  }

  let body = "";
  body += `<h1>${escapeHtml(data.org_name || "Pharmacy")} — Temperature Report</h1>`;
  body += `<p class="meta">Location: ${escapeHtml(data.location_name || "")}<br/>Range: ${escapeHtml(data.from)} to ${escapeHtml(data.to)}</p>`;

  for (const [ym, dlist] of byMonth.entries()) {
    body += `<h2>${escapeHtml(ym)}</h2>`;
    body += `<table><thead><tr><th>Date</th>`;
    for (const dev of devices) {
      body += `<th>${escapeHtml(dev.name)}<div class="small">${escapeHtml(dev.device_type)}</div></th>`;
    }
    body += `</tr></thead><tbody>`;
    for (const d of dlist) {
      body += `<tr><td>${escapeHtml(d)}</td>`;
      const rowMap = map.get(d) || new Map();
      for (const dev of devices) {
        const cell = rowMap.get(Number(dev.id));
        if (!cell) body += `<td></td>`;
        else {
          const min = (cell.min === null || cell.min === undefined) ? "" : Number(cell.min).toFixed(1);
          const max = (cell.max === null || cell.max === undefined) ? "" : Number(cell.max).toFixed(1);
          body += `<td>${escapeHtml(min)}${min && max ? " / " : ""}${escapeHtml(max)}</td>`;
        }
      }
      body += `</tr>`;
    }
    body += `</tbody></table>`;
  }

  return htmlReportPage("Temperature Report", body);
}

/* =========================
   CLIENT ORDERS MODULE (API)
   ========================= */

async function ensureClientOrdersSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS client_orders_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,

      order_date TEXT NOT NULL,               -- YYYY-MM-DD
      client_name TEXT NOT NULL,
      client_phone TEXT NOT NULL DEFAULT '',
      client_alt_phone TEXT NOT NULL DEFAULT '',
      client_email TEXT NOT NULL DEFAULT '',
      client_address TEXT NOT NULL DEFAULT '',

      items_text TEXT NOT NULL,               -- free text (what they ordered)
      priority INTEGER NOT NULL DEFAULT 2,     -- 1=high,2=normal,3=low
      needed_by TEXT,                         -- YYYY-MM-DD or NULL
      pickup_date TEXT,                       -- YYYY-MM-DD or NULL
      deposit_amount REAL NOT NULL DEFAULT 0,  -- optional

      fulfilled INTEGER NOT NULL DEFAULT 0,    -- 0/1
      fulfilled_at TEXT,                      -- datetime when marked fulfilled

      notes TEXT NOT NULL DEFAULT '',

      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_client_orders_org_loc_date ON client_orders_entries (org_id, location_id, order_date)",
    []
  );
  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_client_orders_org_loc_fulfilled ON client_orders_entries (org_id, location_id, fulfilled, order_date)",
    []
  );
  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_client_orders_org_loc_client ON client_orders_entries (org_id, location_id, client_name)",
    []
  );
  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_client_orders_org_loc_priority ON client_orders_entries (org_id, location_id, priority)",
    []
  );

  // Backfill schema for existing deployments (safe if column already exists)
  const adds = [
    "ALTER TABLE client_orders_entries ADD COLUMN client_phone TEXT NOT NULL DEFAULT ''",
    "ALTER TABLE client_orders_entries ADD COLUMN client_alt_phone TEXT NOT NULL DEFAULT ''",
    "ALTER TABLE client_orders_entries ADD COLUMN client_email TEXT NOT NULL DEFAULT ''",
    "ALTER TABLE client_orders_entries ADD COLUMN client_address TEXT NOT NULL DEFAULT ''",
    "ALTER TABLE client_orders_entries ADD COLUMN items_text TEXT NOT NULL DEFAULT ''",
    "ALTER TABLE client_orders_entries ADD COLUMN pickup_date TEXT",
    "ALTER TABLE client_orders_entries ADD COLUMN deposit_amount REAL NOT NULL DEFAULT 0"
  ];

  for (const sql of adds) {
    try { await dbRun(env, sql, []); } catch (e) { /* ignore duplicate column */ }
  }

}

function normalizePriority(p) {
  const n = Number(p);
  if (!Number.isFinite(n)) return 2;
  const i = Math.floor(n);
  if (i === 1 || i === 2 || i === 3) return i;
  return 2;
}

function normalizeMoney(n) {
  if (n === null || n === undefined || n === "") return 0;
  const v = Number(n);
  if (!Number.isFinite(v) || v < 0) return null;
  // keep 2dp-ish
  return Math.round(v * 100) / 100;
}

function normalizeMaybeYmd(s) {
  const t = String(s ?? "").trim();
  if (!t) return null;
  return isValidYmd(t) ? t : "__INVALID__";
}

function clientOrderRowToUi(r) {
  if (!r) return r;
  const phone = r.client_phone || "";
  const alt = r.client_alt_phone || "";
  const email = r.client_email || "";
  const addr = r.client_address || "";
  const items = r.items_text || "";
  const orderDate = r.order_date || "";
  const pickup = r.pickup_date || null;
  const deposit = (r.deposit_amount === null || r.deposit_amount === undefined) ? 0 : r.deposit_amount;

  return {
    // DB names (keep for compatibility)
    ...r,

    // UI aliases (what your front-end likely expects)
    entry_date: orderDate,
    contact: phone,
    alternate: alt,
    email,
    address: addr,
    items,
    pick_up_date: pickup,
    deposit
  };
}


function nearExpiryRowToUi(r) {
  if (!r) return null;
  return {
    id: r.id,
    product_name: r.product_name,
    expiry_date: r.expiry_date,
    location: r.location || "",
    notes: r.notes || "",
    created_by: r.created_by,
    created_at: r.created_at,
    updated_at: r.updated_at,
    updated_by: r.updated_by
  };
}


async function ensureNearExpirySchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS near_expiry_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,

      product_name TEXT NOT NULL,
      expiry_date TEXT NOT NULL, -- YYYY-MM-DD

      location TEXT NOT NULL DEFAULT '',
      notes TEXT NOT NULL DEFAULT '',

      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_by INTEGER
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_near_expiry_org_loc_expiry ON near_expiry_entries (org_id, location_id, expiry_date)",
    []
  );
  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_near_expiry_org_loc_name ON near_expiry_entries (org_id, location_id, product_name)",
    []
  );
}

async function handleClientOrdersEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureClientOrdersSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  // fulfilled filter: "0", "1", or omit for all
  const fulfilledParam = (url.searchParams.get("fulfilled") || "").trim();
  const hasFulfilled = fulfilledParam === "0" || fulfilledParam === "1";
  const fulfilledVal = hasFulfilled ? Number(fulfilledParam) : null;

  const sql = `
    SELECT
      id,
      order_date,
      client_name,
      client_phone,
      client_alt_phone,
      client_email,
      client_address,
      items_text,
      priority,
      needed_by,
      pickup_date,
      deposit_amount,
      fulfilled,
      fulfilled_at,
      notes,
      created_by,
      created_at,
      updated_at
    FROM client_orders_entries
    WHERE org_id = ?
      AND location_id = ?
      AND order_date >= ?
      AND order_date < ?
      ${hasFulfilled ? "AND fulfilled = ?" : ""}
      ${hasQ ? `AND (
        order_date LIKE ?
        OR client_name LIKE ?
        OR client_phone LIKE ?
        OR client_email LIKE ?
        OR client_address LIKE ?
        OR items_text LIKE ?
        OR notes LIKE ?
      )` : ""}
    ORDER BY fulfilled ASC, order_date DESC, priority ASC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id, range.startStr, range.endStr];
  if (hasFulfilled) bind.push(fulfilledVal);
  if (hasQ) bind.push(qLike, qLike, qLike, qLike, qLike, qLike, qLike);

  const rows = await dbAll(env, sql, bind);
  const entries = rows.map(clientOrderRowToUi);
  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleClientOrdersEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureClientOrdersSchema(env);

  const body = await readJson(request);

  const orderDate = String(body.order_date || body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientPhone = String(body.client_phone || "").trim();
  const clientAltPhone = String(body.client_alt_phone ?? body.alternate ?? "").trim();
  const clientEmail = String(body.client_email || "").trim();
  const clientAddress = String(body.client_address || "").trim();
  const itemsText = String(body.items_text || body.items || "").trim();
  const priority = normalizePriority(body.priority);
  const neededBy = normalizeMaybeYmd(body.needed_by);
  const pickupDate = normalizeMaybeYmd(body.pickup_date);
  const depositAmount = normalizeMoney(body.deposit_amount);
  const fulfilled = body.fulfilled ? 1 : 0;
  const notes = String(body.notes || "").trim();

  if (!isValidYmd(orderDate)) return jsonResponse({ ok: false, error: "Invalid order_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!itemsText) return jsonResponse({ ok: false, error: "Missing items_text" }, 400, corsOkHeaders);

  if (neededBy === "__INVALID__") return jsonResponse({ ok: false, error: "Invalid needed_by (YYYY-MM-DD or empty)" }, 400, corsOkHeaders);
  if (pickupDate === "__INVALID__") return jsonResponse({ ok: false, error: "Invalid pickup_date (YYYY-MM-DD or empty)" }, 400, corsOkHeaders);
  if (depositAmount === null) return jsonResponse({ ok: false, error: "Invalid deposit_amount (>= 0)" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO client_orders_entries
    (org_id, location_id, order_date, client_name, client_phone, client_alt_phone, client_email, client_address,
    items_text, priority, needed_by, pickup_date, deposit_amount, fulfilled, fulfilled_at, notes, created_by, created_at, updated_at)
     VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CASE WHEN ? THEN datetime('now') ELSE NULL END, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [
      authUser.org_id,
      authUser.location_id,
      orderDate,
      clientName,
      clientPhone,
      clientAltPhone,
      clientEmail,
      clientAddress,
      itemsText,
      priority,
      neededBy,
      pickupDate,
      depositAmount,
      fulfilled,
      fulfilled ? 1 : 0,
      notes,
      authUser.user_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CLIENT_ORDER_CREATE", "client_orders_entries", String(row.id), {
    order_date: orderDate,
    client_name: clientName,
    priority,
    fulfilled
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleClientOrdersEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureClientOrdersSchema(env);

  // Parse + validate id (be strict, but accept numeric strings)
  const id = Number(entryId);
  if (!Number.isFinite(id) || id % 1 !== 0 || id <= 0) {
    return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  }

  // Load existing row first (enables partial updates safely)
  const existing = await dbFirst(
    env,
    "SELECT * FROM client_orders_entries WHERE org_id = ? AND location_id = ? AND id = ?",
    [authUser.org_id, authUser.location_id, id]
  );

  if (!existing) {
    return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
  }

  let body = null;
  try {
    body = await readJson(request);
  } catch (e) {
    return jsonResponse({ ok: false, error: "Invalid JSON body" }, 400, corsOkHeaders);
  }
  if (!body || typeof body !== "object") body = {};

  const has = (k) => Object.prototype.hasOwnProperty.call(body, k);

  // Merge fields: if caller didn’t send a field, keep existing DB value.
  const orderDate = has("order_date") ? String(body.order_date || "").trim() : String(existing.order_date || "").trim();
  const clientName = has("client_name") ? String(body.client_name || "").trim() : String(existing.client_name || "").trim();
  const clientPhone = has("client_phone") ? String(body.client_phone || "").trim() : String(existing.client_phone || "").trim();

  const clientAltPhone = has("client_alt_phone")
    ? String(body.client_alt_phone || "").trim()
    : String(existing.client_alt_phone || "").trim();

  const clientEmail = has("client_email")
    ? String(body.client_email || "").trim()
    : String(existing.client_email || "").trim();

  const clientAddress = has("client_address")
    ? String(body.client_address || "").trim()
    : String(existing.client_address || "").trim();

  const itemsText = has("items_text") ? String(body.items_text || "").trim() : String(existing.items_text || "").trim();

  const priority = has("priority") ? normalizePriority(body.priority) : Number(existing.priority);
  const neededBy = has("needed_by") ? String(body.needed_by || "").trim() : String(existing.needed_by || "").trim();
  const pickupDate = has("pickup_date") ? String(body.pickup_date || "").trim() : String(existing.pickup_date || "").trim();
  const notes = has("notes") ? String(body.notes || "").trim() : String(existing.notes || "").trim();

  // deposit_amount is NOT NULL in your schema: NEVER allow null through.
  // - If caller sends deposit_amount: normalize it (null/"" => 0)
  // - If caller doesn't send it: keep existing
  let depositAmount;
  if (has("deposit_amount")) {
    depositAmount = normalizeMoney(body.deposit_amount);
    // normalizeMoney returns null only for invalid non-empty input
    if (depositAmount === null) {
      return jsonResponse({ ok: false, error: "Invalid deposit_amount" }, 400, corsOkHeaders);
    }
  } else {
    depositAmount = normalizeMoney(existing.deposit_amount);
    if (depositAmount === null) depositAmount = 0;
  }

  // Fulfilled can be partial too
  const nextFulfilled = has("fulfilled") ? !!body.fulfilled : !!existing.fulfilled;

  let fulfilledAt = null;
  if (nextFulfilled) {
    if (has("fulfilled_at")) {
      // if caller sends a value use it; if they send null/"" fallback to now
      const raw = body.fulfilled_at;
      fulfilledAt = raw ? String(raw) : nowIso();
    } else {
      // keep existing if present, otherwise set now
      fulfilledAt = existing.fulfilled_at ? String(existing.fulfilled_at) : nowIso();
    }
  } else {
    // unfulfilled means no timestamp
    fulfilledAt = null;
  }

  // Validate required + formats (after merge)
  if (!isValidYmd(orderDate)) {
    return jsonResponse({ ok: false, error: "Invalid order_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (!clientName) {
    return jsonResponse({ ok: false, error: "client_name is required" }, 400, corsOkHeaders);
  }
  if (!clientPhone) {
    return jsonResponse({ ok: false, error: "client_phone is required" }, 400, corsOkHeaders);
  }
  if (!itemsText) {
    return jsonResponse({ ok: false, error: "items_text is required" }, 400, corsOkHeaders);
  }
  if (![1, 2, 3].includes(priority)) {
    return jsonResponse({ ok: false, error: "priority must be 1, 2, or 3" }, 400, corsOkHeaders);
  }
  if (neededBy && !isValidYmd(neededBy)) {
    return jsonResponse({ ok: false, error: "Invalid needed_by (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (pickupDate && !isValidYmd(pickupDate)) {
    return jsonResponse({ ok: false, error: "Invalid pickup_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }

  // Perform update
  await dbRun(
    env,
    `UPDATE client_orders_entries
       SET order_date = ?,
           client_name = ?,
           client_phone = ?,
           client_alt_phone = ?,
           client_email = ?,
           client_address = ?,
           items_text = ?,
           priority = ?,
           needed_by = ?,
           pickup_date = ?,
           deposit_amount = ?,
           notes = ?,
           fulfilled = ?,
           fulfilled_at = ?,
           updated_at = datetime('now')
     WHERE org_id = ? AND location_id = ? AND id = ?`,
    [
      orderDate,
      clientName,
      clientPhone,
      clientAltPhone,
      clientEmail,
      clientAddress,
      itemsText,
      priority,
      neededBy,
      pickupDate,
      depositAmount,         // ALWAYS a number (0+), never null
      notes,
      nextFulfilled ? 1 : 0,
      fulfilledAt,           // ok to be null when not fulfilled
      authUser.org_id,
      authUser.location_id,
      id
    ]
  );

  const updated = await dbFirst(
    env,
    "SELECT * FROM client_orders_entries WHERE org_id = ? AND location_id = ? AND id = ?",
    [authUser.org_id, authUser.location_id, id]
  );

  return jsonResponse({ ok: true, entry: clientOrderRowToUi(updated) }, 200, corsOkHeaders);
}

async function handleClientOrdersEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureClientOrdersSchema(env);

  const entryIdNum = parseInt(String(entryId || ""), 10);
  if (!entryIdNum || isNaN(entryIdNum)) {
    return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  }

  // IMPORTANT:
  // Client Orders list is org-wide (can include multiple locations),
  // so deletes must not require the caller's current location_id to match.
  const existing = await dbFirst(
    env,
    "SELECT id FROM client_orders_entries WHERE org_id = ? AND id = ?",
    [authUser.org_id, entryIdNum]
  );

  if (!existing) {
    return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  }

  await dbRun(env, "DELETE FROM client_orders_entries WHERE org_id = ? AND id = ?", [authUser.org_id, entryIdNum]);

  await writeAudit(env, authUser.org_id, authUser.user_id, "CLIENT_ORDER_DELETE", "client_orders_entries", String(entryIdNum), {});

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


/* =========================
   END OF DAY (EOD) MODULE (API)
   ========================= */

function eodRowToUi(row) {
  if (!row) return null;
  function safeParse(s, fallback) { try { return JSON.parse(s); } catch (e) { return fallback; } }
  return {
    id: row.id,
    date: row.eod_date,
    eod_date: row.eod_date,
    time_of_day: row.time_of_day || "AM",
    staff: row.staff_name || "",
    staff_name: row.staff_name || "",
    float_amount: row.float_amount != null ? String(row.float_amount) : "500",
    x: safeParse(row.x_json, []),
    epos: safeParse(row.epos_json, []),
    cheques: safeParse(row.cheques_json, []),
    paid_outs: safeParse(row.paid_outs_json, []),
    cash: safeParse(row.cash_json, {}),
    deposit: safeParse(row.bov_deposit_json, {}),
    bov_deposit: safeParse(row.bov_deposit_json, {}),
    bag_number: row.bov_bag_number || "",
    bov_bag_number: row.bov_bag_number || "",
    contact_id: row.bov_contact_id != null ? String(row.bov_contact_id) : "",
    bov_contact_id: row.bov_contact_id,
    notes: row.notes || "",
    saved_at: row.saved_at || "",
    locked_at: row.locked_at || "",
    created_at: row.created_at || "",
    updated_at: row.updated_at || "",
    location_name: row.location_name || "",
    org_id: row.org_id,
    location_id: row.location_id
  };
}

async function handleEodGet(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);
  const date = String(url.searchParams.get("date") || "").trim();
  if (!isValidYmd(date)) return jsonResponse({ ok: false, error: "Invalid date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  const row = await dbFirst(env, "SELECT e.*, l.name AS location_name FROM end_of_day e LEFT JOIN locations l ON l.id = e.location_id AND l.org_id = e.org_id WHERE e.org_id = ? AND e.location_id = ? AND e.eod_date = ?", [authUser.org_id, authUser.location_id, date]);
  const uiRow = eodRowToUi(row);
  if (uiRow && !uiRow.location_name && authUser.location_name) uiRow.location_name = authUser.location_name;
  return jsonResponse({ ok: true, eod: uiRow, record: uiRow, item: uiRow }, 200, corsOkHeaders);
}

async function handleEodUpsert(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureEndOfDaySchema(env);

  let body = await readJson(request); // UI sends { record: { ... } }
  if (body && typeof body === "object" && body.record && typeof body.record === "object") {
    body = body.record;
  }

  const date = String(body.eod_date || body.date || "").trim();
  if (!isValidYmd(date)) {
    return jsonResponse({ ok: false, error: "Invalid date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }

  // Read locked_at intent (explicit)
  const hasLockedAtField =
    body &&
    typeof body === "object" &&
    (Object.prototype.hasOwnProperty.call(body, "locked_at") ||
      Object.prototype.hasOwnProperty.call(body, "lockedAt"));

  const lockedAtRaw = hasLockedAtField
    ? (Object.prototype.hasOwnProperty.call(body, "locked_at") ? body.locked_at : body.lockedAt)
    : undefined;

  const wantsLock = !!(lockedAtRaw && String(lockedAtRaw).trim());

  // Load existing early so we can allow UNLOCK without requiring staff/float validation
  const existing = await dbFirst(
    env,
    "SELECT id, locked_at FROM end_of_day WHERE org_id = ? AND location_id = ? AND eod_date = ?",
    [authUser.org_id, authUser.location_id, date]
  );

  const wantsUnlock =
    !!(existing && existing.locked_at) &&
    (
      lockedAtRaw === "" ||
      lockedAtRaw === null ||
      body.unlock === true ||
      body.action === "UNLOCK"
    );

  // ✅ PATCH: allow explicit unlock for locked records
  if (existing && existing.locked_at) {
    if (wantsUnlock) {
      await dbRun(
        env,
        `UPDATE end_of_day
         SET locked_at = NULL,
             updated_at = datetime('now'),
             updated_by = ?
         WHERE id = ? AND org_id = ? AND location_id = ?`,
        [authUser.user_id, existing.id, authUser.org_id, authUser.location_id]
      );

      await writeAudit(
        env,
        authUser.org_id,
        authUser.user_id,
        "EOD_UNLOCK",
        "end_of_day",
        String(existing.id),
        { eod_date: date }
      );

      const row = await dbFirst(
        env,
        "SELECT e.*, l.name AS location_name FROM end_of_day e LEFT JOIN locations l ON l.id = e.location_id AND l.org_id = e.org_id WHERE e.org_id = ? AND e.location_id = ? AND e.eod_date = ?",
        [authUser.org_id, authUser.location_id, date]
      );
      const uiRow = eodRowToUi(row);
      if (uiRow && !uiRow.location_name && authUser.location_name) uiRow.location_name = authUser.location_name;

      return jsonResponse({ ok: true, eod: uiRow, record: uiRow, item: uiRow }, 200, corsOkHeaders);
    }

    // idempotent lock call: return existing locked state
    if (wantsLock) {
      return jsonResponse({ ok: true, id: existing.id, locked_at: existing.locked_at }, 200, corsOkHeaders);
    }

    // still block normal updates while locked
    return jsonResponse({ ok: false, error: "Locked - cannot update" }, 409, corsOkHeaders);
  }

  // Normal validation for create/update (unlocked)
  const staffName = String(body.staff_name || body.staff || "").trim();
  const floatAmount = Number(body.float_amount ?? body.float ?? body.floatAmount ?? 500);

  if (!staffName) {
    return jsonResponse({ ok: false, error: "Missing staff/staff_name" }, 400, corsOkHeaders);
  }
  if (!Number.isFinite(floatAmount) || floatAmount < 0) {
    return jsonResponse({ ok: false, error: "Invalid float_amount (>= 0)" }, 400, corsOkHeaders);
  }

  const timeOfDay = String(body.time_of_day || "AM").trim() || "AM";

  const xJson = JSON.stringify(Array.isArray(body.x) ? body.x : []);
  const eposJson = JSON.stringify(Array.isArray(body.epos) ? body.epos : []);
  const chequesJson = JSON.stringify(Array.isArray(body.cheques) ? body.cheques : []);
  const paidOutsJson = JSON.stringify(Array.isArray(body.paid_outs) ? body.paid_outs : []);
  const cashJson = JSON.stringify(body.cash && typeof body.cash === "object" ? body.cash : {});

  const bovDeposit = body.bov_deposit || body.deposit || {};
  const bovDepositJson = JSON.stringify(bovDeposit && typeof bovDeposit === "object" ? bovDeposit : {});
  const bovBagNumber = String(body.bov_bag_number || body.bag_number || "").trim();
  const bovContactId = body.bov_contact_id != null ? body.bov_contact_id : (body.contact_id != null ? body.contact_id : null);

  const notes = String(body.notes || "").trim();

  // Insert or update
  if (!existing) {
    const row = await dbFirst(
      env,
      `INSERT INTO end_of_day
       (org_id, location_id, eod_date, time_of_day, staff_name, float_amount,
        x_json, epos_json, cheques_json, paid_outs_json, cash_json,
        bov_deposit_json, bov_bag_number, bov_contact_id, notes,
        saved_at, locked_at, created_at, updated_at, updated_by)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), CASE WHEN ? THEN datetime('now') ELSE NULL END, datetime('now'), datetime('now'), ?)
       RETURNING id`,
      [
        authUser.org_id, authUser.location_id, date, timeOfDay, staffName, floatAmount,
        xJson, eposJson, chequesJson, paidOutsJson, cashJson,
        bovDepositJson, bovBagNumber || null, bovContactId, notes || null,
        wantsLock ? 1 : 0, // NOTE: kept original behavior pattern
        authUser.user_id
      ]
    );

    await writeAudit(env, authUser.org_id, authUser.user_id, "EOD_CREATE", "end_of_day", String(row.id), { eod_date: date, locked: wantsLock });

  } else {
    await dbRun(
      env,
      `UPDATE end_of_day SET
         time_of_day = ?,
         staff_name = ?,
         float_amount = ?,
         x_json = ?,
         epos_json = ?,
         cheques_json = ?,
         paid_outs_json = ?,
         cash_json = ?,
         bov_deposit_json = ?,
         bov_bag_number = ?,
         bov_contact_id = ?,
         notes = ?,
         saved_at = datetime('now'),
         locked_at = CASE WHEN ? THEN datetime('now') ELSE locked_at END,
         updated_at = datetime('now'),
         updated_by = ?
       WHERE id = ? AND org_id = ? AND location_id = ?`,
      [
        timeOfDay,
        staffName,
        floatAmount,
        xJson,
        eposJson,
        chequesJson,
        paidOutsJson,
        cashJson,
        bovDepositJson,
        bovBagNumber || null,
        bovContactId,
        notes || null,
        wantsLock ? 1 : 0,
        authUser.user_id,
        existing.id,
        authUser.org_id,
        authUser.location_id
      ]
    );

    await writeAudit(env, authUser.org_id, authUser.user_id, wantsLock ? "EOD_LOCK" : "EOD_UPDATE", "end_of_day", String(existing.id), { eod_date: date });
  }

  const row = await dbFirst(
    env,
    "SELECT e.*, l.name AS location_name FROM end_of_day e LEFT JOIN locations l ON l.id = e.location_id AND l.org_id = e.org_id WHERE e.org_id = ? AND e.location_id = ? AND e.eod_date = ?",
    [authUser.org_id, authUser.location_id, date]
  );

  const uiRow = eodRowToUi(row);
  if (uiRow && !uiRow.location_name && authUser.location_name) uiRow.location_name = authUser.location_name;

  return jsonResponse({ ok: true, eod: uiRow, record: uiRow, item: uiRow }, 200, corsOkHeaders);
}

async function handleEodLock(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);

  const body = await readJson(request);
  const date = String(body.eod_date || "").trim();
  if (!isValidYmd(date)) return jsonResponse({ ok: false, error: "Invalid eod_date (YYYY-MM-DD)" }, 400, corsOkHeaders);

  const existing = await dbFirst(env, "SELECT id, locked_at FROM end_of_day WHERE org_id = ? AND location_id = ? AND eod_date = ?", [authUser.org_id, authUser.location_id, date]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
  if (existing.locked_at) return jsonResponse({ ok: true, id: existing.id, locked_at: existing.locked_at }, 200, corsOkHeaders);

  await dbRun(env, "UPDATE end_of_day SET locked_at = datetime('now'), updated_at = datetime('now'), updated_by = ? WHERE id = ? AND org_id = ? AND location_id = ?", [authUser.user_id, existing.id, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "EOD_LOCK", "end_of_day", String(existing.id), { eod_date: date });

  const locked = await dbFirst(env, "SELECT locked_at FROM end_of_day WHERE id = ? AND org_id = ? AND location_id = ?", [existing.id, authUser.org_id, authUser.location_id]);
  return jsonResponse({ ok: true, id: existing.id, locked_at: locked ? locked.locked_at : null }, 200, corsOkHeaders);
}

async function handleEodListDates(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);
  const month = String(url.searchParams.get("month") || "").trim();
  if (!isValidYm(month)) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Invalid month" }, 400, corsOkHeaders);
  const rows = await dbAll(env, "SELECT eod_date FROM end_of_day WHERE org_id = ? AND location_id = ? AND eod_date >= ? AND eod_date < ? ORDER BY eod_date ASC", [authUser.org_id, authUser.location_id, range.startStr, range.endStr]);
  const dates = rows.map(r => r.eod_date);
  return jsonResponse({ ok: true, dates: dates, items: dates, records: dates }, 200, corsOkHeaders);
}

async function handleEodContactsList(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);
  const rows = await dbAll(env, "SELECT id, display_name, phone, email FROM end_of_day_contacts WHERE org_id = ? AND location_id = ? AND is_active = 1 ORDER BY display_name ASC", [authUser.org_id, authUser.location_id]);
  return jsonResponse({ ok: true, contacts: rows }, 200, corsOkHeaders);
}

async function handleEodContactsCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);

  const body = await readJson(request);

  // UI sends { contacts: [...] } for bulk save — handle that case
  if (Array.isArray(body.contacts)) {
    return await handleEodContactsBulkSave(body.contacts, env, corsOkHeaders, authUser);
  }

  const name = String(body.display_name || body.name || "").trim();
  const phone = String(body.phone || "").trim();
  const email = String(body.email || "").trim();
  if (!name) return jsonResponse({ ok: false, error: "Missing display_name" }, 400, corsOkHeaders);

  const row = await dbFirst(env, "INSERT INTO end_of_day_contacts (org_id, location_id, display_name, phone, email, is_active, created_at, updated_at, created_by, updated_by) VALUES (?, ?, ?, ?, ?, 1, datetime('now'), datetime('now'), ?, ?) RETURNING id", [authUser.org_id, authUser.location_id, name, phone, email, authUser.user_id, authUser.user_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "EOD_CONTACT_CREATE", "end_of_day_contacts", String(row.id), { display_name: name });

  return jsonResponse({ ok: true, id: row.id }, 200, corsOkHeaders);
}

async function handleEodContactsBulkSave(contacts, env, corsOkHeaders, authUser) {
  // Bulk save: deactivate all existing, then upsert each contact from the UI list
  await ensureEndOfDaySchema(env);

  // Mark all existing contacts inactive
  await dbRun(env, "UPDATE end_of_day_contacts SET is_active = 0, updated_at = datetime('now'), updated_by = ? WHERE org_id = ? AND location_id = ?", [authUser.user_id, authUser.org_id, authUser.location_id]);

  const ids = [];
  for (const c of contacts) {
    const name = String(c.display_name || c.name || "").trim();
    const phone = String(c.phone || "").trim();
    const email = String(c.email || "").trim();
    if (!name) continue;

    // Try to re-activate existing by name, or insert new
    const existing = await dbFirst(env, "SELECT id FROM end_of_day_contacts WHERE org_id = ? AND location_id = ? AND display_name = ?", [authUser.org_id, authUser.location_id, name]);
    if (existing) {
      await dbRun(env, "UPDATE end_of_day_contacts SET phone = ?, email = ?, is_active = 1, updated_at = datetime('now'), updated_by = ? WHERE id = ?", [phone, email, authUser.user_id, existing.id]);
      ids.push(existing.id);
    } else {
      const row = await dbFirst(env, "INSERT INTO end_of_day_contacts (org_id, location_id, display_name, phone, email, is_active, created_at, updated_at, created_by, updated_by) VALUES (?, ?, ?, ?, ?, 1, datetime('now'), datetime('now'), ?, ?) RETURNING id", [authUser.org_id, authUser.location_id, name, phone, email, authUser.user_id, authUser.user_id]);
      ids.push(row.id);
    }
  }

  await writeAudit(env, authUser.org_id, authUser.user_id, "EOD_CONTACTS_BULK_SAVE", "end_of_day_contacts", "", { count: ids.length });
  return jsonResponse({ ok: true, ids: ids }, 200, corsOkHeaders);
}

async function handleEodContactsBulkPut(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);

  const body = await readJson(request);
  const contacts = body.contacts || body;
  if (!Array.isArray(contacts)) return jsonResponse({ ok: false, error: "Expected contacts array" }, 400, corsOkHeaders);
  return await handleEodContactsBulkSave(contacts, env, corsOkHeaders, authUser);
}

async function handleEodContactsUpdate(request, env, corsOkHeaders, authUser, contactId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);

  const existing = await dbFirst(env, "SELECT id FROM end_of_day_contacts WHERE id = ? AND org_id = ? AND location_id = ?", [contactId, authUser.org_id, authUser.location_id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);
  const name = String(body.display_name || body.name || "").trim();
  const phone = String(body.phone || "").trim();
  const email = String(body.email || "").trim();
  if (!name) return jsonResponse({ ok: false, error: "Missing display_name" }, 400, corsOkHeaders);

  await dbRun(env, "UPDATE end_of_day_contacts SET display_name = ?, phone = ?, email = ?, updated_at = datetime('now'), updated_by = ? WHERE id = ? AND org_id = ? AND location_id = ?", [name, phone, email, authUser.user_id, contactId, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "EOD_CONTACT_UPDATE", "end_of_day_contacts", String(contactId), { display_name: name });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleEodContactsDeactivate(request, env, corsOkHeaders, authUser, contactId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);

  const existing = await dbFirst(env, "SELECT id, display_name FROM end_of_day_contacts WHERE id = ? AND org_id = ? AND location_id = ?", [contactId, authUser.org_id, authUser.location_id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(env, "UPDATE end_of_day_contacts SET is_active = 0, updated_at = datetime('now'), updated_by = ? WHERE id = ? AND org_id = ? AND location_id = ?", [authUser.user_id, contactId, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "EOD_CONTACT_DEACTIVATE", "end_of_day_contacts", String(contactId), { display_name: existing.display_name });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


/* =========================
   CLEANING MODULE (API)
   ========================= */


// ------------------------------------------------------------
// Near Expiry
// ------------------------------------------------------------
async function handleNearExpiryEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureNearExpirySchema(env);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  const sql = `
    SELECT
      id,
      product_name,
      expiry_date,
      location,
      notes,
      created_by,
      created_at,
      updated_at,
      updated_by
    FROM near_expiry_entries
    WHERE org_id = ?
      AND location_id = ?
      ${hasQ ? `AND (
        product_name LIKE ?
        OR expiry_date LIKE ?
        OR location LIKE ?
        OR notes LIKE ?
      )` : ""}
    ORDER BY expiry_date ASC, product_name ASC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id];
  if (hasQ) bind.push(qLike, qLike, qLike, qLike);

  const rows = await dbAll(env, sql, bind);
  const entries = rows.map(nearExpiryRowToUi);
  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleNearExpiryEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureNearExpirySchema(env);

  const body = await readJson(request);

  const productName = String(body.product_name || body.name || "").trim();
  const expiryDate = String(body.expiry_date || "").trim();
  const location = String(body.location || "").trim();
  const notes = String(body.notes || "").trim();

  if (!productName) return jsonResponse({ ok: false, error: "Missing product_name" }, 400, corsOkHeaders);
  if (!isValidYmd(expiryDate)) return jsonResponse({ ok: false, error: "Missing/invalid expiry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO near_expiry_entries
      (org_id, location_id, product_name, expiry_date, location, notes, created_by, updated_by, created_at, updated_at)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [authUser.org_id, authUser.location_id, productName, expiryDate, location, notes, authUser.user_id, authUser.user_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "NEAR_EXPIRY_CREATE", "near_expiry_entries", String(row.id), {
    product_name: productName,
    expiry_date: expiryDate
  });

  const saved = await dbFirst(
    env,
    `SELECT id, product_name, expiry_date, location, notes, created_by, created_at, updated_at, updated_by
     FROM near_expiry_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [row.id, authUser.org_id, authUser.location_id]
  );

  return jsonResponse({ ok: true, entry: nearExpiryRowToUi(saved) }, 200, corsOkHeaders);
}

async function handleNearExpiryEntryUpdate(request, env, corsOkHeaders, authUser, id) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureNearExpirySchema(env);

  const existing = await dbFirst(
    env,
    "SELECT id FROM near_expiry_entries WHERE id = ? AND org_id = ? AND location_id = ?",
    [id, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const productName = String(body.product_name || body.name || "").trim();
  const expiryDate = String(body.expiry_date || "").trim();
  const location = String(body.location || "").trim();
  const notes = String(body.notes || "").trim();

  if (!productName) return jsonResponse({ ok: false, error: "Missing product_name" }, 400, corsOkHeaders);
  if (!isValidYmd(expiryDate)) return jsonResponse({ ok: false, error: "Missing/invalid expiry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE near_expiry_entries
     SET product_name = ?, expiry_date = ?, location = ?, notes = ?, updated_by = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [productName, expiryDate, location, notes, authUser.user_id, id, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "NEAR_EXPIRY_UPDATE", "near_expiry_entries", String(id), {
    product_name: productName,
    expiry_date: expiryDate
  });

  const saved = await dbFirst(
    env,
    `SELECT id, product_name, expiry_date, location, notes, created_by, created_at, updated_at, updated_by
     FROM near_expiry_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [id, authUser.org_id, authUser.location_id]
  );

  return jsonResponse({ ok: true, entry: nearExpiryRowToUi(saved) }, 200, corsOkHeaders);
}

async function handleNearExpiryEntryDelete(request, env, corsOkHeaders, authUser, id) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureNearExpirySchema(env);

  const existing = await dbFirst(
    env,
    "SELECT id, product_name, expiry_date FROM near_expiry_entries WHERE id = ? AND org_id = ? AND location_id = ?",
    [id, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    "DELETE FROM near_expiry_entries WHERE id = ? AND org_id = ? AND location_id = ?",
    [id, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "NEAR_EXPIRY_DELETE", "near_expiry_entries", String(id), {
    product_name: existing.product_name,
    expiry_date: existing.expiry_date
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleCleaningEntriesList(request, env, corsOkHeaders, authUser, url) {
  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       time_in,
       time_out,
       cleaner_name,
       staff_name,
       notes,
       created_by,
       created_at,
       updated_at
     FROM cleaning_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date < ?
     ORDER BY entry_date DESC, time_in DESC, id DESC`,
    [authUser.org_id, authUser.location_id, range.startStr, range.endStr]
  );

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleCleaningEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const timeIn = String(body.time_in || "").trim();
  const timeOut = String(body.time_out || "").trim();
  const cleanerName = String(body.cleaner_name || "").trim();
  const staffName = String(body.staff_name || "").trim();
  const notes = String(body.notes || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!isValidHm(timeIn)) return jsonResponse({ ok: false, error: "Invalid time_in (HH:mm)" }, 400, corsOkHeaders);
  if (timeOut && !isValidHm(timeOut)) return jsonResponse({ ok: false, error: "Invalid time_out (HH:mm or empty)" }, 400, corsOkHeaders);
  if (!cleanerName) return jsonResponse({ ok: false, error: "Missing cleaner_name" }, 400, corsOkHeaders);
  if (!staffName) return jsonResponse({ ok: false, error: "Missing staff_name" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO cleaning_entries
       (org_id, location_id, entry_date, time_in, time_out, cleaner_name, staff_name, notes, created_by, created_at, updated_at)
     VALUES
       (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [authUser.org_id, authUser.location_id, entryDate, timeIn, timeOut || "", cleanerName, staffName, notes, authUser.user_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CLEANING_ENTRY_CREATE", "cleaning_entries", String(row.id), {
    entry_date: entryDate,
    time_in: timeIn,
    time_out: timeOut || "",
    cleaner_name: cleanerName,
    staff_name: staffName
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleCleaningEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM cleaning_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const timeIn = String(body.time_in || "").trim();
  const timeOut = String(body.time_out || "").trim();
  const cleanerName = String(body.cleaner_name || "").trim();
  const staffName = String(body.staff_name || "").trim();
  const notes = String(body.notes || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!isValidHm(timeIn)) return jsonResponse({ ok: false, error: "Invalid time_in (HH:mm)" }, 400, corsOkHeaders);
  if (timeOut && !isValidHm(timeOut)) return jsonResponse({ ok: false, error: "Invalid time_out (HH:mm or empty)" }, 400, corsOkHeaders);
  if (!cleanerName) return jsonResponse({ ok: false, error: "Missing cleaner_name" }, 400, corsOkHeaders);
  if (!staffName) return jsonResponse({ ok: false, error: "Missing staff_name" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE cleaning_entries
     SET entry_date = ?, time_in = ?, time_out = ?, cleaner_name = ?, staff_name = ?, notes = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryDate, timeIn, timeOut || "", cleanerName, staffName, notes, entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CLEANING_ENTRY_UPDATE", "cleaning_entries", String(entryId), {
    entry_date: entryDate,
    time_in: timeIn,
    time_out: timeOut || "",
    cleaner_name: cleanerName,
    staff_name: staffName
  });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleCleaningEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM cleaning_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM cleaning_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CLEANING_ENTRY_DELETE", "cleaning_entries", String(entryId), {});

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleCleaningReport(request, env, corsOkHeaders, authUser, url) {
  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();

  if (!isValidYmd(from) || !isValidYmd(to)) {
    return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (to < from) {
    return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
  }

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       time_in,
       time_out,
       cleaner_name,
       staff_name,
       notes
     FROM cleaning_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date <= ?
     ORDER BY entry_date ASC, time_in ASC, id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  return jsonResponse(
    {
      ok: true,
      org_name: authUser.org_name,
      location_name: authUser.location_name,
      from,
      to,
      entries
    },
    200,
    corsOkHeaders
  );
}

async function handleCleaningReportHtml(request, env, corsOkHeaders, authUser, url) {
  const out = await handleCleaningReport(request, env, corsOkHeaders, authUser, url);
  const data = await out.json();
  if (!data.ok) return out;

  const entries = data.entries || [];

  // Group by month
  const byMonth = new Map();
  for (const e of entries) {
    const ym = ymFromYmd(e.entry_date);
    if (!byMonth.has(ym)) byMonth.set(ym, []);
    byMonth.get(ym).push(e);
  }

  let body = "";
  body += `<h1>${escapeHtml(data.org_name || "Pharmacy")} — Cleaning Report</h1>`;
  body += `<p class="meta">Location: ${escapeHtml(data.location_name || "")}<br/>Range: ${escapeHtml(data.from)} to ${escapeHtml(data.to)}</p>`;

  for (const [ym, list] of byMonth.entries()) {
    body += `<h2>${escapeHtml(ym)}</h2>`;
    body += `<table><thead><tr><th>Date</th><th>Time in</th><th>Time out</th><th>Cleaner</th><th>Staff</th><th>Notes</th></tr></thead><tbody>`;
    for (const r of list) {
      body += `<tr>
        <td>${escapeHtml(r.entry_date)}</td>
        <td>${escapeHtml(r.time_in)}</td>
        <td>${escapeHtml(r.time_out || "")}</td>
        <td>${escapeHtml(r.cleaner_name)}</td>
        <td>${escapeHtml(r.staff_name)}</td>
        <td>${escapeHtml(r.notes || "")}</td>
      </tr>`;
    }
    body += `</tbody></table>`;
  }

  return htmlReportPage("Cleaning Report", body);
}

/* =========================
   LOCUM REGISTER MODULE (API)
   ========================= */

async function ensureLocumRegisterSchema(env) {
  // Table may already exist (you created it), but this is safe.
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS locum_register_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      entry_date TEXT NOT NULL,
      time_in TEXT NOT NULL,
      time_out TEXT NOT NULL,
      locum_full_name TEXT NOT NULL,
      registration_number TEXT NOT NULL,
      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_locum_register_org_loc_date ON locum_register_entries (org_id, location_id, entry_date)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_locum_register_org_loc_regno ON locum_register_entries (org_id, location_id, registration_number)",
    []
  );
}

async function handleLocumRegisterEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureLocumRegisterSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       time_in,
       time_out,
       locum_full_name,
       registration_number,
       created_by,
       created_at,
       updated_at
     FROM locum_register_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date < ?
     ORDER BY entry_date DESC, time_in DESC, id DESC`,
    [authUser.org_id, authUser.location_id, range.startStr, range.endStr]
  );

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleLocumRegisterEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureLocumRegisterSchema(env);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const timeIn = String(body.time_in || "").trim();
  const timeOut = String(body.time_out || "").trim();
  const fullName = String(body.locum_full_name || "").trim();
  const regNo = String(body.registration_number || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!isValidHm(timeIn)) return jsonResponse({ ok: false, error: "Invalid time_in (HH:mm)" }, 400, corsOkHeaders);
  if (timeOut && !isValidHm(timeOut)) return jsonResponse({ ok: false, error: "Invalid time_out (HH:mm or empty)" }, 400, corsOkHeaders);
  if (!fullName) return jsonResponse({ ok: false, error: "Missing locum_full_name" }, 400, corsOkHeaders);
  if (!regNo) return jsonResponse({ ok: false, error: "Missing registration_number" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO locum_register_entries
       (org_id, location_id, entry_date, time_in, time_out, locum_full_name, registration_number, created_by, created_at, updated_at)
     VALUES
       (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [authUser.org_id, authUser.location_id, entryDate, timeIn, timeOut || "", fullName, regNo, authUser.user_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "LOCUM_REGISTER_ENTRY_CREATE", "locum_register_entries", String(row.id), {
    entry_date: entryDate,
    time_in: timeIn,
    time_out: timeOut || "",
    locum_full_name: fullName,
    registration_number: regNo
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleLocumRegisterEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureLocumRegisterSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM locum_register_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const timeIn = String(body.time_in || "").trim();
  const timeOut = String(body.time_out || "").trim();
  const fullName = String(body.locum_full_name || "").trim();
  const regNo = String(body.registration_number || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!isValidHm(timeIn)) return jsonResponse({ ok: false, error: "Invalid time_in (HH:mm)" }, 400, corsOkHeaders);
  if (timeOut && !isValidHm(timeOut)) return jsonResponse({ ok: false, error: "Invalid time_out (HH:mm or empty)" }, 400, corsOkHeaders);
  if (!fullName) return jsonResponse({ ok: false, error: "Missing locum_full_name" }, 400, corsOkHeaders);
  if (!regNo) return jsonResponse({ ok: false, error: "Missing registration_number" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE locum_register_entries
     SET entry_date = ?, time_in = ?, time_out = ?, locum_full_name = ?, registration_number = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryDate, timeIn, timeOut || "", fullName, regNo, entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "LOCUM_REGISTER_ENTRY_UPDATE", "locum_register_entries", String(entryId), {
    entry_date: entryDate,
    time_in: timeIn,
    time_out: timeOut || "",
    locum_full_name: fullName,
    registration_number: regNo
  });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleLocumRegisterEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureLocumRegisterSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM locum_register_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM locum_register_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "LOCUM_REGISTER_ENTRY_DELETE", "locum_register_entries", String(entryId), {});

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}





/* =========================
   LOCUM RECEIPTS MODULE (API)
   ========================= */

const LOCUM_RECEIPTS_REPORT_PASS = "Report1234!";
const LOCUM_RECEIPTS_EDIT_PASS = "!4321";

function round2(n) {
  const x = Number(n);
  if (!Number.isFinite(x)) return 0;
  return Math.round(x * 100) / 100;
}

function isValidYear(s) {
  return /^\d{4}$/.test(String(s || "").trim());
}

function yearRange(yyyy) {
  const y = String(yyyy || "").trim();
  if (!isValidYear(y)) return null;
  const yNum = parseInt(y, 10);
  const start = new Date(Date.UTC(yNum, 0, 1));
  const end = new Date(Date.UTC(yNum + 1, 0, 1));
  return { startStr: start.toISOString().slice(0, 10), endStr: end.toISOString().slice(0, 10) };
}

function isValidDayType(s) {
  const v = String(s || "").trim().toLowerCase();
  return v === "normal" || v === "holiday";
}

function requireHeaderPass(request, headerName, expected) {
  try {
    return String(request.headers.get(headerName) || "") === String(expected);
  } catch (e) {
    return false;
  }
}

async function ensureLocumReceiptsSchema(env) {
  // One-line queries (easy to copy/paste into D1 console)
  await dbRun(env, "CREATE TABLE IF NOT EXISTS locum_receipts (id INTEGER PRIMARY KEY AUTOINCREMENT, org_id INTEGER NOT NULL, location_id INTEGER NOT NULL, receipt_date TEXT NOT NULL, hours REAL NOT NULL, locum_full_name TEXT NOT NULL, registration_number TEXT NOT NULL, day_type TEXT NOT NULL DEFAULT 'normal', fee_per_hour REAL NOT NULL, total_fee REAL NOT NULL, created_by INTEGER, created_at TEXT NOT NULL DEFAULT (datetime('now')), updated_at TEXT NOT NULL DEFAULT (datetime('now')))", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_locum_receipts_org_loc_date ON locum_receipts (org_id, location_id, receipt_date)", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_locum_receipts_org_loc_name ON locum_receipts (org_id, location_id, locum_full_name)", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_locum_receipts_org_loc_regno ON locum_receipts (org_id, location_id, registration_number)", []);
}

async function handleLocumReceiptsList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureLocumReceiptsSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const year = (url.searchParams.get("year") || "").trim();

  let range = null;
  let label = "";
  if (month) {
    range = monthRange(month);
    label = "month";
    if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);
  } else if (year) {
    range = yearRange(year);
    label = "year";
    if (!range) return jsonResponse({ ok: false, error: "Missing/invalid year (YYYY)" }, 400, corsOkHeaders);
  } else {
    return jsonResponse({ ok: false, error: "Missing month or year" }, 400, corsOkHeaders);
  }

  const receipts = await dbAll(
    env,
    `SELECT
       id,
       receipt_date,
       hours,
       locum_full_name,
       registration_number,
       day_type,
       fee_per_hour,
       total_fee,
       created_by,
       created_at,
       updated_at
     FROM locum_receipts
     WHERE org_id = ?
       AND location_id = ?
       AND receipt_date >= ?
       AND receipt_date < ?
     ORDER BY receipt_date DESC, id DESC`,
    [authUser.org_id, authUser.location_id, range.startStr, range.endStr]
  );

  const payload = { ok: true, receipts };
  if (isDebugEnabled(request)) payload.debug = { range, label };
  return jsonResponse(payload, 200, corsOkHeaders);
}

async function handleLocumReceiptCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureLocumReceiptsSchema(env);

  const body = await readJson(request);

  const receiptDate = String(body.receipt_date || "").trim();
  const hours = Number(body.hours);
  const fullName = String(body.locum_full_name || "").trim();
  const regNo = String(body.registration_number || "").trim();
  const dayType = String(body.day_type || "normal").trim().toLowerCase();
  const feePerHour = Number(body.fee_per_hour);

  if (!isValidYmd(receiptDate)) return jsonResponse({ ok: false, error: "Invalid receipt_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!Number.isFinite(hours) || hours <= 0) return jsonResponse({ ok: false, error: "Invalid hours" }, 400, corsOkHeaders);
  if (hours > 24) return jsonResponse({ ok: false, error: "Hours cannot exceed 24" }, 400, corsOkHeaders);
  if (!fullName) return jsonResponse({ ok: false, error: "Missing locum_full_name" }, 400, corsOkHeaders);
  if (!regNo) return jsonResponse({ ok: false, error: "Missing registration_number" }, 400, corsOkHeaders);
  if (!isValidDayType(dayType)) return jsonResponse({ ok: false, error: "Invalid day_type (normal|holiday)" }, 400, corsOkHeaders);
  if (!Number.isFinite(feePerHour) || feePerHour < 0) return jsonResponse({ ok: false, error: "Invalid fee_per_hour" }, 400, corsOkHeaders);

  const totalFee = round2(hours * feePerHour);

  const row = await dbFirst(
    env,
    `INSERT INTO locum_receipts
       (org_id, location_id, receipt_date, hours, locum_full_name, registration_number, day_type, fee_per_hour, total_fee, created_by, created_at, updated_at)
     VALUES
       (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id, receipt_date, hours, locum_full_name, registration_number, day_type, fee_per_hour, total_fee, created_by, created_at, updated_at`,
    [authUser.org_id, authUser.location_id, receiptDate, hours, fullName, regNo, dayType, feePerHour, totalFee, authUser.user_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "LOCUM_RECEIPT_CREATE", "locum_receipts", String(row.id), {
    receipt_date: receiptDate,
    hours,
    locum_full_name: fullName,
    registration_number: regNo,
    day_type: dayType,
    fee_per_hour: feePerHour,
    total_fee: totalFee
  });

  const payload = { ok: true, receipt: row, id: row.id };
  if (isDebugEnabled(request)) payload.debug = { row };
  return jsonResponse(payload, 200, corsOkHeaders);
}

async function handleLocumReceiptUpdate(request, env, corsOkHeaders, authUser, receiptId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  // extra protection as requested
  if (!requireHeaderPass(request, "X-Eikon-Edit-Pass", LOCUM_RECEIPTS_EDIT_PASS)) {
    return jsonResponse({ ok: false, error: "Edit password required" }, 403, corsOkHeaders);
  }

  await ensureLocumReceiptsSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM locum_receipts
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [receiptId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const receiptDate = String(body.receipt_date || "").trim();
  const hours = Number(body.hours);
  const fullName = String(body.locum_full_name || "").trim();
  const regNo = String(body.registration_number || "").trim();
  const dayType = String(body.day_type || "normal").trim().toLowerCase();
  const feePerHour = Number(body.fee_per_hour);

  if (!isValidYmd(receiptDate)) return jsonResponse({ ok: false, error: "Invalid receipt_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!Number.isFinite(hours) || hours <= 0) return jsonResponse({ ok: false, error: "Invalid hours" }, 400, corsOkHeaders);
  if (hours > 24) return jsonResponse({ ok: false, error: "Hours cannot exceed 24" }, 400, corsOkHeaders);
  if (!fullName) return jsonResponse({ ok: false, error: "Missing locum_full_name" }, 400, corsOkHeaders);
  if (!regNo) return jsonResponse({ ok: false, error: "Missing registration_number" }, 400, corsOkHeaders);
  if (!isValidDayType(dayType)) return jsonResponse({ ok: false, error: "Invalid day_type (normal|holiday)" }, 400, corsOkHeaders);
  if (!Number.isFinite(feePerHour) || feePerHour < 0) return jsonResponse({ ok: false, error: "Invalid fee_per_hour" }, 400, corsOkHeaders);

  const totalFee = round2(hours * feePerHour);

  await dbRun(
    env,
    `UPDATE locum_receipts
     SET receipt_date = ?,
         hours = ?,
         locum_full_name = ?,
         registration_number = ?,
         day_type = ?,
         fee_per_hour = ?,
         total_fee = ?,
         updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [receiptDate, hours, fullName, regNo, dayType, feePerHour, totalFee, receiptId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "LOCUM_RECEIPT_UPDATE", "locum_receipts", String(receiptId), {
    receipt_date: receiptDate,
    hours,
    locum_full_name: fullName,
    registration_number: regNo,
    day_type: dayType,
    fee_per_hour: feePerHour,
    total_fee: totalFee
  });

  const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { receiptId };
  return jsonResponse(payload, 200, corsOkHeaders);
}

async function handleLocumReceiptDelete(request, env, corsOkHeaders, authUser, receiptId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  // extra protection as requested
  if (!requireHeaderPass(request, "X-Eikon-Edit-Pass", LOCUM_RECEIPTS_EDIT_PASS)) {
    return jsonResponse({ ok: false, error: "Edit password required" }, 403, corsOkHeaders);
  }

  await ensureLocumReceiptsSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM locum_receipts
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [receiptId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    "DELETE FROM locum_receipts WHERE id = ? AND org_id = ? AND location_id = ?",
    [receiptId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "LOCUM_RECEIPT_DELETE", "locum_receipts", String(receiptId), {});

  const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { receiptId };
  return jsonResponse(payload, 200, corsOkHeaders);
}

async function handleLocumReceiptsReport(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  // extra protection as requested
  if (!requireHeaderPass(request, "X-Eikon-Report-Pass", LOCUM_RECEIPTS_REPORT_PASS)) {
    return jsonResponse({ ok: false, error: "Report password required" }, 403, corsOkHeaders);
  }

  await ensureLocumReceiptsSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const year = (url.searchParams.get("year") || "").trim();

  let range = null;
  let periodLabel = "";
  if (month) {
    range = monthRange(month);
    if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);
    periodLabel = "Month • " + month;
  } else if (year) {
    range = yearRange(year);
    if (!range) return jsonResponse({ ok: false, error: "Missing/invalid year (YYYY)" }, 400, corsOkHeaders);
    periodLabel = "Year • " + year;
  } else {
    return jsonResponse({ ok: false, error: "Missing month or year" }, 400, corsOkHeaders);
  }

  const rows = await dbAll(
    env,
    `SELECT
       id,
       receipt_date,
       hours,
       locum_full_name,
       registration_number,
       day_type,
       fee_per_hour,
       total_fee
     FROM locum_receipts
     WHERE org_id = ?
       AND location_id = ?
       AND receipt_date >= ?
       AND receipt_date < ?
     ORDER BY locum_full_name ASC, registration_number ASC, receipt_date ASC, id ASC`,
    [authUser.org_id, authUser.location_id, range.startStr, range.endStr]
  );

  // Group by locum (name + reg)
  const byKey = new Map();
  for (const r of rows) {
    const name = String(r.locum_full_name || "");
    const reg = String(r.registration_number || "");
    const key = name + "||" + reg;
    if (!byKey.has(key)) {
      byKey.set(key, { locum_full_name: name, registration_number: reg, entries: [], total_hours: 0, total_fees: 0 });
    }
    const g = byKey.get(key);
    const h = Number(r.hours);
    const tf = Number(r.total_fee);
    g.entries.push({
      id: r.id,
      receipt_date: r.receipt_date,
      hours: Number.isFinite(h) ? h : 0,
      locum_full_name: name,
      registration_number: reg,
      day_type: r.day_type,
      fee_per_hour: Number(r.fee_per_hour),
      total_fee: Number.isFinite(tf) ? tf : 0
    });
    g.total_hours = round2(g.total_hours + (Number.isFinite(h) ? h : 0));
    g.total_fees = round2(g.total_fees + (Number.isFinite(tf) ? tf : 0));
  }

  const locums = Array.from(byKey.values());

  // Overall table
  const overall = locums.map(l => ({
    locum_full_name: l.locum_full_name,
    registration_number: l.registration_number,
    total_hours: l.total_hours,
    total_fees: l.total_fees
  }));

  const overallTotals = overall.reduce(
    (acc, r) => {
      acc.total_hours = round2(acc.total_hours + (Number(r.total_hours) || 0));
      acc.total_fees = round2(acc.total_fees + (Number(r.total_fees) || 0));
      return acc;
    },
    { total_hours: 0, total_fees: 0 }
  );

  const report = {
    location_name: authUser.location_name || "",
    period_label: periodLabel,
    generated_at: new Date().toISOString().replace("T", " ").slice(0, 19),
    locums,
    overall,
    overall_totals: overallTotals
  };

  const payload = { ok: true, report };
  if (isDebugEnabled(request)) payload.debug = { range, rowCount: rows.length };
  return jsonResponse(payload, 200, corsOkHeaders);
}

/* =========================
   DAILY REGISTER MODULE (API)
   ========================= */

async function ensureDailyRegisterSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS daily_register_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      entry_date TEXT NOT NULL,
      client_name TEXT NOT NULL,
      client_id TEXT NOT NULL,
      medicine_name_dose TEXT NOT NULL,
      posology TEXT NOT NULL,
      prescriber_name TEXT NOT NULL,
      prescriber_reg_no TEXT NOT NULL,
      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_daily_register_org_loc_date ON daily_register_entries (org_id, location_id, entry_date)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_daily_register_org_loc_client ON daily_register_entries (org_id, location_id, client_id)",
    []
  );
}

async function handleDailyRegisterEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDailyRegisterSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  const sql = `
    SELECT
      id,
      entry_date,
      client_name,
      client_id,
      medicine_name_dose,
      posology,
      prescriber_name,
      prescriber_reg_no,
      created_by,
      created_at,
      updated_at
    FROM daily_register_entries
    WHERE org_id = ?
      AND location_id = ?
      AND entry_date >= ?
      AND entry_date < ?
      ${hasQ ? `AND (
        entry_date LIKE ?
        OR client_name LIKE ?
        OR client_id LIKE ?
        OR medicine_name_dose LIKE ?
        OR posology LIKE ?
        OR prescriber_name LIKE ?
        OR prescriber_reg_no LIKE ?
      )` : ""}
    ORDER BY entry_date DESC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id, range.startStr, range.endStr];
  if (hasQ) {
    bind.push(qLike, qLike, qLike, qLike, qLike, qLike, qLike);
  }

  const entries = await dbAll(env, sql, bind);

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleDailyRegisterEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDailyRegisterSchema(env);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientId = String(body.client_id || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const posology = String(body.posology || "").trim();
  const prescriberName = String(body.prescriber_name || "").trim();
  const prescriberRegNo = String(body.prescriber_reg_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientId) return jsonResponse({ ok: false, error: "Missing client_id" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!posology) return jsonResponse({ ok: false, error: "Missing posology" }, 400, corsOkHeaders);
  if (!prescriberName) return jsonResponse({ ok: false, error: "Missing prescriber_name" }, 400, corsOkHeaders);
  if (!prescriberRegNo) return jsonResponse({ ok: false, error: "Missing prescriber_reg_no" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO daily_register_entries
      (org_id, location_id, entry_date, client_name, client_id, medicine_name_dose, posology, prescriber_name, prescriber_reg_no, created_by, created_at, updated_at)
     VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [
      authUser.org_id,
      authUser.location_id,
      entryDate,
      clientName,
      clientId,
      medicineNameDose,
      posology,
      prescriberName,
      prescriberRegNo,
      authUser.user_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DAILY_REGISTER_ENTRY_CREATE", "daily_register_entries", String(row.id), {
    entry_date: entryDate,
    client_id: clientId,
    medicine_name_dose: medicineNameDose
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleDailyRegisterEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDailyRegisterSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM daily_register_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientId = String(body.client_id || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const posology = String(body.posology || "").trim();
  const prescriberName = String(body.prescriber_name || "").trim();
  const prescriberRegNo = String(body.prescriber_reg_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientId) return jsonResponse({ ok: false, error: "Missing client_id" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!posology) return jsonResponse({ ok: false, error: "Missing posology" }, 400, corsOkHeaders);
  if (!prescriberName) return jsonResponse({ ok: false, error: "Missing prescriber_name" }, 400, corsOkHeaders);
  if (!prescriberRegNo) return jsonResponse({ ok: false, error: "Missing prescriber_reg_no" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE daily_register_entries
     SET entry_date = ?, client_name = ?, client_id = ?, medicine_name_dose = ?, posology = ?, prescriber_name = ?, prescriber_reg_no = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      entryDate,
      clientName,
      clientId,
      medicineNameDose,
      posology,
      prescriberName,
      prescriberRegNo,
      entryId,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DAILY_REGISTER_ENTRY_UPDATE", "daily_register_entries", String(entryId), {
    entry_date: entryDate,
    client_id: clientId,
    medicine_name_dose: medicineNameDose
  });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleDailyRegisterEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDailyRegisterSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id, entry_date, client_id
     FROM daily_register_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM daily_register_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DAILY_REGISTER_ENTRY_DELETE", "daily_register_entries", String(entryId), {
    entry_date: existing.entry_date,
    client_id: existing.client_id
  });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleDailyRegisterReport(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDailyRegisterSchema(env);

  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();

  if (!isValidYmd(from) || !isValidYmd(to)) {
    return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (to < from) {
    return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
  }

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       client_name,
       client_id,
       medicine_name_dose,
       posology,
       prescriber_name,
       prescriber_reg_no
     FROM daily_register_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date <= ?
     ORDER BY entry_date ASC, id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  return jsonResponse(
    {
      ok: true,
      org_name: authUser.org_name,
      location_name: authUser.location_name,
      from,
      to,
      entries
    },
    200,
    corsOkHeaders
  );
}

async function handleDailyRegisterReportHtml(request, env, corsOkHeaders, authUser, url) {
  const out = await handleDailyRegisterReport(request, env, corsOkHeaders, authUser, url);
  const data = await out.json();
  if (!data.ok) return out;

  const entries = data.entries || [];

  // Group by month
  const byMonth = new Map();
  for (const e of entries) {
    const ym = ymFromYmd(e.entry_date);
    if (!byMonth.has(ym)) byMonth.set(ym, []);
    byMonth.get(ym).push(e);
  }

  let body = "";
  body += `<h1>${escapeHtml(data.org_name || "Pharmacy")} — Daily Register Report</h1>`;
  body += `<p class="meta">Location: ${escapeHtml(data.location_name || "")}<br/>Range: ${escapeHtml(data.from)} to ${escapeHtml(data.to)}</p>`;

  for (const [ym, list] of byMonth.entries()) {
    body += `<h2>${escapeHtml(ym)}</h2>`;
    body += `<table><thead><tr>
      <th>Date</th>
      <th>Client Name &amp; Surname</th>
      <th>Client ID</th>
      <th>Medicine Name &amp; Dose</th>
      <th>Posology</th>
      <th>Prescriber Name</th>
      <th>Prescriber Reg No.</th>
    </tr></thead><tbody>`;

    for (const r of list) {
      body += `<tr>
        <td>${escapeHtml(r.entry_date)}</td>
        <td>${escapeHtml(r.client_name)}</td>
        <td>${escapeHtml(r.client_id)}</td>
        <td>${escapeHtml(r.medicine_name_dose)}</td>
        <td>${escapeHtml(r.posology)}</td>
        <td>${escapeHtml(r.prescriber_name)}</td>
        <td>${escapeHtml(r.prescriber_reg_no)}</td>
      </tr>`;
    }

    body += `</tbody></table>`;
  }

  return htmlReportPage("Daily Register Report", body);
}

/* =========================
   REPEAT PRESCRIPTIONS MODULE (API)
   ========================= */

async function ensureRepeatPrescriptionsSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS repeat_prescription_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      entry_date TEXT NOT NULL,
      expires_date TEXT NOT NULL,
      client_name TEXT NOT NULL,
      client_id TEXT NOT NULL,
      medicine_name_dose TEXT NOT NULL,
      posology TEXT NOT NULL,
      prescriber_name TEXT NOT NULL,
      prescriber_reg_no TEXT NOT NULL,
      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  const cols = await dbAll(env, "PRAGMA table_info(repeat_prescription_entries)", []);
  let hasExpires = false;
  for (const c of cols) {
    if (String(c.name || "") === "expires_date") { hasExpires = true; break; }
  }
  if (!hasExpires) {
    await dbRun(env, "ALTER TABLE repeat_prescription_entries ADD COLUMN expires_date TEXT", []);
  }

  await dbRun(
    env,
    "UPDATE repeat_prescription_entries SET expires_date = date(entry_date, '+6 months') WHERE expires_date IS NULL OR expires_date = ''",
    []
  );

  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_repeat_rx_org_loc_date ON repeat_prescription_entries (org_id, location_id, entry_date)", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_repeat_rx_org_loc_client ON repeat_prescription_entries (org_id, location_id, client_id)", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_repeat_rx_org_loc_expires ON repeat_prescription_entries (org_id, location_id, expires_date)", []);
}

async function handleRepeatPrescriptionsEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureRepeatPrescriptionsSchema(env);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  // NEW: support either month=YYYY-MM (legacy) OR from/to=YYYY-MM-DD (range)
  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();

  let startStr = "";
  let endStr = "";
  let endOp = "<"; // month mode uses exclusive end

  if (from || to) {
    if (!isValidYmd(from) || !isValidYmd(to)) {
      return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
    }
    if (to < from) {
      return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
    }
    startStr = from;
    endStr = to;
    endOp = "<="; // range mode uses inclusive end
  } else {
    const month = (url.searchParams.get("month") || "").trim();
    const range = monthRange(month);
    if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);
    startStr = range.startStr;
    endStr = range.endStr;
    endOp = "<";
  }

  // IMPORTANT: do NOT filter out expired rows here. We always return them; UI highlights them red.
  const sql = `
    SELECT
      id, entry_date, expires_date,
      client_name, client_id, medicine_name_dose, posology,
      prescriber_name, prescriber_reg_no,
      created_by, created_at, updated_at
    FROM repeat_prescription_entries
    WHERE org_id = ?
      AND location_id = ?
      AND entry_date >= ?
      AND entry_date ${endOp} ?
      ${hasQ ? `AND (
        entry_date LIKE ?
        OR expires_date LIKE ?
        OR client_name LIKE ?
        OR client_id LIKE ?
        OR medicine_name_dose LIKE ?
        OR posology LIKE ?
        OR prescriber_name LIKE ?
        OR prescriber_reg_no LIKE ?
      )` : ""}
    ORDER BY entry_date DESC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id, startStr, endStr];
  if (hasQ) bind.push(qLike, qLike, qLike, qLike, qLike, qLike, qLike, qLike);

  const entries = await dbAll(env, sql, bind);
  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleRepeatPrescriptionsEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureRepeatPrescriptionsSchema(env);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  let expiresDate = String(body.expires_date || "").trim();

  const clientName = String(body.client_name || "").trim();
  const clientId = String(body.client_id || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const posology = String(body.posology || "").trim();
  const prescriberName = String(body.prescriber_name || "").trim();
  const prescriberRegNo = String(body.prescriber_reg_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);

  if (!expiresDate) expiresDate = addMonthsToYmd(entryDate, 6) || "";
  if (!isValidYmd(expiresDate)) return jsonResponse({ ok: false, error: "Invalid expires_date (YYYY-MM-DD)" }, 400, corsOkHeaders);

  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientId) return jsonResponse({ ok: false, error: "Missing client_id" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!posology) return jsonResponse({ ok: false, error: "Missing posology" }, 400, corsOkHeaders);
  if (!prescriberName) return jsonResponse({ ok: false, error: "Missing prescriber_name" }, 400, corsOkHeaders);
  if (!prescriberRegNo) return jsonResponse({ ok: false, error: "Missing prescriber_reg_no" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO repeat_prescription_entries
      (org_id, location_id, entry_date, expires_date, client_name, client_id, medicine_name_dose, posology, prescriber_name, prescriber_reg_no, created_by, created_at, updated_at)
     VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [
      authUser.org_id,
      authUser.location_id,
      entryDate,
      expiresDate,
      clientName,
      clientId,
      medicineNameDose,
      posology,
      prescriberName,
      prescriberRegNo,
      authUser.user_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "REPEAT_RX_ENTRY_CREATE", "repeat_prescription_entries", String(row.id), {
    entry_date: entryDate,
    expires_date: expiresDate,
    client_id: clientId,
    medicine_name_dose: medicineNameDose
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleRepeatPrescriptionsEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureRepeatPrescriptionsSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id FROM repeat_prescription_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  let expiresDate = String(body.expires_date || "").trim();

  const clientName = String(body.client_name || "").trim();
  const clientId = String(body.client_id || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const posology = String(body.posology || "").trim();
  const prescriberName = String(body.prescriber_name || "").trim();
  const prescriberRegNo = String(body.prescriber_reg_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);

  if (!expiresDate) expiresDate = addMonthsToYmd(entryDate, 6) || "";
  if (!isValidYmd(expiresDate)) return jsonResponse({ ok: false, error: "Invalid expires_date (YYYY-MM-DD)" }, 400, corsOkHeaders);

  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientId) return jsonResponse({ ok: false, error: "Missing client_id" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!posology) return jsonResponse({ ok: false, error: "Missing posology" }, 400, corsOkHeaders);
  if (!prescriberName) return jsonResponse({ ok: false, error: "Missing prescriber_name" }, 400, corsOkHeaders);
  if (!prescriberRegNo) return jsonResponse({ ok: false, error: "Missing prescriber_reg_no" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE repeat_prescription_entries
     SET entry_date = ?, expires_date = ?, client_name = ?, client_id = ?, medicine_name_dose = ?, posology = ?, prescriber_name = ?, prescriber_reg_no = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      entryDate,
      expiresDate,
      clientName,
      clientId,
      medicineNameDose,
      posology,
      prescriberName,
      prescriberRegNo,
      entryId,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "REPEAT_RX_ENTRY_UPDATE", "repeat_prescription_entries", String(entryId), {
    entry_date: entryDate,
    expires_date: expiresDate,
    client_id: clientId,
    medicine_name_dose: medicineNameDose
  });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleRepeatPrescriptionsEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureRepeatPrescriptionsSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id, entry_date, expires_date, client_id
     FROM repeat_prescription_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM repeat_prescription_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "REPEAT_RX_ENTRY_DELETE", "repeat_prescription_entries", String(entryId), {
    entry_date: existing.entry_date,
    expires_date: existing.expires_date,
    client_id: existing.client_id
  });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


/* ========================= ALERTS (Recall / Quarantine) ========================= */

async function ensureAlertsSchema(env) {
  await dbRun(env, `
    CREATE TABLE IF NOT EXISTS alerts_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,

      entry_date TEXT NOT NULL,
      alert_type TEXT NOT NULL,
      status TEXT NOT NULL,

      item_name TEXT NOT NULL,
      batch TEXT,
      expiry TEXT,
      quantity TEXT,
      reason TEXT,
      storage_location TEXT NOT NULL,
      supplier TEXT,
      notes TEXT,

      team_informed INTEGER NOT NULL DEFAULT 0,
      supplier_informed INTEGER NOT NULL DEFAULT 0,
      authorities_informed INTEGER NOT NULL DEFAULT 0,
      return_arranged INTEGER NOT NULL DEFAULT 0,
      handed_over INTEGER NOT NULL DEFAULT 0,
      collection_note_received INTEGER NOT NULL DEFAULT 0,
      credit_note_received INTEGER NOT NULL DEFAULT 0,

      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now')),
      created_by INTEGER,
      updated_by INTEGER
    )
  `);
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_alerts_entries_org_loc_date ON alerts_entries(org_id, location_id, entry_date)`);
}

function normalizeAlertType(x) {
  const s = String(x || "").trim().toLowerCase();
  if (s === "recall") return "recall";
  if (s === "quarantine") return "quarantine";
  return "";
}
function normalizeAlertStatus(x) {
  const s = String(x || "").trim().toLowerCase();
  if (s === "open") return "open";
  if (s === "in_progress" || s === "in progress") return "in_progress";
  if (s === "closed") return "closed";
  return "";
}
function to01(v) { return (v === 1 || v === "1" || v === true) ? 1 : 0; }

async function handleAlertsEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureAlertsSchema(env);

  const month = String(url.searchParams.get("month") || "").trim(); // YYYY-MM
  const bind = [authUser.org_id, authUser.location_id];
  let where = `WHERE org_id = ? AND location_id = ?`;
  if (month) { where += ` AND substr(entry_date, 1, 7) = ?`; bind.push(month); }

  const rows = await dbAll(env, `
    SELECT *
    FROM alerts_entries
    ${where}
    ORDER BY entry_date DESC, id DESC
  `, bind);

  return jsonResponse({ ok: true, entries: rows }, 200, corsOkHeaders);
}

async function handleAlertsEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureAlertsSchema(env);

  const body = await readJson(request);
  const entry_date = String(body.entry_date || "").trim();
  const alert_type = normalizeAlertType(body.alert_type);
  const status = normalizeAlertStatus(body.status);
  const item_name = String(body.item_name || "").trim();
  const batch = String(body.batch || "").trim();
  const expiry = String(body.expiry || "").trim();
  const quantity = String(body.quantity || "").trim();
  const reason = String(body.reason || "").trim();
  const storage_location = String(body.storage_location || "").trim().toLowerCase();
  const supplier = String(body.supplier || "").trim();
  const notes = String(body.notes || "").trim();

  if (!/^\d{4}-\d{2}-\d{2}$/.test(entry_date)) return jsonResponse({ ok: false, error: "Invalid date" }, 400, corsOkHeaders);
  if (!alert_type) return jsonResponse({ ok: false, error: "Invalid type" }, 400, corsOkHeaders);
  if (!status) return jsonResponse({ ok: false, error: "Invalid status" }, 400, corsOkHeaders);
  if (!item_name) return jsonResponse({ ok: false, error: "Item name required" }, 400, corsOkHeaders);
  if (!(storage_location === "room" || storage_location === "fridge")) return jsonResponse({ ok: false, error: "Room/Fridge required" }, 400, corsOkHeaders);
  if (expiry && !/^\d{4}-\d{2}-\d{2}$/.test(expiry)) return jsonResponse({ ok: false, error: "Invalid expiry" }, 400, corsOkHeaders);

  const team_informed = to01(body.team_informed);
  const supplier_informed = to01(body.supplier_informed);
  const authorities_informed = to01(body.authorities_informed);
  const return_arranged = to01(body.return_arranged);
  const handed_over = to01(body.handed_over);
  const collection_note_received = to01(body.collection_note_received);
  const credit_note_received = to01(body.credit_note_received);

  const res = await dbRun(env, `
    INSERT INTO alerts_entries (
      org_id, location_id,
      entry_date, alert_type, status,
      item_name, batch, expiry, quantity, reason, storage_location, supplier, notes,
      team_informed, supplier_informed, authorities_informed, return_arranged, handed_over, collection_note_received, credit_note_received,
      created_at, updated_at, created_by, updated_by
    ) VALUES (
      ?, ?,
      ?, ?, ?,
      ?, ?, ?, ?, ?, ?, ?, ?,
      ?, ?, ?, ?, ?, ?, ?,
      datetime('now'), datetime('now'), ?, ?
    )
  `, [
    authUser.org_id, authUser.location_id,
    entry_date, alert_type, status,
    item_name, batch || null, expiry || null, quantity || null, reason || null, storage_location, supplier || null, notes || null,
    team_informed, supplier_informed, authorities_informed, return_arranged, handed_over, collection_note_received, credit_note_received,
    authUser.user_id, authUser.user_id
  ]);

  const newId = (res && res.meta && res.meta.last_row_id) ? Number(res.meta.last_row_id) : null;
  await writeAudit(env, authUser.org_id, authUser.user_id, "ALERT_CREATE", "alerts_entries", String(newId || ""), { entry_date, alert_type, status, item_name });

  return jsonResponse({ ok: true, id: newId }, 200, corsOkHeaders);
}

async function handleAlertsEntryUpdate(request, env, corsOkHeaders, authUser, id) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureAlertsSchema(env);

  const existing = await dbFirst(env, `
    SELECT id FROM alerts_entries
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [id, authUser.org_id, authUser.location_id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);
  const entry_date = String(body.entry_date || "").trim();
  const alert_type = normalizeAlertType(body.alert_type);
  const status = normalizeAlertStatus(body.status);
  const item_name = String(body.item_name || "").trim();
  const batch = String(body.batch || "").trim();
  const expiry = String(body.expiry || "").trim();
  const quantity = String(body.quantity || "").trim();
  const reason = String(body.reason || "").trim();
  const storage_location = String(body.storage_location || "").trim().toLowerCase();
  const supplier = String(body.supplier || "").trim();
  const notes = String(body.notes || "").trim();

  if (!/^\d{4}-\d{2}-\d{2}$/.test(entry_date)) return jsonResponse({ ok: false, error: "Invalid date" }, 400, corsOkHeaders);
  if (!alert_type) return jsonResponse({ ok: false, error: "Invalid type" }, 400, corsOkHeaders);
  if (!status) return jsonResponse({ ok: false, error: "Invalid status" }, 400, corsOkHeaders);
  if (!item_name) return jsonResponse({ ok: false, error: "Item name required" }, 400, corsOkHeaders);
  if (!(storage_location === "room" || storage_location === "fridge")) return jsonResponse({ ok: false, error: "Room/Fridge required" }, 400, corsOkHeaders);
  if (expiry && !/^\d{4}-\d{2}-\d{2}$/.test(expiry)) return jsonResponse({ ok: false, error: "Invalid expiry" }, 400, corsOkHeaders);

  const team_informed = to01(body.team_informed);
  const supplier_informed = to01(body.supplier_informed);
  const authorities_informed = to01(body.authorities_informed);
  const return_arranged = to01(body.return_arranged);
  const handed_over = to01(body.handed_over);
  const collection_note_received = to01(body.collection_note_received);
  const credit_note_received = to01(body.credit_note_received);

  await dbRun(env, `
    UPDATE alerts_entries
    SET
      entry_date = ?, alert_type = ?, status = ?,
      item_name = ?, batch = ?, expiry = ?, quantity = ?, reason = ?, storage_location = ?, supplier = ?, notes = ?,
      team_informed = ?, supplier_informed = ?, authorities_informed = ?, return_arranged = ?, handed_over = ?, collection_note_received = ?, credit_note_received = ?,
      updated_at = datetime('now'), updated_by = ?
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [
    entry_date, alert_type, status,
    item_name, batch || null, expiry || null, quantity || null, reason || null, storage_location, supplier || null, notes || null,
    team_informed, supplier_informed, authorities_informed, return_arranged, handed_over, collection_note_received, credit_note_received,
    authUser.user_id,
    id, authUser.org_id, authUser.location_id
  ]);

  await writeAudit(env, authUser.org_id, authUser.user_id, "ALERT_UPDATE", "alerts_entries", String(id), { entry_date, alert_type, status, item_name });
    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleAlertsEntryDelete(request, env, corsOkHeaders, authUser, id) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureAlertsSchema(env);

  const existing = await dbFirst(env, `
    SELECT id, entry_date, alert_type, item_name
    FROM alerts_entries
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [id, authUser.org_id, authUser.location_id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(env, `DELETE FROM alerts_entries WHERE id = ? AND org_id = ? AND location_id = ?`, [id, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "ALERT_DELETE", "alerts_entries", String(id), existing);

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}



/* ========================= RETURNS (Supplier Returns) ========================= */

async function ensureReturnsSchema(env) {
  await dbRun(env, `
    CREATE TABLE IF NOT EXISTS returns_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,

      entry_date TEXT NOT NULL,
      description TEXT NOT NULL,

      expiry TEXT,
      batch TEXT,
      quantity TEXT,
      supplier TEXT,
      invoice_number TEXT,
      remarks TEXT,
      location_stored TEXT,

      return_arranged INTEGER NOT NULL DEFAULT 0,
      handed_over INTEGER NOT NULL DEFAULT 0,
      collection_note_received INTEGER NOT NULL DEFAULT 0,
      credit_note_received INTEGER NOT NULL DEFAULT 0,

      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now')),
      created_by INTEGER,
      updated_by INTEGER
    )
  `);
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_returns_entries_org_loc_date ON returns_entries(org_id, location_id, entry_date)`);
}

async function handleReturnsEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureReturnsSchema(env);

  const month = String(url.searchParams.get("month") || "").trim(); // YYYY-MM
  const qRaw = String(url.searchParams.get("q") || "").trim().toLowerCase();

  const bind = [authUser.org_id, authUser.location_id];
  let where = "WHERE org_id=? AND location_id=?";

  if (month && /^\d{4}-\d{2}$/.test(month)) {
    where += " AND entry_date LIKE ?";
    bind.push(month + "-%");
  }

  if (qRaw) {
    const like = "%" + qRaw + "%";
    where += " AND (lower(description) LIKE ? OR lower(batch) LIKE ? OR lower(quantity) LIKE ? OR lower(supplier) LIKE ? OR lower(invoice_number) LIKE ? OR lower(remarks) LIKE ? OR lower(location_stored) LIKE ?)";
    bind.push(like, like, like, like, like, like, like);
  }

  const rows = await dbAll(env, `
    SELECT
      id, entry_date, description,
      expiry, batch, quantity, supplier, invoice_number, remarks, location_stored,
      return_arranged, handed_over, collection_note_received, credit_note_received
    FROM returns_entries
    ${where}
    ORDER BY entry_date DESC, id DESC
    LIMIT 800
  `, bind);

  const payload = { ok: true, entries: rows || [] };
  if (isDebugEnabled(request)) payload.debug = { month, q: qRaw, count: (rows || []).length };
  return jsonResponse(payload, 200, corsOkHeaders);
}

async function handleReturnsEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureReturnsSchema(env);

  const body = await readJson(request);
  const entry_date = String(body.entry_date || "").trim();
  const description = String(body.description || "").trim();

  const expiry = String(body.expiry || "").trim();
  const batch = String(body.batch || "").trim();
  const quantity = String(body.quantity || "").trim();
  const supplier = String(body.supplier || "").trim();
  const invoice_number = String(body.invoice_number || "").trim();
  const remarks = String(body.remarks || "").trim();
  const location_stored = String(body.location_stored || "").trim();

  if (!/^\d{4}-\d{2}-\d{2}$/.test(entry_date)) return jsonResponse({ ok: false, error: "Invalid date" }, 400, corsOkHeaders);
  if (!description) return jsonResponse({ ok: false, error: "Description required" }, 400, corsOkHeaders);
  if (expiry && !/^\d{4}-\d{2}-\d{2}$/.test(expiry)) return jsonResponse({ ok: false, error: "Invalid expiry" }, 400, corsOkHeaders);

  const return_arranged = to01(body.return_arranged);
  const handed_over = to01(body.handed_over);
  const collection_note_received = to01(body.collection_note_received);
  const credit_note_received = to01(body.credit_note_received);

  const res = await dbRun(env, `
    INSERT INTO returns_entries (
      org_id, location_id,
      entry_date, description,
      expiry, batch, quantity, supplier, invoice_number, remarks, location_stored,
      return_arranged, handed_over, collection_note_received, credit_note_received,
      created_at, updated_at, created_by, updated_by
    ) VALUES (
      ?, ?,
      ?, ?,
      ?, ?, ?, ?, ?, ?, ?,
      ?, ?, ?, ?,
      datetime('now'), datetime('now'), ?, ?
    )
  `, [
    authUser.org_id, authUser.location_id,
    entry_date, description,
    expiry || null, batch || null, quantity || null, supplier || null, invoice_number || null, remarks || null, location_stored || null,
    return_arranged, handed_over, collection_note_received, credit_note_received,
    authUser.user_id, authUser.user_id
  ]);

  const newId = (res && res.meta && res.meta.last_row_id) ? Number(res.meta.last_row_id) : null;
  await writeAudit(env, authUser.org_id, authUser.user_id, "RETURNS_CREATE", "returns_entries", String(newId || ""), { entry_date, description });

  return jsonResponse({ ok: true, id: newId }, 200, corsOkHeaders);
}

async function handleReturnsEntryUpdate(request, env, corsOkHeaders, authUser, id) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureReturnsSchema(env);

  const existing = await dbFirst(env, `
    SELECT id, entry_date, description
    FROM returns_entries
    WHERE id=? AND org_id=? AND location_id=?
  `, [id, authUser.org_id, authUser.location_id]);

  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);
  const entry_date = String(body.entry_date || "").trim();
  const description = String(body.description || "").trim();

  const expiry = String(body.expiry || "").trim();
  const batch = String(body.batch || "").trim();
  const quantity = String(body.quantity || "").trim();
  const supplier = String(body.supplier || "").trim();
  const invoice_number = String(body.invoice_number || "").trim();
  const remarks = String(body.remarks || "").trim();
  const location_stored = String(body.location_stored || "").trim();

  if (!/^\d{4}-\d{2}-\d{2}$/.test(entry_date)) return jsonResponse({ ok: false, error: "Invalid date" }, 400, corsOkHeaders);
  if (!description) return jsonResponse({ ok: false, error: "Description required" }, 400, corsOkHeaders);
  if (expiry && !/^\d{4}-\d{2}-\d{2}$/.test(expiry)) return jsonResponse({ ok: false, error: "Invalid expiry" }, 400, corsOkHeaders);

  const return_arranged = to01(body.return_arranged);
  const handed_over = to01(body.handed_over);
  const collection_note_received = to01(body.collection_note_received);
  const credit_note_received = to01(body.credit_note_received);

  await dbRun(env, `
    UPDATE returns_entries SET
      entry_date=?,
      description=?,
      expiry=?,
      batch=?,
      quantity=?,
      supplier=?,
      invoice_number=?,
      remarks=?,
      location_stored=?,
      return_arranged=?,
      handed_over=?,
      collection_note_received=?,
      credit_note_received=?,
      updated_at=datetime('now'),
      updated_by=?
    WHERE id=? AND org_id=? AND location_id=?
  `, [
    entry_date,
    description,
    expiry || null,
    batch || null,
    quantity || null,
    supplier || null,
    invoice_number || null,
    remarks || null,
    location_stored || null,
    return_arranged,
    handed_over,
    collection_note_received,
    credit_note_received,
    authUser.user_id,
    id, authUser.org_id, authUser.location_id
  ]);

  await writeAudit(env, authUser.org_id, authUser.user_id, "RETURNS_UPDATE", "returns_entries", String(id), { entry_date, description });
  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleReturnsEntryDelete(request, env, corsOkHeaders, authUser, id) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureReturnsSchema(env);

  const existing = await dbFirst(env, `
    SELECT id, entry_date, description
    FROM returns_entries
    WHERE id=? AND org_id=? AND location_id=?
  `, [id, authUser.org_id, authUser.location_id]);

  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(env, `DELETE FROM returns_entries WHERE id=? AND org_id=? AND location_id=?`, [id, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "RETURNS_DELETE", "returns_entries", String(id), { entry_date: existing.entry_date, description: existing.description });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}


/* =========================
   DDA SALES MODULE (API)  <-- ADDED
   ========================= */

async function ensureDdaSalesSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS dda_sales_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      entry_date TEXT NOT NULL,
      client_name TEXT NOT NULL,
      client_id_card TEXT NOT NULL,
      client_address TEXT NOT NULL,
      medicine_name_dose TEXT NOT NULL,
      quantity INTEGER NOT NULL,
      doctor_name TEXT NOT NULL,
      doctor_reg_no TEXT NOT NULL,
      prescription_serial_no TEXT NOT NULL,
      urgent INTEGER NOT NULL DEFAULT 0,
      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  const cols = await dbAll(env, "PRAGMA table_info(dda_sales_entries)", []);
  let hasUrgent = false;
  for (const c of cols) {
    if (String(c.name || "") === "urgent") { hasUrgent = true; break; }
  }
  if (!hasUrgent) {
    await dbRun(env, "ALTER TABLE dda_sales_entries ADD COLUMN urgent INTEGER NOT NULL DEFAULT 0", []);
  }
  await dbRun(env, "UPDATE dda_sales_entries SET urgent = 0 WHERE urgent IS NULL", []);

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_sales_org_loc_date ON dda_sales_entries (org_id, location_id, entry_date)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_sales_org_loc_client ON dda_sales_entries (org_id, location_id, client_id_card)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_sales_org_loc_serial ON dda_sales_entries (org_id, location_id, prescription_serial_no)",
    []
  );
}



function normalizeIntPositive(n) {
  if (n === null || n === undefined) return null;
  if (n === "") return null;
  const v = Number(n);
  if (!Number.isFinite(v)) return null;
  const i = Math.floor(v);
  if (String(i) !== String(v) && v !== i) {
    // If they send 3.0, Number(v) is 3; still okay. If they send 3.2, reject.
    if (!Number.isInteger(v)) return null;
  }
  return i;
}

function normalizeBool01(v) {
  if (v === null || v === undefined) return 0;
  if (v === true) return 1;
  if (v === false) return 0;
  if (v === 1 || v === 0) return v;
  const s = String(v).trim().toLowerCase();
  if (!s) return 0;
  if (s === "1" || s === "true" || s === "yes" || s === "y" || s === "on") return 1;
  return 0;
}

// ✅ PATCH: normalize Maltese ID card numbers
// - always uppercase
// - if pattern is 1-7 digits + 1 letter => left-pad zeros to 7 digits, keep letter
//   e.g. 789M => 0000789M
function normalizeMtIdCard(raw) {
  const s = String(raw || "").replace(/\s+/g, "").toUpperCase();
  if (!s) return "";
  const m = /^(\d{1,7})([A-Z])$/.exec(s);
  if (m) {
    let digits = m[1];
    while (digits.length < 7) digits = "0" + digits;
    return digits + m[2];
  }
  return s;
}

function mtIdCardLookupKeys(raw) {
  const key = String(raw || "").replace(/\s+/g, "").toUpperCase();
  const norm = normalizeMtIdCard(key);
  const out = [];
  if (norm) out.push(norm);
  if (key && !out.includes(key)) out.push(key);

  const m = /^(\d{1,7})([A-Z])$/.exec(key);
  if (m) {
    const digits = String(parseInt(m[1], 10)); // strips leading zeros
    const unpadded = digits + m[2];
    if (unpadded && !out.includes(unpadded)) out.push(unpadded);
  }
  return out;
}



async function handleDdaSalesEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  const sql = `
    SELECT
      id,
      entry_date,
      client_name,
      client_id_card,
      client_address,
      medicine_name_dose,
      quantity,
      doctor_name,
      doctor_reg_no,
      prescription_serial_no,
      urgent,
      created_by,
      created_at,
      updated_at
    FROM dda_sales_entries
    WHERE org_id = ?
      AND location_id = ?
      AND entry_date >= ?
      AND entry_date < ?
      ${hasQ ? `AND (
        entry_date LIKE ?
        OR client_name LIKE ?
        OR client_id_card LIKE ?
        OR client_address LIKE ?
        OR medicine_name_dose LIKE ?
        OR doctor_name LIKE ?
        OR doctor_reg_no LIKE ?
        OR prescription_serial_no LIKE ?
      )` : ""}
    ORDER BY entry_date DESC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id, range.startStr, range.endStr];
  if (hasQ) {
    bind.push(qLike, qLike, qLike, qLike, qLike, qLike, qLike, qLike);
  }

  const entries = await dbAll(env, sql, bind);

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}



async function handleDdaSalesClientLookup(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  const clientIdCardRaw = String(url.searchParams.get("client_id_card") || "").trim();
  const clientIdCard = normalizeMtIdCard(clientIdCardRaw);
  if (!clientIdCard) return jsonResponse({ ok: false, error: "Missing client_id_card" }, 400, corsOkHeaders);

  const keys = mtIdCardLookupKeys(clientIdCardRaw);
  const placeholders = keys.map(() => "?").join(", ");

  const row = await dbFirst(
    env,
    `SELECT client_name, client_address, client_id_card
     FROM dda_sales_entries
     WHERE org_id = ?
       AND location_id = ?
       AND upper(replace(client_id_card, ' ', '')) IN (${placeholders})
     ORDER BY entry_date DESC, id DESC
     LIMIT 1`,
    [authUser.org_id, authUser.location_id].concat(keys)
  );

  if (!row) return jsonResponse({ ok: true, found: false, client_id_card: clientIdCard }, 200, corsOkHeaders);

  if (row && row.client_id_card && row.client_id_card !== clientIdCard) {
    // normalize existing historical records to prevent duplicates going forward
    await dbRun(
      env,
      `UPDATE dda_sales_entries
       SET client_id_card = ?
       WHERE org_id = ?
         AND location_id = ?
         AND upper(replace(client_id_card, ' ', '')) IN (${placeholders})`,
      [clientIdCard, authUser.org_id, authUser.location_id].concat(keys)
    );
  }

  return jsonResponse(
    { ok: true, found: true, client_id_card: row.client_id_card, client_name: row.client_name, client_address: row.client_address },
    200,
    corsOkHeaders
  );
}

async function handleDdaSalesDoctorsLookup(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  const qRaw = String((url && url.searchParams ? url.searchParams.get("q") : "") || "").trim();
  const limitRaw = parseInt(String((url && url.searchParams ? url.searchParams.get("limit") : "") || "12"), 10);
  const limit = Number.isFinite(limitRaw) ? Math.max(1, Math.min(50, limitRaw)) : 12;

  let sql = `
    SELECT doctor_name, doctor_reg_no, COUNT(*) AS c, MAX(entry_date) AS last_date
    FROM dda_sales_entries
    WHERE org_id = ? AND location_id = ?
      AND doctor_name IS NOT NULL AND doctor_reg_no IS NOT NULL
      AND TRIM(doctor_name) <> '' AND TRIM(doctor_reg_no) <> ''
  `;
  const bind = [authUser.org_id, authUser.location_id];

  if (qRaw) {
    const q = "%" + qRaw.toLowerCase() + "%";
    sql += " AND (LOWER(doctor_name) LIKE ? OR LOWER(doctor_reg_no) LIKE ?) ";
    bind.push(q, q);
  }

  sql += `
    GROUP BY doctor_name, doctor_reg_no
    ORDER BY c DESC, last_date DESC
    LIMIT ?
  `;
  bind.push(limit);

  const rows = await dbAll(env, sql, bind);

  const out = [];
  for (const r of rows) {
    out.push({
      doctor_name: r.doctor_name || "",
      doctor_reg_no: r.doctor_reg_no || "",
      count: r.c == null ? 0 : Number(r.c)
    });
  }

  return jsonResponse({ ok: true, doctors: out }, 200, corsOkHeaders);
}


async function handleDdaSalesEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientIdCard = String(body.client_id_card || "").trim();
  const clientIdCardNorm = normalizeMtIdCard(clientIdCard);
  const keys = mtIdCardLookupKeys(clientIdCard);
  const placeholders = keys.map(() => "?").join(", ");

  // normalize existing historical records for this client_id_card to prevent duplicates
  if (clientIdCardNorm && keys.length) {
  await dbRun(
      env,
      `UPDATE dda_sales_entries
       SET client_id_card = ?
       WHERE org_id = ?
         AND location_id = ?
         AND upper(replace(client_id_card, ' ', '')) IN (${placeholders})`,
      [clientIdCardNorm, authUser.org_id, authUser.location_id].concat(keys)
    );
    }
  const clientAddress = String(body.client_address || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const quantity = normalizeIntPositive(body.quantity);
  const doctorName = String(body.doctor_name || "").trim();
  const doctorRegNo = String(body.doctor_reg_no || "").trim();
  const prescriptionSerialNo = String(body.prescription_serial_no || "").trim();
  const urgent = normalizeBool01(body.urgent);

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientIdCardNorm) return jsonResponse({ ok: false, error: "Missing client_id_card" }, 400, corsOkHeaders);
  if (!clientAddress) return jsonResponse({ ok: false, error: "Missing client_address" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!quantity || quantity < 1) return jsonResponse({ ok: false, error: "Invalid quantity (must be >= 1)" }, 400, corsOkHeaders);
  if (!doctorName) return jsonResponse({ ok: false, error: "Missing doctor_name" }, 400, corsOkHeaders);
  if (!doctorRegNo) return jsonResponse({ ok: false, error: "Missing doctor_reg_no" }, 400, corsOkHeaders);
  if (!prescriptionSerialNo) return jsonResponse({ ok: false, error: "Missing prescription_serial_no" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO dda_sales_entries
      (org_id, location_id, entry_date, client_name, client_id_card, client_address, medicine_name_dose, quantity, doctor_name, doctor_reg_no, prescription_serial_no, urgent, created_by, created_at, updated_at)
     VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [
      authUser.org_id,
      authUser.location_id,
      entryDate,
      clientName,
      clientIdCardNorm,
      clientAddress,
      medicineNameDose,
      quantity,
      doctorName,
      doctorRegNo,
      prescriptionSerialNo,
      urgent,
      authUser.user_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_SALES_ENTRY_CREATE", "dda_sales_entries", String(row.id), {
    entry_date: entryDate,
    client_id_card: clientIdCardNorm,
    prescription_serial_no: prescriptionSerialNo,
    quantity: quantity,
    urgent: urgent
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleDdaSalesEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM dda_sales_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientIdCard = String(body.client_id_card || "").trim();
  const clientIdCardNorm = normalizeMtIdCard(clientIdCard);
  const keys = mtIdCardLookupKeys(clientIdCard);
  const placeholders = keys.map(() => "?").join(", ");

  // normalize existing historical records for this client_id_card to prevent duplicates
  if (clientIdCardNorm && keys.length) {
  await dbRun(
      env,
      `UPDATE dda_sales_entries
       SET client_id_card = ?
       WHERE org_id = ?
         AND location_id = ?
         AND upper(replace(client_id_card, ' ', '')) IN (${placeholders})`,
      [clientIdCardNorm, authUser.org_id, authUser.location_id].concat(keys)
    );
    }
  const clientAddress = String(body.client_address || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const quantity = normalizeIntPositive(body.quantity);
  const doctorName = String(body.doctor_name || "").trim();
  const doctorRegNo = String(body.doctor_reg_no || "").trim();
  const prescriptionSerialNo = String(body.prescription_serial_no || "").trim();
  const urgent = normalizeBool01(body.urgent);

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientIdCardNorm) return jsonResponse({ ok: false, error: "Missing client_id_card" }, 400, corsOkHeaders);
  if (!clientAddress) return jsonResponse({ ok: false, error: "Missing client_address" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!quantity || quantity < 1) return jsonResponse({ ok: false, error: "Invalid quantity (must be >= 1)" }, 400, corsOkHeaders);
  if (!doctorName) return jsonResponse({ ok: false, error: "Missing doctor_name" }, 400, corsOkHeaders);
  if (!doctorRegNo) return jsonResponse({ ok: false, error: "Missing doctor_reg_no" }, 400, corsOkHeaders);
  if (!prescriptionSerialNo) return jsonResponse({ ok: false, error: "Missing prescription_serial_no" }, 400, corsOkHeaders);

  const updRes = await dbRun(
    env,
    `UPDATE dda_sales_entries
     SET entry_date = ?, client_name = ?, client_id_card = ?, client_address = ?, medicine_name_dose = ?, quantity = ?, doctor_name = ?, doctor_reg_no = ?, prescription_serial_no = ?, urgent = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      entryDate,
      clientName,
      clientIdCardNorm,
      clientAddress,
      medicineNameDose,
      quantity,
      doctorName,
      doctorRegNo,
      prescriptionSerialNo,
      urgent,
      entryId,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_SALES_ENTRY_UPDATE", "dda_sales_entries", String(entryId), {
    entry_date: entryDate,
    client_id_card: clientIdCardNorm,
    prescription_serial_no: prescriptionSerialNo,
    quantity: quantity,
    urgent: urgent
  });

  const changes = updRes && updRes.meta && typeof updRes.meta.changes === "number" ? updRes.meta.changes : null;
  const wantDebug = (request.headers.get("X-Eikon-Debug") || "") === "1";

  const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleDdaSalesEntryDeleteByBody(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  let body = null;
  try { body = await request.json(); } catch (e) { body = null; }
  const entryId = parseInt(body && body.id, 10);
  if (!entryId) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);

  // Reuse the canonical delete handler
  return await handleDdaSalesEntryDelete(request, env, corsOkHeaders, authUser, entryId);
}

async function handleDdaSalesEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id, entry_date, client_id_card, prescription_serial_no
     FROM dda_sales_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const delRes = await dbRun(
    env,
    `DELETE FROM dda_sales_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  const changes = delRes && delRes.meta && typeof delRes.meta.changes === "number" ? delRes.meta.changes : null;
  const wantDebug = (request.headers.get("X-Eikon-Debug") || "") === "1";
  if (changes === 0) {
    const payload = { ok: false, error: "Delete failed (no rows changed)" };
    if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
    return jsonResponse(payload, 500, corsOkHeaders);
  }

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_SALES_ENTRY_DELETE", "dda_sales_entries", String(entryId), {
    entry_date: existing.entry_date,
    client_id_card: existing.client_id_card,
    prescription_serial_no: existing.prescription_serial_no
  });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleDdaSalesReport(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();

  if (!isValidYmd(from) || !isValidYmd(to)) {
    return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (to < from) {
    return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
  }

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       client_name,
       client_id_card,
       client_address,
       medicine_name_dose,
       quantity,
       doctor_name,
       doctor_reg_no,
       prescription_serial_no,
       urgent
     FROM dda_sales_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date <= ?
     ORDER BY entry_date ASC, id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  return jsonResponse(
    {
      ok: true,
      org_name: authUser.org_name,
      location_name: authUser.location_name,
      from,
      to,
      entries
    },
    200,
    corsOkHeaders
  );
}

async function handleDdaSalesReportHtml(request, env, corsOkHeaders, authUser, url) {
  const out = await handleDdaSalesReport(request, env, corsOkHeaders, authUser, url);
  const data = await out.json();
  if (!data.ok) return out;

  const entries = data.entries || [];

  const byMonth = new Map();
  for (const e of entries) {
    const ym = ymFromYmd(e.entry_date);
    if (!byMonth.has(ym)) byMonth.set(ym, []);
    byMonth.get(ym).push(e);
  }

  let body = "";
  body += `<h1>${escapeHtml(data.org_name || "Pharmacy")} — DDA Sales Report</h1>`;
  body += `<p class="meta">Location: ${escapeHtml(data.location_name || "")}<br/>Range: ${escapeHtml(data.from)} to ${escapeHtml(data.to)}</p>`;

  for (const [ym, list] of byMonth.entries()) {
    body += `<h2>${escapeHtml(ym)}</h2>`;
    body += `<table><thead><tr>
      <th>Date</th>
      <th>Client Name</th>
      <th>ID Card</th>
      <th>Address</th>
      <th>Medicine Name &amp; Dose</th>
      <th>Qty</th>
      <th>Doctor Name</th>
      <th>Doctor Reg No.</th>
      <th>Prescription Serial No.</th>
      <th>Urgent</th>
    </tr></thead><tbody>`;

    for (const r of list) {
      body += `<tr>
        <td>${escapeHtml(r.entry_date)}</td>
        <td>${escapeHtml(r.client_name)}</td>
        <td>${escapeHtml(r.client_id_card)}</td>
        <td>${escapeHtml(r.client_address)}</td>
        <td>${escapeHtml(r.medicine_name_dose)}</td>
        <td>${escapeHtml(String(r.quantity))}</td>
        <td>${escapeHtml(r.doctor_name)}</td>
        <td>${escapeHtml(r.doctor_reg_no)}</td>
        <td>${escapeHtml(r.prescription_serial_no)}</td>
        <td>${(r && (r.urgent === 1 || r.urgent === true)) ? "URGENT" : ""}</td>
      </tr>`;
    }

    body += `</tbody></table>`;
  }

  return htmlReportPage("DDA Sales Report", body);
}

/* =========================
   DDA POYC MODULE (API)  <-- ADDED (NEW)
   ========================= */

async function ensureDdaPoycSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS dda_poyc_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      entry_date TEXT NOT NULL,
      client_name TEXT NOT NULL,
      client_id_card TEXT NOT NULL,
      client_address TEXT NOT NULL,
      medicine_name_dose TEXT NOT NULL,
      quantity INTEGER NOT NULL,
      doctor_name TEXT NOT NULL,
      doctor_reg_no TEXT NOT NULL,
      prescription_serial_no TEXT NOT NULL,
      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_poyc_org_loc_date ON dda_poyc_entries (org_id, location_id, entry_date)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_poyc_org_loc_client ON dda_poyc_entries (org_id, location_id, client_id_card)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_poyc_org_loc_serial ON dda_poyc_entries (org_id, location_id, prescription_serial_no)",
    []
  );
}

async function handleDdaPoycEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPoycSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  const sql = `
    SELECT
      id,
      entry_date,
      client_name,
      client_id_card,
      client_address,
      medicine_name_dose,
      quantity,
      doctor_name,
      doctor_reg_no,
      prescription_serial_no,
      created_by,
      created_at,
      updated_at
    FROM dda_poyc_entries
    WHERE org_id = ?
      AND location_id = ?
      AND entry_date >= ?
      AND entry_date < ?
      ${hasQ ? `AND (
        entry_date LIKE ?
        OR client_name LIKE ?
        OR client_id_card LIKE ?
        OR client_address LIKE ?
        OR medicine_name_dose LIKE ?
        OR doctor_name LIKE ?
        OR doctor_reg_no LIKE ?
        OR prescription_serial_no LIKE ?
      )` : ""}
    ORDER BY entry_date DESC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id, range.startStr, range.endStr];
  if (hasQ) {
    bind.push(qLike, qLike, qLike, qLike, qLike, qLike, qLike, qLike);
  }

  const entries = await dbAll(env, sql, bind);

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleDdaPoycEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPoycSchema(env);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientIdCard = String(body.client_id_card || "").trim();
  const clientAddress = String(body.client_address || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const quantity = normalizeIntPositive(body.quantity);
  const doctorName = String(body.doctor_name || "").trim();
  const doctorRegNo = String(body.doctor_reg_no || "").trim();
  const prescriptionSerialNo = String(body.prescription_serial_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientIdCard) return jsonResponse({ ok: false, error: "Missing client_id_card" }, 400, corsOkHeaders);
  if (!clientAddress) return jsonResponse({ ok: false, error: "Missing client_address" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!quantity || quantity < 1) return jsonResponse({ ok: false, error: "Invalid quantity (must be >= 1)" }, 400, corsOkHeaders);
  if (!doctorName) return jsonResponse({ ok: false, error: "Missing doctor_name" }, 400, corsOkHeaders);
  if (!doctorRegNo) return jsonResponse({ ok: false, error: "Missing doctor_reg_no" }, 400, corsOkHeaders);
  if (!prescriptionSerialNo) return jsonResponse({ ok: false, error: "Missing prescription_serial_no" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO dda_poyc_entries
      (org_id, location_id, entry_date, client_name, client_id_card, client_address, medicine_name_dose, quantity, doctor_name, doctor_reg_no, prescription_serial_no, created_by, created_at, updated_at)
     VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [
      authUser.org_id,
      authUser.location_id,
      entryDate,
      clientName,
      clientIdCard,
      clientAddress,
      medicineNameDose,
      quantity,
      doctorName,
      doctorRegNo,
      prescriptionSerialNo,
      authUser.user_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_POYC_ENTRY_CREATE", "dda_poyc_entries", String(row.id), {
    entry_date: entryDate,
    client_id_card: clientIdCard,
    prescription_serial_no: prescriptionSerialNo,
    quantity: quantity
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleDdaPoycEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPoycSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM dda_poyc_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientIdCard = String(body.client_id_card || "").trim();
  const clientAddress = String(body.client_address || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const quantity = normalizeIntPositive(body.quantity);
  const doctorName = String(body.doctor_name || "").trim();
  const doctorRegNo = String(body.doctor_reg_no || "").trim();
  const prescriptionSerialNo = String(body.prescription_serial_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientIdCard) return jsonResponse({ ok: false, error: "Missing client_id_card" }, 400, corsOkHeaders);
  if (!clientAddress) return jsonResponse({ ok: false, error: "Missing client_address" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!quantity || quantity < 1) return jsonResponse({ ok: false, error: "Invalid quantity (must be >= 1)" }, 400, corsOkHeaders);
  if (!doctorName) return jsonResponse({ ok: false, error: "Missing doctor_name" }, 400, corsOkHeaders);
  if (!doctorRegNo) return jsonResponse({ ok: false, error: "Missing doctor_reg_no" }, 400, corsOkHeaders);
  if (!prescriptionSerialNo) return jsonResponse({ ok: false, error: "Missing prescription_serial_no" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE dda_poyc_entries
     SET entry_date = ?, client_name = ?, client_id_card = ?, client_address = ?, medicine_name_dose = ?, quantity = ?, doctor_name = ?, doctor_reg_no = ?, prescription_serial_no = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      entryDate,
      clientName,
      clientIdCard,
      clientAddress,
      medicineNameDose,
      quantity,
      doctorName,
      doctorRegNo,
      prescriptionSerialNo,
      entryId,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_POYC_ENTRY_UPDATE", "dda_poyc_entries", String(entryId), {
    entry_date: entryDate,
    client_id_card: clientIdCard,
    prescription_serial_no: prescriptionSerialNo,
    quantity: quantity
  });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleDdaPoycEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPoycSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id, entry_date, client_id_card, prescription_serial_no
     FROM dda_poyc_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM dda_poyc_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_POYC_ENTRY_DELETE", "dda_poyc_entries", String(entryId), {
    entry_date: existing.entry_date,
    client_id_card: existing.client_id_card,
    prescription_serial_no: existing.prescription_serial_no
  });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleDdaPoycReport(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPoycSchema(env);

  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();

  if (!isValidYmd(from) || !isValidYmd(to)) {
    return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (to < from) {
    return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
  }

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       client_name,
       client_id_card,
       client_address,
       medicine_name_dose,
       quantity,
       doctor_name,
       doctor_reg_no,
       prescription_serial_no
     FROM dda_poyc_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date <= ?
     ORDER BY entry_date ASC, id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  return jsonResponse(
    {
      ok: true,
      org_name: authUser.org_name,
      location_name: authUser.location_name,
      from,
      to,
      entries
    },
    200,
    corsOkHeaders
  );
}

async function handleDdaPoycReportHtml(request, env, corsOkHeaders, authUser, url) {
  const out = await handleDdaPoycReport(request, env, corsOkHeaders, authUser, url);
  const data = await out.json();
  if (!data.ok) return out;

  const entries = data.entries || [];

  const byMonth = new Map();
  for (const e of entries) {
    const ym = ymFromYmd(e.entry_date);
    if (!byMonth.has(ym)) byMonth.set(ym, []);
    byMonth.get(ym).push(e);
  }

  let body = "";
  body += `<h1>${escapeHtml(data.org_name || "Pharmacy")} — DDA POYC Report</h1>`;
  body += `<p class="meta">Location: ${escapeHtml(data.location_name || "")}<br/>Range: ${escapeHtml(data.from)} to ${escapeHtml(data.to)}</p>`;

  for (const [ym, list] of byMonth.entries()) {
    body += `<h2>${escapeHtml(ym)}</h2>`;
    body += `<table><thead><tr>
      <th>Date</th>
      <th>Client Name</th>
      <th>ID Card</th>
      <th>Address</th>
      <th>Medicine Name &amp; Dose</th>
      <th>Qty</th>
      <th>Doctor Name</th>
      <th>Doctor Reg No.</th>
      <th>Prescription Serial No.</th>
    </tr></thead><tbody>`;

    for (const r of list) {
      body += `<tr>
        <td>${escapeHtml(r.entry_date)}</td>
        <td>${escapeHtml(r.client_name)}</td>
        <td>${escapeHtml(r.client_id_card)}</td>
        <td>${escapeHtml(r.client_address)}</td>
        <td>${escapeHtml(r.medicine_name_dose)}</td>
        <td>${escapeHtml(String(r.quantity))}</td>
        <td>${escapeHtml(r.doctor_name)}</td>
        <td>${escapeHtml(r.doctor_reg_no)}</td>
        <td>${escapeHtml(r.prescription_serial_no)}</td>
      </tr>`;
    }

    body += `</tbody></table>`;
  }

  return htmlReportPage("DDA POYC Report", body);
}

/* =========================
   DDA PURCHASES MODULE (API)  <-- NEW
   ========================= */

async function ensureDdaPurchasesSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS dda_purchases_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      entry_date TEXT NOT NULL,
      dda_name_dose TEXT NOT NULL,
      quantity INTEGER NOT NULL,
      agent TEXT NOT NULL,
      invoice_number TEXT NOT NULL,
      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_purchases_org_loc_date ON dda_purchases_entries (org_id, location_id, entry_date)",
    []
  );
  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_purchases_org_loc_invoice ON dda_purchases_entries (org_id, location_id, invoice_number)",
    []
  );
  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_purchases_org_loc_dda ON dda_purchases_entries (org_id, location_id, dda_name_dose)",
    []
  );
}

async function handleDdaPurchasesEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPurchasesSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  const sql = `
    SELECT
      id,
      entry_date,
      dda_name_dose,
      quantity,
      agent,
      invoice_number,
      created_by,
      created_at,
      updated_at
    FROM dda_purchases_entries
    WHERE org_id = ?
      AND location_id = ?
      AND entry_date >= ?
      AND entry_date < ?
      ${hasQ ? `AND (
        entry_date LIKE ?
        OR dda_name_dose LIKE ?
        OR agent LIKE ?
        OR invoice_number LIKE ?
      )` : ""}
    ORDER BY entry_date DESC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id, range.startStr, range.endStr];
  if (hasQ) bind.push(qLike, qLike, qLike, qLike);

  const entries = await dbAll(env, sql, bind);
  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleDdaPurchasesEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPurchasesSchema(env);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const ddaNameDose = String(body.dda_name_dose || "").trim();
  const quantity = normalizeIntPositive(body.quantity);
  const agent = String(body.agent || "").trim();
  const invoiceNumber = String(body.invoice_number || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!ddaNameDose) return jsonResponse({ ok: false, error: "Missing dda_name_dose" }, 400, corsOkHeaders);
  if (!quantity || quantity < 1) return jsonResponse({ ok: false, error: "Invalid quantity (must be >= 1)" }, 400, corsOkHeaders);
  if (!agent) return jsonResponse({ ok: false, error: "Missing agent" }, 400, corsOkHeaders);
  if (!invoiceNumber) return jsonResponse({ ok: false, error: "Missing invoice_number" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO dda_purchases_entries
      (org_id, location_id, entry_date, dda_name_dose, quantity, agent, invoice_number, created_by, created_at, updated_at)
     VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [
      authUser.org_id,
      authUser.location_id,
      entryDate,
      ddaNameDose,
      quantity,
      agent,
      invoiceNumber,
      authUser.user_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_PURCHASES_ENTRY_CREATE", "dda_purchases_entries", String(row.id), {
    entry_date: entryDate,
    dda_name_dose: ddaNameDose,
    invoice_number: invoiceNumber,
    quantity
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleDdaPurchasesEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPurchasesSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM dda_purchases_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const ddaNameDose = String(body.dda_name_dose || "").trim();
  const quantity = normalizeIntPositive(body.quantity);
  const agent = String(body.agent || "").trim();
  const invoiceNumber = String(body.invoice_number || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!ddaNameDose) return jsonResponse({ ok: false, error: "Missing dda_name_dose" }, 400, corsOkHeaders);
  if (!quantity || quantity < 1) return jsonResponse({ ok: false, error: "Invalid quantity (must be >= 1)" }, 400, corsOkHeaders);
  if (!agent) return jsonResponse({ ok: false, error: "Missing agent" }, 400, corsOkHeaders);
  if (!invoiceNumber) return jsonResponse({ ok: false, error: "Missing invoice_number" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE dda_purchases_entries
     SET entry_date = ?, dda_name_dose = ?, quantity = ?, agent = ?, invoice_number = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      entryDate,
      ddaNameDose,
      quantity,
      agent,
      invoiceNumber,
      entryId,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_PURCHASES_ENTRY_UPDATE", "dda_purchases_entries", String(entryId), {
    entry_date: entryDate,
    dda_name_dose: ddaNameDose,
    invoice_number: invoiceNumber,
    quantity
  });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleDdaPurchasesEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPurchasesSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id, entry_date, dda_name_dose, invoice_number
     FROM dda_purchases_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM dda_purchases_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_PURCHASES_ENTRY_DELETE", "dda_purchases_entries", String(entryId), {
    entry_date: existing.entry_date,
    dda_name_dose: existing.dda_name_dose,
    invoice_number: existing.invoice_number
  });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleDdaPurchasesReport(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPurchasesSchema(env);

  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();

  if (!isValidYmd(from) || !isValidYmd(to)) {
    return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (to < from) {
    return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
  }

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       dda_name_dose,
       quantity,
       agent,
       invoice_number
     FROM dda_purchases_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date <= ?
     ORDER BY entry_date ASC, id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  return jsonResponse(
    {
      ok: true,
      org_name: authUser.org_name,
      location_name: authUser.location_name,
      from,
      to,
      entries
    },
    200,
    corsOkHeaders
  );
}

async function handleDdaPurchasesReportHtml(request, env, corsOkHeaders, authUser, url) {
  const out = await handleDdaPurchasesReport(request, env, corsOkHeaders, authUser, url);
  const data = await out.json();
  if (!data.ok) return out;

  const entries = data.entries || [];

  const byMonth = new Map();
  for (const e of entries) {
    const ym = ymFromYmd(e.entry_date);
    if (!byMonth.has(ym)) byMonth.set(ym, []);
    byMonth.get(ym).push(e);
  }

  let body = "";
  body += `<h1>${escapeHtml(data.org_name || "Pharmacy")} — DDA Purchases Report</h1>`;
  body += `<p class="meta">Location: ${escapeHtml(data.location_name || "")}<br/>Range: ${escapeHtml(data.from)} to ${escapeHtml(data.to)}</p>`;

  for (const [ym, list] of byMonth.entries()) {
    body += `<h2>${escapeHtml(ym)}</h2>`;
    body += `<table><thead><tr>
      <th>Date</th>
      <th>DDA Name &amp; Dose</th>
      <th>Qty</th>
      <th>Agent</th>
      <th>Invoice No.</th>
    </tr></thead><tbody>`;

    for (const r of list) {
      body += `<tr>
        <td>${escapeHtml(r.entry_date)}</td>
        <td>${escapeHtml(r.dda_name_dose)}</td>
        <td>${escapeHtml(String(r.quantity))}</td>
        <td>${escapeHtml(r.agent)}</td>
        <td>${escapeHtml(r.invoice_number)}</td>
      </tr>`;
    }

    body += `</tbody></table>`;
  }

  return htmlReportPage("DDA Purchases Report", body);
}

/* ========================= DDA STOCK TAKES MODULE (API) ========================= */
async function ensureDdaStockTakesSchema(env) {
  await dbRun(env, `CREATE TABLE IF NOT EXISTS dda_stocktakes (id INTEGER PRIMARY KEY AUTOINCREMENT, org_id INTEGER NOT NULL, location_id INTEGER NOT NULL, created_at TEXT NOT NULL DEFAULT (datetime('now')), created_by INTEGER, closed_at TEXT, updated_at TEXT NOT NULL DEFAULT (datetime('now')))`, []);
  await dbRun(env, `CREATE TABLE IF NOT EXISTS dda_stocktake_items (id INTEGER PRIMARY KEY AUTOINCREMENT, org_id INTEGER NOT NULL, location_id INTEGER NOT NULL, stocktake_id INTEGER NOT NULL, item_name TEXT NOT NULL, dosage TEXT, qty_tablets INTEGER NOT NULL DEFAULT 0, created_at TEXT NOT NULL DEFAULT (datetime('now')), updated_at TEXT NOT NULL DEFAULT (datetime('now')))`, []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_dda_stocktakes_org_loc_created ON dda_stocktakes (org_id, location_id, created_at)", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_dda_stocktake_items_stocktake ON dda_stocktake_items (org_id, location_id, stocktake_id)", []);
}

async function handleDdaStockTakesList(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const stocktakes = await dbAll(env, `
    SELECT s.id, s.created_at, s.closed_at, s.updated_at,
      (SELECT COUNT(*) FROM dda_stocktake_items i
        WHERE i.org_id=s.org_id AND i.location_id=s.location_id AND i.stocktake_id=s.id) AS item_count
    FROM dda_stocktakes s
    WHERE s.org_id = ? AND s.location_id = ?
    ORDER BY s.created_at DESC, s.id DESC
  `, [authUser.org_id, authUser.location_id]);

  return jsonResponse({ ok: true, stocktakes }, 200, corsOkHeaders);
}

async function handleDdaStockTakeCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const row = await dbFirst(env, `
    INSERT INTO dda_stocktakes (org_id, location_id, created_by, created_at, updated_at)
    VALUES (?, ?, ?, datetime('now'), datetime('now'))
    RETURNING id, created_at
  `, [authUser.org_id, authUser.location_id, authUser.user_id]);

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_STOCKTAKE_CREATE", "dda_stocktakes", String(row.id), { created_at: row.created_at });
  return jsonResponse({ ok: true, stocktake_id: row.id, created_at: row.created_at }, 200, corsOkHeaders);
}

async function handleDdaStockTakeGet(request, env, corsOkHeaders, authUser, stocktakeId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const st = await dbFirst(env, `
    SELECT id, created_at, created_by, closed_at, updated_at
    FROM dda_stocktakes
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [stocktakeId, authUser.org_id, authUser.location_id]);

  if (!st) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const items = await dbAll(env, `
    SELECT id, stocktake_id, item_name, dosage, qty_tablets, created_at, updated_at
    FROM dda_stocktake_items
    WHERE stocktake_id = ? AND org_id = ? AND location_id = ?
    ORDER BY item_name COLLATE NOCASE ASC, id ASC
  `, [stocktakeId, authUser.org_id, authUser.location_id]);

  return jsonResponse({ ok: true, stocktake: st, items }, 200, corsOkHeaders);
}

async function handleDdaStockTakeUpdate(request, env, corsOkHeaders, authUser, stocktakeId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const st = await dbFirst(env, `SELECT id, closed_at FROM dda_stocktakes WHERE id = ? AND org_id = ? AND location_id = ?`, [stocktakeId, authUser.org_id, authUser.location_id]);
  if (!st) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);
  const close = body && (body.closed === 1 || body.closed === true);
  const reopen = body && (body.closed === 0 || body.closed === false);

  if (close) {
    await dbRun(env, `
      UPDATE dda_stocktakes
      SET closed_at = COALESCE(closed_at, datetime('now')),
          updated_at = datetime('now')
      WHERE id = ? AND org_id = ? AND location_id = ?
    `, [stocktakeId, authUser.org_id, authUser.location_id]);

    await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_STOCKTAKE_CLOSE", "dda_stocktakes", String(stocktakeId), {});
  } else if (reopen) {
    await dbRun(env, `
      UPDATE dda_stocktakes
      SET closed_at = NULL,
          updated_at = datetime('now')
      WHERE id = ? AND org_id = ? AND location_id = ?
    `, [stocktakeId, authUser.org_id, authUser.location_id]);

    await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_STOCKTAKE_REOPEN", "dda_stocktakes", String(stocktakeId), {});
  }

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleDdaStockTakeItemAdd(request, env, corsOkHeaders, authUser, stocktakeId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const st = await dbFirst(env, `SELECT id FROM dda_stocktakes WHERE id = ? AND org_id = ? AND location_id = ?`, [stocktakeId, authUser.org_id, authUser.location_id]);
  if (!st) return jsonResponse({ ok: false, error: "Stock take not found" }, 404, corsOkHeaders);

  const body = await readJson(request);
  const name = String(body.item_name || "").trim();
  const dosage = String(body.dosage || "").trim();
  const qty = Number(body.qty_tablets);

  if (!name) return jsonResponse({ ok: false, error: "Missing item_name" }, 400, corsOkHeaders);
  if (!Number.isFinite(qty) || qty < 0) return jsonResponse({ ok: false, error: "Invalid qty_tablets (>= 0)" }, 400, corsOkHeaders);

  const row = await dbFirst(env, `
    INSERT INTO dda_stocktake_items (org_id, location_id, stocktake_id, item_name, dosage, qty_tablets, created_at, updated_at)
    VALUES (?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
    RETURNING id
  `, [authUser.org_id, authUser.location_id, stocktakeId, name, dosage, Math.floor(qty)]);

  await dbRun(env, `UPDATE dda_stocktakes SET updated_at = datetime('now') WHERE id = ? AND org_id = ? AND location_id = ?`, [stocktakeId, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_STOCKTAKE_ITEM_ADD", "dda_stocktake_items", String(row.id), { stocktake_id: stocktakeId, item_name: name, dosage, qty_tablets: Math.floor(qty) });

  return jsonResponse({ ok: true, item_id: row.id }, 200, corsOkHeaders);
}

async function handleDdaStockTakeItemUpdate(request, env, corsOkHeaders, authUser, itemId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const existing = await dbFirst(env, `
    SELECT id, stocktake_id
    FROM dda_stocktake_items
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [itemId, authUser.org_id, authUser.location_id]);

  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);
  const name = String(body.item_name || "").trim();
  const dosage = String(body.dosage || "").trim();
  const qty = Number(body.qty_tablets);

  if (!name) return jsonResponse({ ok: false, error: "Missing item_name" }, 400, corsOkHeaders);
  if (!Number.isFinite(qty) || qty < 0) return jsonResponse({ ok: false, error: "Invalid qty_tablets (>= 0)" }, 400, corsOkHeaders);

  await dbRun(env, `
    UPDATE dda_stocktake_items
    SET item_name = ?, dosage = ?, qty_tablets = ?, updated_at = datetime('now')
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [name, dosage, Math.floor(qty), itemId, authUser.org_id, authUser.location_id]);

  await dbRun(env, `UPDATE dda_stocktakes SET updated_at = datetime('now') WHERE id = ? AND org_id = ? AND location_id = ?`, [existing.stocktake_id, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_STOCKTAKE_ITEM_UPDATE", "dda_stocktake_items", String(itemId), { item_name: name, dosage, qty_tablets: Math.floor(qty) });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleDdaStockTakeItemDelete(request, env, corsOkHeaders, authUser, itemId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const existing = await dbFirst(env, `
    SELECT id, stocktake_id, item_name
    FROM dda_stocktake_items
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [itemId, authUser.org_id, authUser.location_id]);

  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(env, `DELETE FROM dda_stocktake_items WHERE id = ? AND org_id = ? AND location_id = ?`, [itemId, authUser.org_id, authUser.location_id]);
  await dbRun(env, `UPDATE dda_stocktakes SET updated_at = datetime('now') WHERE id = ? AND org_id = ? AND location_id = ?`, [existing.stocktake_id, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_STOCKTAKE_ITEM_DELETE", "dda_stocktake_items", String(itemId), { item_name: existing.item_name });

    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleDdaStockTakeReportHtml(request, env, corsOkHeaders, authUser, stocktakeId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const st = await dbFirst(env, `
    SELECT id, created_at, closed_at
    FROM dda_stocktakes
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [stocktakeId, authUser.org_id, authUser.location_id]);

  if (!st) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const items = await dbAll(env, `
    SELECT item_name, dosage, qty_tablets
    FROM dda_stocktake_items
    WHERE stocktake_id = ? AND org_id = ? AND location_id = ?
    ORDER BY item_name COLLATE NOCASE ASC, id ASC
  `, [stocktakeId, authUser.org_id, authUser.location_id]);

  let body = "";
  body += `<h1>${escapeHtml(authUser.org_name || "Pharmacy")} — DDA Stock Take</h1>`;
  body += `<div class="meta">Location: ${escapeHtml(authUser.location_name || "")}<br>
    Stock Take ID: ${escapeHtml(String(st.id))}<br>
    Created: ${escapeHtml(String(st.created_at || ""))}${st.closed_at ? `<br>Closed: ${escapeHtml(String(st.closed_at))}` : ""}</div>`;

  body += `<table><thead><tr><th>Name</th><th>Dosage</th><th>Quantity of Tablets</th></tr></thead><tbody>`;
  if (!items.length) {
    body += `<tr><td colspan="3">No items.</td></tr>`;
  } else {
    for (const it of items) {
      body += `<tr><td>${escapeHtml(it.item_name || "")}</td><td>${escapeHtml(it.dosage || "")}</td><td>${escapeHtml(String(it.qty_tablets == null ? "" : it.qty_tablets))}</td></tr>`;
    }
  }
  body += `</tbody></table>`;

  body += `<div class="meta">Generated: ${escapeHtml(nowIso())}</div>`;
  return htmlReportPage("DDA Stock Take", body);
}


/* =========================
   CERTIFICATES MODULE (API)
   ========================= */

function addMonthsToYmd(ymd, months) {
  const s = String(ymd || "").trim();
  if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return null;

  const y = parseInt(s.slice(0, 4), 10);
  const m = parseInt(s.slice(5, 7), 10);
  const d = parseInt(s.slice(8, 10), 10);

  if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return null;

  const targetMonthIndex = (m - 1) + Number(months || 0);
  const ty = y + Math.floor(targetMonthIndex / 12);
  const tm = (targetMonthIndex % 12 + 12) % 12; // 0..11

  // Clamp day to end of month
  const lastDay = new Date(Date.UTC(ty, tm + 1, 0)).getUTCDate();
  const td = Math.min(d, lastDay);

  const dt = new Date(Date.UTC(ty, tm, td));
  return dt.toISOString().slice(0, 10);
}

async function ensureCertificatesSchema(env) {
  console.log("[certificates] ensureCertificatesSchema() start");

  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS certificates_items (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      item_key TEXT NOT NULL,
      title TEXT NOT NULL,
      subtitle TEXT NOT NULL,
      last_label TEXT NOT NULL,
      next_label TEXT NOT NULL,
      interval_months INTEGER NOT NULL DEFAULT 12,
      last_date TEXT,
      certified_person TEXT,
      requires_person INTEGER NOT NULL DEFAULT 0,
      file_name TEXT,
      file_mime TEXT,
      file_size INTEGER,
      file_uploaded_at TEXT,
      file_r2_key TEXT,
      file_b64 TEXT,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now')),
      created_by INTEGER,
      updated_by INTEGER,
      UNIQUE(org_id, location_id, item_key)
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_certificates_items_org_loc ON certificates_items (org_id, location_id)",
    []
  );

  console.log("[certificates] ensureCertificatesSchema() done");
}

async function ensureDefaultCertificatesIfMissing(env, authUser) {
  await ensureCertificatesSchema(env);

  const existing = await dbFirst(
    env,
    "SELECT COUNT(*) AS c FROM certificates_items WHERE org_id = ? AND location_id = ?",
    [authUser.org_id, authUser.location_id]
  );

  const c = existing && existing.c ? Number(existing.c) : 0;
  console.log("[certificates] ensureDefaultCertificatesIfMissing() existing count=", c);

  if (c > 0) return;

  if (!requireRole(authUser, ["admin"])) return;

  const defaults = [
    {
      item_key: "thermometer_calibration",
      title: "Thermometer Calibration",
      subtitle: "Yearly calibration",
      last_label: "Last Calibration",
      next_label: "Next Due",
      interval_months: 12,
      requires_person: 0
    },
    {
      item_key: "ac_maintenance",
      title: "AC Maintenance",
      subtitle: "Yearly service",
      last_label: "Last Service",
      next_label: "Next Due",
      interval_months: 12,
      requires_person: 0
    },
    {
      item_key: "first_aid_certificate",
      title: "First Aid Certificate",
      subtitle: "3 year renewal",
      last_label: "Issued / Last Renewal",
      next_label: "Renew By",
      interval_months: 36,
      requires_person: 1
    },
    {
      item_key: "dispensary_licence",
      title: "Dispensary Licence",
      subtitle: "Yearly renewal",
      last_label: "Last Renewal",
      next_label: "Renew By",
      interval_months: 12,
      requires_person: 0
    },
    {
      item_key: "fire_extinguisher",
      title: "Fire Extinguisher",
      subtitle: "Yearly renewal",
      last_label: "Last Renewal",
      next_label: "Renew By",
      interval_months: 12,
      requires_person: 0
    },
    {
      item_key: "pest_control",
      title: "Pest Control",
      subtitle: "Yearly service",
      last_label: "Last Service",
      next_label: "Next Due",
      interval_months: 12,
      requires_person: 0
    },
    {
      item_key: "fire_training",
      title: "Fire Training",
      subtitle: "3 year renewal",
      last_label: "Issued / Last Renewal",
      next_label: "Renew By",
      interval_months: 36,
      requires_person: 1
    },
    {
      item_key: "reverse_osmosis_system",
      title: "Reverse Osmmosis System",
      subtitle: "Yearly service",
      last_label: "Last Service",
      next_label: "Next Due",
      interval_months: 12,
      requires_person: 0
    }
  ];

  for (const it of defaults) {
    console.log("[certificates] inserting default item", it.item_key);
    await dbRun(
      env,
      `INSERT INTO certificates_items
        (org_id, location_id, item_key, title, subtitle, last_label, next_label, interval_months, requires_person, created_at, updated_at, created_by, updated_by)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'), ?, ?)
       ON CONFLICT(org_id, location_id, item_key)
       DO NOTHING`,
      [
        authUser.org_id,
        authUser.location_id,
        it.item_key,
        it.title,
        it.subtitle,
        it.last_label,
        it.next_label,
        it.interval_months,
        it.requires_person ? 1 : 0,
        authUser.user_id,
        authUser.user_id
      ]
    );
  }

  await writeAudit(env, authUser.org_id, authUser.user_id, "CERT_DEFAULT_ITEMS_CREATE", "location", String(authUser.location_id), {});
  console.log("[certificates] default items ensured");
}

async function getCertificateItemByIdOrKey(env, authUser, idOrKey) {
  const raw = String(idOrKey || "").trim();
  if (!raw) return null;

  let row = null;

  if (/^\d+$/.test(raw)) {
    const id = parseInt(raw, 10);
    row = await dbFirst(
      env,
      `SELECT *
       FROM certificates_items
       WHERE id = ? AND org_id = ? AND location_id = ?`,
      [id, authUser.org_id, authUser.location_id]
    );
    if (row) return row;
  }

  row = await dbFirst(
    env,
    `SELECT *
     FROM certificates_items
     WHERE item_key = ? AND org_id = ? AND location_id = ?`,
    [raw, authUser.org_id, authUser.location_id]
  );

  return row || null;
}

async function handleCertificatesItemsList(request, env, corsOkHeaders, authUser) {
  console.log("[certificates] LIST start", { org_id: authUser.org_id, location_id: authUser.location_id });

  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDefaultCertificatesIfMissing(env, authUser);

  const items = await dbAll(
    env,
    `SELECT
       id,
       item_key,
       title,
       subtitle,
       last_label,
       next_label,
       interval_months,
       last_date,
       certified_person,
       requires_person,
       file_name,
       file_mime,
       file_size,
       file_uploaded_at,
       file_r2_key,
       created_at,
       updated_at
     FROM certificates_items
     WHERE org_id = ? AND location_id = ?
     ORDER BY id ASC`,
    [authUser.org_id, authUser.location_id]
  );

  const out = [];
  for (const it of items) {
    const next_due = (it.last_date && it.interval_months)
      ? addMonthsToYmd(it.last_date, Number(it.interval_months))
      : null;

    out.push({
      id: it.id,
      item_key: it.item_key,
      title: it.title,
      subtitle: it.subtitle,
      last_label: it.last_label,
      next_label: it.next_label,
      interval_months: Number(it.interval_months || 12),
      last_date: it.last_date || null,
      next_due: next_due,
      certified_person: it.certified_person || "",
      requires_person: it.requires_person ? 1 : 0,
      file_name: it.file_name || "",
      file_uploaded_at: it.file_uploaded_at || "",
      file_mime: it.file_mime || "",
      file_size: it.file_size === null || it.file_size === undefined ? null : Number(it.file_size),
      file_r2_key: it.file_r2_key || ""
    });
  }

  console.log("[certificates] LIST done count=", out.length);
  return jsonResponse({ ok: true, items: out }, 200, corsOkHeaders);
}

async function handleCertificatesItemUpdate(request, env, corsOkHeaders, authUser, idOrKey) {
  console.log("[certificates] UPDATE start", { idOrKey: String(idOrKey), org_id: authUser.org_id, location_id: authUser.location_id });

  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDefaultCertificatesIfMissing(env, authUser);

  const existing = await getCertificateItemByIdOrKey(env, authUser, idOrKey);
  if (!existing) {
    console.log("[certificates] UPDATE not found", { idOrKey: String(idOrKey) });
    return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
  }

  const body = await readJson(request);

  const lastDate = body.last_date === null || body.last_date === undefined ? undefined : String(body.last_date || "").trim();
  const intervalMonths = body.interval_months === null || body.interval_months === undefined ? undefined : parseInt(body.interval_months, 10);
  const certifiedPerson = body.certified_person === undefined ? undefined : String(body.certified_person || "").trim();

  if (lastDate !== undefined) {
    if (lastDate && !isValidYmd(lastDate)) {
      return jsonResponse({ ok: false, error: "Invalid last_date (YYYY-MM-DD or null)" }, 400, corsOkHeaders);
    }
  }

  let newInterval = existing.interval_months;
  if (intervalMonths !== undefined) {
    if (!Number.isFinite(intervalMonths) || intervalMonths < 1 || intervalMonths > 240) {
      return jsonResponse({ ok: false, error: "Invalid interval_months (1..240)" }, 400, corsOkHeaders);
    }
    newInterval = intervalMonths;
  }

  let newLast = existing.last_date;
  if (lastDate !== undefined) {
    newLast = lastDate ? lastDate : null;
  }

  let newPerson = existing.certified_person;
  if (existing.requires_person === 1) {
    if (certifiedPerson !== undefined) newPerson = certifiedPerson;
  } else {
    if (certifiedPerson !== undefined) {
      console.log("[certificates] UPDATE: ignoring certified_person (requires_person=0)");
    }
  }

  await dbRun(
    env,
    `UPDATE certificates_items
     SET last_date = ?, interval_months = ?, certified_person = ?, updated_at = datetime('now'), updated_by = ?
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      newLast,
      newInterval,
      existing.requires_person === 1 ? (newPerson || "") : (existing.certified_person || ""),
      authUser.user_id,
      existing.id,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CERT_ITEM_UPDATE", "certificates_items", String(existing.id), {
    id: existing.id,
    item_key: existing.item_key,
    last_date: newLast,
    interval_months: newInterval,
    certified_person: (existing.requires_person === 1 ? (newPerson || "") : "")
  });

  console.log("[certificates] UPDATE done", { id: existing.id, item_key: existing.item_key });
    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


async function handleCertificatesUpload(request, env, corsOkHeaders, authUser, idOrKey) {
  console.log("[certificates] UPLOAD start", { idOrKey: String(idOrKey), ct: request.headers.get("Content-Type") || "" });

  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDefaultCertificatesIfMissing(env, authUser);

  const existing = await getCertificateItemByIdOrKey(env, authUser, idOrKey);
  if (!existing) {
    console.log("[certificates] UPLOAD not found", { idOrKey: String(idOrKey) });
    return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
  }

  const ct = (request.headers.get("Content-Type") || "").toLowerCase();

  let fileName = "";
  let fileMime = "application/octet-stream";
  let fileSize = 0;
  let bytes = null;

  if (ct.includes("multipart/form-data")) {
    const form = await request.formData();
    const f = form.get("file");

    if (!f) return jsonResponse({ ok: false, error: "Missing form field: file" }, 400, corsOkHeaders);
    if (!(f instanceof File)) return jsonResponse({ ok: false, error: "Invalid file upload" }, 400, corsOkHeaders);

    fileName = String(f.name || "upload.bin");
    fileMime = String(f.type || "application/octet-stream");
    fileSize = Number(f.size || 0);

    const ab = await f.arrayBuffer();
    bytes = new Uint8Array(ab);

    console.log("[certificates] UPLOAD multipart received", { fileName, fileMime, fileSize });
  } else if (ct.includes("application/json")) {
    const body = await readJson(request);

    fileName = String(body.file_name || "").trim();
    fileMime = String(body.file_mime || "application/octet-stream").trim() || "application/octet-stream";
    const b64 = String(body.file_b64 || "").trim();

    if (!fileName) return jsonResponse({ ok: false, error: "Missing file_name" }, 400, corsOkHeaders);
    if (!b64) return jsonResponse({ ok: false, error: "Missing file_b64" }, 400, corsOkHeaders);

    try {
      bytes = bytesFromBase64(b64);
    } catch (e) {
      console.log("[certificates] UPLOAD json base64 decode failed", e && (e.stack || e.message || String(e)));
      return jsonResponse({ ok: false, error: "Invalid base64" }, 400, corsOkHeaders);
    }

    fileSize = bytes.length;

    console.log("[certificates] UPLOAD json received", { fileName, fileMime, fileSize });
  } else {
    return jsonResponse({ ok: false, error: "Unsupported Content-Type for upload" }, 415, corsOkHeaders);
  }

  const maxBytes = parseInt((env.CERT_UPLOAD_MAX_BYTES || "800000").trim(), 10);
  const hasR2 = !!env.CERTS_R2;

  if (!hasR2 && fileSize > maxBytes) {
    console.log("[certificates] UPLOAD too large for D1 base64", { fileSize, maxBytes });
    return jsonResponse({ ok: false, error: `File too large (${fileSize} bytes). Max without R2 is ${maxBytes}.` }, 413, corsOkHeaders);
  }

  let fileR2Key = null;
  let fileB64 = null;

  if (hasR2) {
    const safeName = fileName.replace(/[^\w.\-() ]+/g, "_").slice(0, 120) || "upload.bin";
    fileR2Key = `certificates/org_${authUser.org_id}/loc_${authUser.location_id}/${existing.item_key}/${Date.now()}_${safeName}`;

    console.log("[certificates] UPLOAD storing in R2", { fileR2Key });

    await env.CERTS_R2.put(fileR2Key, bytes, {
      httpMetadata: {
        contentType: fileMime
      }
    });

    fileB64 = null;
  } else {
    fileB64 = base64FromBytes(bytes);
    fileR2Key = null;

    console.log("[certificates] UPLOAD storing in D1 (base64)", { fileSize });
  }

  await dbRun(
    env,
    `UPDATE certificates_items
     SET file_name = ?, file_mime = ?, file_size = ?, file_uploaded_at = datetime('now'),
         file_r2_key = ?, file_b64 = ?, updated_at = datetime('now'), updated_by = ?
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      fileName,
      fileMime,
      fileSize,
      fileR2Key,
      fileB64,
      authUser.user_id,
      existing.id,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CERT_FILE_UPLOAD", "certificates_items", String(existing.id), {
    id: existing.id,
    item_key: existing.item_key,
    file_name: fileName,
    file_mime: fileMime,
    file_size: fileSize,
    stored: hasR2 ? "r2" : "d1_base64"
  });

  console.log("[certificates] UPLOAD done", { id: existing.id, item_key: existing.item_key });
    const payload = { ok: true };
  if (isDebugEnabled(request)) payload.debug = { entryId: entryId };
  return jsonResponse(payload, 200, corsOkHeaders);
}


/* ===== CERTIFICATES: DOWNLOAD ENDPOINT PATCH ===== */

function sanitizeFilenameForHeader(name) {
  let s = String(name || "").trim();
  if (!s) s = "download.bin";
  s = s.replace(/[/\\]+/g, "_");
  s = s.replace(/[\x00-\x1F\x7F]/g, "_");
  s = s.replace(/\s+/g, " ").trim();
  if (s.length > 180) s = s.slice(0, 180);
  return s;
}

function contentDispositionHeader(filename, inline) {
  const safe = sanitizeFilenameForHeader(filename);
  const asciiFallback = safe.replace(/[^A-Za-z0-9._-]/g, "_") || "download.bin";
  const utf8 = encodeURIComponent(safe)
    .replace(/'/g, "%27")
    .replace(/\(/g, "%28")
    .replace(/\)/g, "%29")
    .replace(/\*/g, "%2A");

  return `${inline ? "inline" : "attachment"}; filename="${asciiFallback}"; filename*=UTF-8''${utf8}`;
}

async function handleCertificatesDownload(request, env, corsOkHeaders, authUser, idOrKey) {
  console.log("[certificates] DOWNLOAD start", { idOrKey: String(idOrKey), org_id: authUser.org_id, location_id: authUser.location_id });

  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDefaultCertificatesIfMissing(env, authUser);

  const existing = await getCertificateItemByIdOrKey(env, authUser, idOrKey);
  if (!existing) {
    console.log("[certificates] DOWNLOAD not found item", { idOrKey: String(idOrKey) });
    return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
  }

  const hasFile = !!(existing.file_r2_key || existing.file_b64);
  if (!hasFile) {
    return jsonResponse({ ok: false, error: "No file uploaded" }, 404, corsOkHeaders);
  }

  const url = new URL(request.url);
  const inline = url.searchParams.get("inline") === "1";

  const fileName = existing.file_name || `${existing.item_key || "certificate"}.bin`;
  const fileMime = (existing.file_mime || "application/octet-stream").trim() || "application/octet-stream";

  const headers = {
    ...corsOkHeaders,
    "Content-Type": fileMime,
    "Content-Disposition": contentDispositionHeader(fileName, inline),
    "Cache-Control": "no-store",
    "X-Content-Type-Options": "nosniff",
    "Access-Control-Expose-Headers": "Content-Disposition, Content-Type, Content-Length"
  };

  // Prefer R2
  if (existing.file_r2_key && env.CERTS_R2) {
    const obj = await env.CERTS_R2.get(existing.file_r2_key);
    if (!obj) {
      console.log("[certificates] DOWNLOAD missing R2 object", { key: existing.file_r2_key });
      return jsonResponse({ ok: false, error: "File missing" }, 404, corsOkHeaders);
    }
    return new Response(obj.body, { status: 200, headers });
  }

  // Fallback to D1 base64
  if (existing.file_b64) {
    let bytes;
    try {
      bytes = bytesFromBase64(String(existing.file_b64 || "").trim());
    } catch (e) {
      console.log("[certificates] DOWNLOAD base64 decode failed", e && (e.stack || e.message || String(e)));
      return jsonResponse({ ok: false, error: "Corrupt stored file" }, 500, corsOkHeaders);
    }

    headers["Content-Length"] = String(bytes.length);
    return new Response(bytes, { status: 200, headers });
  }

  return jsonResponse({ ok: false, error: "File missing" }, 404, corsOkHeaders);
}

/* =========================
   UI FILE SERVING (/ui/*)
   ========================= */

function contentTypeForPath(pathname) {
  const p = String(pathname || "").toLowerCase();
  if (p.endsWith(".css")) return "text/css; charset=utf-8";
  if (p.endsWith(".js")) return "application/javascript; charset=utf-8";
  if (p.endsWith(".html")) return "text/html; charset=utf-8";
  if (p.endsWith(".json")) return "application/json; charset=utf-8";
  if (p.endsWith(".svg")) return "image/svg+xml";
  if (p.endsWith(".png")) return "image/png";
  if (p.endsWith(".jpg") || p.endsWith(".jpeg")) return "image/jpeg";
  if (p.endsWith(".webp")) return "image/webp";
  if (p.endsWith(".txt")) return "text/plain; charset=utf-8";
  return "application/octet-stream";
}

function buildGithubRawUrl(env, uiPath) {
  const owner = (env.UI_GITHUB_OWNER || "").trim() || "johnagius";
  const repo = (env.UI_GITHUB_REPO || "").trim() || "eikon-ui";
  const branch = (env.UI_GITHUB_BRANCH || "").trim() || "main";
  const dir = (env.UI_GITHUB_DIR || "").trim() || "ui";

  const safe = uiPath.replace(/^\/+/, "").replace(/\.\.+/g, ".");
  return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${dir}/${safe}`;
}

function sanitizeJsSourceText(s) {
  return String(s || "")
    .replace(/\uFEFF/g, "")
    .replace(/\u0000/g, "")
    .replace(/\u2028/g, "\n")
    .replace(/\u2029/g, "\n");
}

async function handleUiAsset(request, env, url) {
  const p = url.pathname;
  const rel = p.replace(/^\/ui\/?/, "");
  if (!rel || rel.endsWith("/")) {
    return new Response("Not found", { status: 404, headers: { "Content-Type": "text/plain; charset=utf-8" } });
  }

  const cacheSeconds = parseInt((env.UI_CACHE_SECONDS || "300").trim(), 10);
  const ct = contentTypeForPath(rel);

  const cache = caches.default;

  const cachingEnabled = Number.isFinite(cacheSeconds) && cacheSeconds > 0;

  if (cachingEnabled) {
    const cached = await cache.match(request);
    if (cached) return cached;
  }

  const ghUrl = buildGithubRawUrl(env, rel);
  const ghRes = await fetch(ghUrl, {
    method: "GET",
    headers: {
      "User-Agent": "eikon-worker-ui-proxy",
      "Cache-Control": "no-cache"
    }
  });

  if (!ghRes.ok) {
    return new Response("Not found", {
      status: 404,
      headers: { "Content-Type": "text/plain; charset=utf-8" }
    });
  }

  let body = await ghRes.arrayBuffer();

  // Patch: sanitize problematic Unicode that can cause "Invalid or unexpected token"
  if (rel.toLowerCase().endsWith(".js")) {
    try {
      const dec = new TextDecoder("utf-8");
      const txt = dec.decode(body);
      const clean = sanitizeJsSourceText(txt);
      if (clean !== txt) {
        body = new TextEncoder().encode(clean).buffer;
      }
    } catch (e) {
      // serve original bytes if sanitize fails
    }
  }

  const headers = new Headers();
  headers.set("Content-Type", ct);
  headers.set("Cache-Control", cachingEnabled ? `public, max-age=${cacheSeconds}` : "no-store");
  headers.set("X-Source", "github-raw");
  headers.set("Access-Control-Allow-Origin", "*");

  const out = new Response(body, { status: 200, headers });

  if (cachingEnabled) {
    await cache.put(request, out.clone());
  }

  return out;
}


// ------------------------------------------------------------
// POCT (Point of Care Testing) — Cloud state sync (D1)
// Endpoints:
//   GET  /poct/state  -> { ok:true, state:{records:[], patients:[]} }
//   PUT  /poct/state  -> replace/upsert state for org+location
// ------------------------------------------------------------

async function ensurePoctSchema(env) {
  // Safe even if you already created the tables manually.
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS poct_patients (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      patient_id TEXT NOT NULL,
      name TEXT NOT NULL DEFAULT '',
      phone TEXT NOT NULL DEFAULT '',
      age REAL,
      address TEXT NOT NULL DEFAULT '',
      created_at_iso TEXT NOT NULL DEFAULT '',
      updated_at_iso TEXT NOT NULL DEFAULT '',
      last_seen_iso TEXT NOT NULL DEFAULT '',
      conflicts_json TEXT NOT NULL DEFAULT '[]',
      patient_json TEXT NOT NULL,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now')),
      created_by INTEGER,
      updated_by INTEGER,
      UNIQUE(org_id, location_id, patient_id)
    )`
  );

  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS poct_records (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      record_id TEXT NOT NULL,
      test_type TEXT NOT NULL,
      test_label TEXT NOT NULL DEFAULT '',
      performed_at_iso TEXT NOT NULL,
      performed_at_local TEXT NOT NULL DEFAULT '',
      patient_id TEXT NOT NULL DEFAULT '',
      patient_name TEXT NOT NULL DEFAULT '',
      patient_phone TEXT NOT NULL DEFAULT '',
      patient_age REAL,
      patient_address TEXT NOT NULL DEFAULT '',
      fee_due REAL NOT NULL DEFAULT 0,
      notes TEXT NOT NULL DEFAULT '',
      intervention TEXT NOT NULL DEFAULT '',
      bp_sys REAL,
      bp_dia REAL,
      bp_pulse REAL,
      bp_arm TEXT,
      bp_position TEXT,
      urine_leu TEXT,
      urine_nit TEXT,
      urine_uro TEXT,
      urine_pro TEXT,
      urine_ph TEXT,
      urine_bld TEXT,
      urine_ket TEXT,
      urine_glu TEXT,
      urine_appearance TEXT,
      hba1c_pct REAL,
      hba1c_mmol REAL,
      bg_glucose REAL,
      bg_timing TEXT,
      chol_tc REAL,
      chol_hdl REAL,
      chol_ldl REAL,
      chol_tg REAL,
      chol_ratio REAL,
      chol_fasting TEXT,
      bmi_weight REAL,
      bmi_height REAL,
      bmi_bmi REAL,
      bmi_category TEXT,
      bmi_waist REAL,
      results_json TEXT NOT NULL DEFAULT '{}',
      record_json TEXT NOT NULL,
      updated_at_iso TEXT NOT NULL DEFAULT '',
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now')),
      created_by INTEGER,
      updated_by INTEGER,
      UNIQUE(org_id, location_id, record_id)
    )`
  );

  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_poct_records_org_loc_dt ON poct_records(org_id, location_id, performed_at_iso)`);
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_poct_records_org_loc_type_dt ON poct_records(org_id, location_id, test_type, performed_at_iso)`);
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_poct_records_org_loc_patient ON poct_records(org_id, location_id, patient_id)`);
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_poct_records_org_loc_phone ON poct_records(org_id, location_id, patient_phone)`);

  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_poct_patients_org_loc_lastseen ON poct_patients(org_id, location_id, last_seen_iso)`);
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_poct_patients_org_loc_name ON poct_patients(org_id, location_id, name)`);
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_poct_patients_org_loc_phone ON poct_patients(org_id, location_id, phone)`);
}

function poctText(v, maxLen = 4000) {
  let s = String(v == null ? "" : v).trim();
  if (s.length > maxLen) s = s.slice(0, maxLen);
  return s;
}
function poctNumOrNull(v) {
  if (v == null) return null;
  if (typeof v === "number") return Number.isFinite(v) ? v : null;
  const s = String(v).trim();
  if (!s) return null;
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}
function poctJsonString(v, fallback) {
  try {
    return JSON.stringify(v == null ? fallback : v);
  } catch (e) {
    return JSON.stringify(fallback);
  }
}

function poctExtractRecordColumns(rec) {
  const r = rec && typeof rec === "object" ? rec : {};
  const p = r.patient && typeof r.patient === "object" ? r.patient : {};
  const res = r.results && typeof r.results === "object" ? r.results : {};

  const testType = poctText(r.testType, 30);
  const out = {
    record_id: poctText(r.id, 120),
    test_type: testType || "unknown",
    test_label: poctText(r.testLabel, 80),
    performed_at_iso: poctText(r.performedAtIso, 60),
    performed_at_local: poctText(r.performedAtLocal, 60),

    patient_id: poctText(p.patientId, 120),
    patient_name: poctText(p.name, 200),
    patient_phone: poctText(p.phone, 80),
    patient_age: poctNumOrNull(p.age),
    patient_address: poctText(p.address, 500),

    fee_due: poctNumOrNull(r.feeDue) || 0,
    notes: poctText(r.notes, 2000),
    intervention: poctText(r.intervention, 2000),

    bp_sys: null,
    bp_dia: null,
    bp_pulse: null,
    bp_arm: null,
    bp_position: null,

    urine_leu: null,
    urine_nit: null,
    urine_uro: null,
    urine_pro: null,
    urine_ph: null,
    urine_bld: null,
    urine_ket: null,
    urine_glu: null,
    urine_appearance: null,

    hba1c_pct: null,
    hba1c_mmol: null,

    bg_glucose: null,
    bg_timing: null,

    chol_tc: null,
    chol_hdl: null,
    chol_ldl: null,
    chol_tg: null,
    chol_ratio: null,
    chol_fasting: null,

    bmi_weight: null,
    bmi_height: null,
    bmi_bmi: null,
    bmi_category: null,
    bmi_waist: null,

    results_json: poctJsonString(res, {}),
    record_json: poctJsonString(r, {}),
    updated_at_iso: poctText(r.updatedAtIso, 60) || nowIso() };

  // Map typed result fields (best-effort; record_json remains source-of-truth).
  if (testType === "bp") {
    out.bp_sys = poctNumOrNull(res.sys);
    out.bp_dia = poctNumOrNull(res.dia);
    out.bp_pulse = poctNumOrNull(res.pulse);
    out.bp_arm = poctText(res.arm, 40) || null;
    out.bp_position = poctText(res.position, 40) || null;
  } else if (testType === "urine") {
    out.urine_leu = poctText(res.leu, 60) || null;
    out.urine_nit = poctText(res.nit, 60) || null;
    out.urine_uro = poctText(res.uro, 60) || null;
    out.urine_pro = poctText(res.pro, 60) || null;
    out.urine_ph = poctText(res.ph, 60) || null;
    out.urine_bld = poctText(res.bld, 60) || null;
    out.urine_ket = poctText(res.ket, 60) || null;
    out.urine_glu = poctText(res.glu, 60) || null;
    out.urine_appearance = poctText(res.appearance, 120) || null;
  } else if (testType === "hba1c") {
    out.hba1c_pct = poctNumOrNull(res.pct);
    out.hba1c_mmol = poctNumOrNull(res.mmol);
  } else if (testType === "bg") {
    out.bg_glucose = poctNumOrNull(res.glucose);
    out.bg_timing = poctText(res.timing, 40) || null;
  } else if (testType === "chol") {
    out.chol_tc = poctNumOrNull(res.tc);
    out.chol_hdl = poctNumOrNull(res.hdl);
    out.chol_ldl = poctNumOrNull(res.ldl);
    out.chol_tg = poctNumOrNull(res.tg);
    out.chol_ratio = poctNumOrNull(res.ratio);
    out.chol_fasting = poctText(res.fasting, 40) || null;
  } else if (testType === "bmi") {
    out.bmi_weight = poctNumOrNull(res.weight);
    out.bmi_height = poctNumOrNull(res.height);
    out.bmi_bmi = poctNumOrNull(res.bmi);
    out.bmi_category = poctText(res.category, 80) || null;
    out.bmi_waist = poctNumOrNull(res.waist);
  }

  return out;
}

function poctExtractPatientColumns(pat) {
  const p = pat && typeof pat === "object" ? pat : {};
  const pid = poctText(p.patientId, 120);
  const conflicts = Array.isArray(p.conflicts) ? p.conflicts : [];
  return {
    patient_id: pid,
    name: poctText(p.name, 200),
    phone: poctText(p.phone, 80),
    age: poctNumOrNull(p.age),
    address: poctText(p.address, 500),
    created_at_iso: poctText(p.createdAtIso, 60) || nowIso(),
    updated_at_iso: poctText(p.updatedAtIso, 60) || nowIso(),
    last_seen_iso: poctText(p.lastSeenIso, 60),
    conflicts_json: poctJsonString(conflicts, []),
    patient_json: poctJsonString(p, {}) };
}

function poctChunk(arr, size) {
  const out = [];
  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
  return out;
}

async function handlePoctStateGet(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensurePoctSchema(env);

  const orgId = authUser.org_id;
  const locId = authUser.location_id;

  const recRows = await dbAll(
    env,
    `SELECT record_json FROM poct_records
     WHERE org_id = ? AND location_id = ?
     ORDER BY performed_at_iso DESC, id DESC`,
    [orgId, locId]
  );

  const patRows = await dbAll(
    env,
    `SELECT patient_json FROM poct_patients
     WHERE org_id = ? AND location_id = ?
     ORDER BY name ASC, patient_id ASC`,
    [orgId, locId]
  );

  const records = [];
  for (let i = 0; i < recRows.length; i++) {
    const s = recRows[i] ? recRows[i].record_json : null;
    if (!s) continue;
    try {
      const v = JSON.parse(String(s));
      if (v && typeof v === "object") records.push(v);
    } catch (e) {}
  }

  const patients = [];
  for (let j = 0; j < patRows.length; j++) {
    const s2 = patRows[j] ? patRows[j].patient_json : null;
    if (!s2) continue;
    try {
      const v2 = JSON.parse(String(s2));
      if (v2 && typeof v2 === "object") patients.push(v2);
    } catch (e) {}
  }

  // compatibility with modules.poct.js cloudLoad()
  return jsonResponse({ ok: true, state: { records, patients }, records, patients }, 200, corsOkHeaders);
}

async function handlePoctStatePut(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensurePoctSchema(env);

  const body = await readJson(request);
  const st = body && (body.state || body.data) ? (body.state || body.data) : body;

  const recordsIn = st && (st.records || st.entries) ? (st.records || st.entries) : [];
  const patientsIn = st && st.patients ? st.patients : [];

  const records = Array.isArray(recordsIn) ? recordsIn : [];
  const patients = Array.isArray(patientsIn) ? patientsIn : [];

  const orgId = authUser.org_id;
  const locId = authUser.location_id;
  const userId = authUser.user_id;

  // Build sets of IDs (also filters out invalid items).
  const recIds = [];
  const recIdSet = new Set();
  const cleanedRecords = [];
  for (let i = 0; i < records.length; i++) {
    const r = records[i];
    const id = r && r.id ? String(r.id).trim() : "";
    if (!id) continue;
    if (!recIdSet.has(id)) {
      recIdSet.add(id);
      recIds.push(id);
    }
    cleanedRecords.push(r);
  }

  const patIds = [];
  const patIdSet = new Set();
  const cleanedPatients = [];
  for (let j = 0; j < patients.length; j++) {
    const p = patients[j];
    const id2 = p && p.patientId ? String(p.patientId).trim() : "";
    if (!id2) continue;
    if (!patIdSet.has(id2)) {
      patIdSet.add(id2);
      patIds.push(id2);
    }
    cleanedPatients.push(p);
  }

  // Apply as an authoritative replace (no explicit SQL transaction).
  // NOTE: Cloudflare may reject BEGIN/COMMIT in some contexts; we keep writes idempotent and safe.
  let counts = {
    patients_upserted: 0,
    records_upserted: 0,
    patients_deleted: 0,
    records_deleted: 0 };

  try {
// Upsert patients
    const upPatSql = `
      INSERT INTO poct_patients (
        org_id, location_id, patient_id, name, phone, age, address,
        created_at_iso, updated_at_iso, last_seen_iso, conflicts_json, patient_json,
        created_by, updated_by, updated_at
      ) VALUES (
        ?,?,?,?,?,?,?,?,?,?,?,?,?,?, datetime('now')
      )
      ON CONFLICT(org_id, location_id, patient_id) DO UPDATE SET
        name = excluded.name,
        phone = excluded.phone,
        age = excluded.age,
        address = excluded.address,
        created_at_iso = CASE WHEN poct_patients.created_at_iso = '' THEN excluded.created_at_iso ELSE poct_patients.created_at_iso END,
        updated_at_iso = excluded.updated_at_iso,
        last_seen_iso = excluded.last_seen_iso,
        conflicts_json = excluded.conflicts_json,
        patient_json = excluded.patient_json,
        updated_by = excluded.updated_by,
        updated_at = datetime('now')
    `;
    const upPat = env.DB.prepare(upPatSql);

    for (let i = 0; i < cleanedPatients.length; i++) {
      const cols = poctExtractPatientColumns(cleanedPatients[i]);
      if (!cols.patient_id) continue;
      await upPat
        .bind(
          orgId,
          locId,
          cols.patient_id,
          cols.name,
          cols.phone,
          cols.age,
          cols.address,
          cols.created_at_iso,
          cols.updated_at_iso,
          cols.last_seen_iso,
          cols.conflicts_json,
          cols.patient_json,
          userId,
          userId
        )
        .run();
      counts.patients_upserted++;
    }

    // Upsert records
    const upRecSql = `
      INSERT INTO poct_records (
        org_id, location_id, record_id, test_type, test_label, performed_at_iso, performed_at_local,
        patient_id, patient_name, patient_phone, patient_age, patient_address,
        fee_due, notes, intervention,
        bp_sys, bp_dia, bp_pulse, bp_arm, bp_position,
        urine_leu, urine_nit, urine_uro, urine_pro, urine_ph, urine_bld, urine_ket, urine_glu, urine_appearance,
        hba1c_pct, hba1c_mmol,
        bg_glucose, bg_timing,
        chol_tc, chol_hdl, chol_ldl, chol_tg, chol_ratio, chol_fasting,
        bmi_weight, bmi_height, bmi_bmi, bmi_category, bmi_waist,
        results_json, record_json, updated_at_iso,
        created_by, updated_by
      ) VALUES (
        ?,?,?,?,?,?,?,?,
        ?,?,?,?,
        ?,?,?,
        ?,?,?,?,?,
        ?,?,?,?,?,?,?,?,?,
        ?,?,
        ?,?,
        ?,?,?,?,?,?,
        ?,?,?,?,?,
        ?,?,?,
        ?,?
      )
      ON CONFLICT(org_id, location_id, record_id) DO UPDATE SET
        test_type=excluded.test_type,
        test_label=excluded.test_label,
        performed_at_iso=excluded.performed_at_iso,
        performed_at_local=excluded.performed_at_local,
        patient_id=excluded.patient_id,
        patient_name=excluded.patient_name,
        patient_phone=excluded.patient_phone,
        patient_age=excluded.patient_age,
        patient_address=excluded.patient_address,
        fee_due=excluded.fee_due,
        notes=excluded.notes,
        intervention=excluded.intervention,
        bp_sys=excluded.bp_sys,
        bp_dia=excluded.bp_dia,
        bp_pulse=excluded.bp_pulse,
        bp_arm=excluded.bp_arm,
        bp_position=excluded.bp_position,
        urine_leu=excluded.urine_leu,
        urine_nit=excluded.urine_nit,
        urine_uro=excluded.urine_uro,
        urine_pro=excluded.urine_pro,
        urine_ph=excluded.urine_ph,
        urine_bld=excluded.urine_bld,
        urine_ket=excluded.urine_ket,
        urine_glu=excluded.urine_glu,
        urine_appearance=excluded.urine_appearance,
        hba1c_pct=excluded.hba1c_pct,
        hba1c_mmol=excluded.hba1c_mmol,
        bg_glucose=excluded.bg_glucose,
        bg_timing=excluded.bg_timing,
        chol_tc=excluded.chol_tc,
        chol_hdl=excluded.chol_hdl,
        chol_ldl=excluded.chol_ldl,
        chol_tg=excluded.chol_tg,
        chol_ratio=excluded.chol_ratio,
        chol_fasting=excluded.chol_fasting,
        bmi_weight=excluded.bmi_weight,
        bmi_height=excluded.bmi_height,
        bmi_bmi=excluded.bmi_bmi,
        bmi_category=excluded.bmi_category,
        bmi_waist=excluded.bmi_waist,
        results_json=excluded.results_json,
        record_json=excluded.record_json,
        updated_at_iso=excluded.updated_at_iso,
        updated_by=excluded.updated_by,
        updated_at=datetime('now')
    `;
    const upRec = env.DB.prepare(upRecSql);

    for (let k = 0; k < cleanedRecords.length; k++) {
      const cols = poctExtractRecordColumns(cleanedRecords[k]);
      if (!cols.record_id) continue;
      // performed_at_iso is required in schema; best-effort fallback
      if (!cols.performed_at_iso) cols.performed_at_iso = nowIso();

      await upRec
        .bind(
          orgId,
          locId,
          cols.record_id,
          cols.test_type,
          cols.test_label,
          cols.performed_at_iso,
          cols.performed_at_local,

          cols.patient_id,
          cols.patient_name,
          cols.patient_phone,
          cols.patient_age,
          cols.patient_address,

          cols.fee_due,
          cols.notes,
          cols.intervention,

          cols.bp_sys,
          cols.bp_dia,
          cols.bp_pulse,
          cols.bp_arm,
          cols.bp_position,

          cols.urine_leu,
          cols.urine_nit,
          cols.urine_uro,
          cols.urine_pro,
          cols.urine_ph,
          cols.urine_bld,
          cols.urine_ket,
          cols.urine_glu,
          cols.urine_appearance,

          cols.hba1c_pct,
          cols.hba1c_mmol,

          cols.bg_glucose,
          cols.bg_timing,

          cols.chol_tc,
          cols.chol_hdl,
          cols.chol_ldl,
          cols.chol_tg,
          cols.chol_ratio,
          cols.chol_fasting,

          cols.bmi_weight,
          cols.bmi_height,
          cols.bmi_bmi,
          cols.bmi_category,
          cols.bmi_waist,

          cols.results_json,
          cols.record_json,
          cols.updated_at_iso,

          userId,
          userId
        )
        .run();

      counts.records_upserted++;
    }

    // Delete records that no longer exist (authoritative replace)
    const existingRec = await dbAll(
      env,
      `SELECT record_id AS id FROM poct_records WHERE org_id = ? AND location_id = ?`,
      [orgId, locId]
    );
    const toDeleteRec = [];
    for (let i = 0; i < existingRec.length; i++) {
      const id = existingRec[i] ? String(existingRec[i].id || "") : "";
      if (!id) continue;
      if (!recIdSet.has(id)) toDeleteRec.push(id);
    }
    const recChunks = poctChunk(toDeleteRec, 800);
    for (let c = 0; c < recChunks.length; c++) {
      const chunk = recChunks[c];
      if (!chunk.length) continue;
      const qs = chunk.map(() => "?").join(",");
      await dbRun(
        env,
        `DELETE FROM poct_records WHERE org_id = ? AND location_id = ? AND record_id IN (${qs})`,
        [orgId, locId, ...chunk]
      );
      counts.records_deleted += chunk.length;
    }

    // Delete patients that no longer exist
    const existingPat = await dbAll(
      env,
      `SELECT patient_id AS id FROM poct_patients WHERE org_id = ? AND location_id = ?`,
      [orgId, locId]
    );
    const toDeletePat = [];
    for (let j2 = 0; j2 < existingPat.length; j2++) {
      const id2 = existingPat[j2] ? String(existingPat[j2].id || "") : "";
      if (!id2) continue;
      if (!patIdSet.has(id2)) toDeletePat.push(id2);
    }
    const patChunks = poctChunk(toDeletePat, 800);
    for (let d = 0; d < patChunks.length; d++) {
      const chunk2 = patChunks[d];
      if (!chunk2.length) continue;
      const qs2 = chunk2.map(() => "?").join(",");
      await dbRun(
        env,
        `DELETE FROM poct_patients WHERE org_id = ? AND location_id = ? AND patient_id IN (${qs2})`,
        [orgId, locId, ...chunk2]
      );
      counts.patients_deleted += chunk2.length;
    }
  } catch (e) {
    // Best-effort failure response; partial progress is possible but safe (upserts happen before deletes).
    throw e;
  }

  return jsonResponse({ ok: true, ...counts }, 200, corsOkHeaders);
}


async function handleInstructionsGlobalGet(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const row = await dbFirst(
    env,
    `SELECT data_json, created_at, created_by, updated_at, updated_by
     FROM instructions_global
     WHERE org_id = ? AND location_id = ?`,
    [authUser.org_id, authUser.location_id]
  );

  if (!row) {
    return jsonResponse({ ok: true, global: null }, 200, corsOkHeaders);
  }

  let data = null;
  try { data = JSON.parse(String(row.data_json || "null")); } catch (e) { data = null; }

  return jsonResponse({
    ok: true,
    global: (data && typeof data === "object") ? data : null,
    meta: {
      created_at: String(row.created_at || ""),
      created_by: row.created_by || null,
      updated_at: String(row.updated_at || ""),
      updated_by: row.updated_by || null
    }
  }, 200, corsOkHeaders);
}

async function handleInstructionsGlobalPut(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const body = await readJson(request);
  const global = (body && (body.global || body.data)) || null;

  if (!global || typeof global !== "object") {
    return jsonResponse({ ok: false, error: "Missing/invalid global payload" }, 400, corsOkHeaders);
  }

  const now = nowIso();
  const dataJson = JSON.stringify(global);

  await env.DB.prepare(
    `INSERT INTO instructions_global
       (org_id, location_id, data_json, created_at, created_by, updated_at, updated_by)
     VALUES (?, ?, ?, ?, ?, ?, ?)
     ON CONFLICT(org_id, location_id) DO UPDATE SET
       data_json = excluded.data_json,
       updated_at = excluded.updated_at,
       updated_by = excluded.updated_by`
  ).bind(
    authUser.org_id,
    authUser.location_id,
    dataJson,
    now,
    authUser.user_id,
    now,
    authUser.user_id
  ).run();

  return jsonResponse({ ok: true, updated_at: now }, 200, corsOkHeaders);
}

function parseHandoverJson(s) {
  try {
    const v = JSON.parse(String(s || "[]"));
    return Array.isArray(v) ? v : [];
  } catch (e) {
    return [];
  }
}

async function handleInstructionsDailyGetOrList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const ymd = String(url.searchParams.get("ymd") || "").trim();
  const month = String(url.searchParams.get("month") || "").trim();

  if (ymd) {
    if (!isValidYmd(ymd)) return jsonResponse({ ok: false, error: "Invalid ymd (YYYY-MM-DD)" }, 400, corsOkHeaders);

    const row = await dbFirst(
      env,
      `SELECT ymd, notes, handover_json, created_at, created_by, updated_at, updated_by
       FROM instructions_daily
       WHERE org_id = ? AND location_id = ? AND ymd = ?`,
      [authUser.org_id, authUser.location_id, ymd]
    );

    if (!row) {
      return jsonResponse({ ok: true, record: null }, 200, corsOkHeaders);
    }

    return jsonResponse({
      ok: true,
      record: {
        ymd: String(row.ymd),
        notes: String(row.notes || ""),
        handover_out: parseHandoverJson(row.handover_json),
        created_at: String(row.created_at || ""),
        created_by: row.created_by || null,
        updated_at: String(row.updated_at || ""),
        updated_by: row.updated_by || null
      }
    }, 200, corsOkHeaders);
  }

  // Month list
  if (!month || !isValidYm(month)) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const rows = await dbAll(
    env,
    `SELECT ymd, notes, handover_json, updated_at, updated_by
     FROM instructions_daily
     WHERE org_id = ?
       AND location_id = ?
       AND ymd >= ?
       AND ymd < ?
     ORDER BY ymd ASC`,
    [authUser.org_id, authUser.location_id, range.startStr, range.endStr]
  );

  const records = (rows || []).map(r => ({
    ymd: String(r.ymd),
    notes: String(r.notes || ""),
    handover_out: parseHandoverJson(r.handover_json),
    updated_at: String(r.updated_at || ""),
    updated_by: r.updated_by || null
  }));

  return jsonResponse({ ok: true, records }, 200, corsOkHeaders);
}

async function handleInstructionsDailyPut(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const body = await readJson(request);

  const ymd = String(body.ymd || "").trim();
  if (!isValidYmd(ymd)) return jsonResponse({ ok: false, error: "Invalid ymd (YYYY-MM-DD)" }, 400, corsOkHeaders);

  const notes = String(body.notes || "");
  const handover = Array.isArray(body.handover_out) ? body.handover_out : [];
  const handoverJson = JSON.stringify(handover);

  const now = nowIso();

  // If cleared, delete the day row to keep month lists clean
  if ((notes || "").trim() === "" && (!handover || handover.length === 0)) {
    await env.DB.prepare(
      `DELETE FROM instructions_daily
       WHERE org_id = ? AND location_id = ? AND ymd = ?`
    ).bind(authUser.org_id, authUser.location_id, ymd).run();

    return jsonResponse({ ok: true, deleted: true, updated_at: now }, 200, corsOkHeaders);
  }

  await env.DB.prepare(
    `INSERT INTO instructions_daily
       (org_id, location_id, ymd, notes, handover_json, created_at, created_by, updated_at, updated_by)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
     ON CONFLICT(org_id, location_id, ymd) DO UPDATE SET
       notes = excluded.notes,
       handover_json = excluded.handover_json,
       updated_at = excluded.updated_at,
       updated_by = excluded.updated_by`
  ).bind(
    authUser.org_id,
    authUser.location_id,
    ymd,
    notes,
    handoverJson,
    now,
    authUser.user_id,
    now,
    authUser.user_id
  ).run();

  return jsonResponse({ ok: true, updated_at: now }, 200, corsOkHeaders);
}






// ============================================================
// Scarce Stock
// ============================================================
async function ensureScarceStockSchema(env) {
  await dbRun(env, `CREATE TABLE IF NOT EXISTS scarce_stock_offers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    org_id INTEGER NOT NULL,
    location_id INTEGER NOT NULL,
    entry_date TEXT NOT NULL,
    item_name TEXT NOT NULL,
    description TEXT NOT NULL DEFAULT '',
    batch TEXT NOT NULL DEFAULT '',
    expiry_date TEXT,
    quantity_available INTEGER NOT NULL DEFAULT 0,
    is_closed INTEGER NOT NULL DEFAULT 0,
    created_by INTEGER,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_by INTEGER
  )`, []);

  await dbRun(env, `CREATE TABLE IF NOT EXISTS scarce_stock_offer_requests (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    offer_id INTEGER NOT NULL,
    requester_org_id INTEGER NOT NULL,
    requester_location_id INTEGER NOT NULL,
    quantity_requested INTEGER NOT NULL DEFAULT 0,
    note TEXT NOT NULL DEFAULT '',
    created_by INTEGER,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_by INTEGER
  )`, []);

  await dbRun(env, `CREATE TABLE IF NOT EXISTS scarce_stock_needs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    org_id INTEGER NOT NULL,
    location_id INTEGER NOT NULL,
    entry_date TEXT NOT NULL,
    item_name TEXT NOT NULL,
    description TEXT NOT NULL DEFAULT '',
    needed_by TEXT,
    quantity_needed INTEGER NOT NULL DEFAULT 0,
    is_closed INTEGER NOT NULL DEFAULT 0,
    created_by INTEGER,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_by INTEGER
  )`, []);

  await dbRun(env, `CREATE TABLE IF NOT EXISTS scarce_stock_need_offers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    need_id INTEGER NOT NULL,
    offerer_org_id INTEGER NOT NULL,
    offerer_location_id INTEGER NOT NULL,
    quantity_offered INTEGER NOT NULL DEFAULT 0,
    note TEXT NOT NULL DEFAULT '',
    created_by INTEGER,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_by INTEGER
  )`, []);

  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_ss_offers_org_loc_date ON scarce_stock_offers (org_id, location_id, entry_date)", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_ss_offers_item ON scarce_stock_offers (item_name)", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_ss_offer_requests_offer ON scarce_stock_offer_requests (offer_id)", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_ss_offer_requests_req_loc ON scarce_stock_offer_requests (requester_org_id, requester_location_id)", []);

  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_ss_needs_org_loc_date ON scarce_stock_needs (org_id, location_id, entry_date)", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_ss_needs_item ON scarce_stock_needs (item_name)", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_ss_need_offers_need ON scarce_stock_need_offers (need_id)", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_ss_need_offers_offer_loc ON scarce_stock_need_offers (offerer_org_id, offerer_location_id)", []);
}

function ssIntNonNeg(v) {
  const n = Number(v);
  if (!Number.isFinite(n)) return null;
  const i = Math.floor(n);
  return i < 0 ? null : i;
}
function ssText(v, max) {
  let s = String(v ?? "").trim();
  if (max && s.length > max) s = s.slice(0, max);
  return s;
}
function ssBool01(v) { return (v === 1 || v === "1" || v === true) ? 1 : 0; }

function ssCanSeeSensitive(authUser, aOrg, aLoc, bOrg, bLoc) {
  const uOrg = authUser.org_id, uLoc = authUser.location_id;
  const isA = (uOrg === aOrg && uLoc === aLoc);
  const isB = (uOrg === bOrg && uLoc === bLoc);
  return isA || isB;
}

// ----- Offers list
async function handleScarceOffersList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const offersBase = await dbAll(env, `
    SELECT
      o.id, o.org_id, o.location_id, o.entry_date, o.item_name, o.description, o.batch, o.expiry_date,
      o.quantity_available, o.is_closed,
      org.name AS org_name,
      loc.name AS location_name,
      COALESCE(SUM(r.quantity_requested), 0) AS total_requested
    FROM scarce_stock_offers o
    JOIN orgs org ON org.id = o.org_id
    JOIN locations loc ON loc.id = o.location_id
    LEFT JOIN scarce_stock_offer_requests r ON r.offer_id = o.id
    GROUP BY o.id
    ORDER BY o.is_closed ASC, o.entry_date DESC, o.id DESC
  `, []);

  const offerIds = offersBase.map(x => Number(x.id)).filter(n => Number.isFinite(n) && n > 0);
  let reqRows = [];
  if (offerIds.length) {
    const qs = offerIds.map(() => "?").join(",");
    reqRows = await dbAll(env, `
      SELECT
        r.id, r.offer_id, r.requester_org_id, r.requester_location_id, r.quantity_requested, r.note,
        org.name AS requester_org_name,
        loc.name AS requester_location_name
      FROM scarce_stock_offer_requests r
      JOIN orgs org ON org.id = r.requester_org_id
      JOIN locations loc ON loc.id = r.requester_location_id
      WHERE r.offer_id IN (${qs})
      ORDER BY r.created_at ASC, r.id ASC
    `, offerIds);
  }

  const reqByOffer = new Map();
  for (const rr of reqRows) {
    const oid = Number(rr.offer_id);
    if (!reqByOffer.has(oid)) reqByOffer.set(oid, []);
    reqByOffer.get(oid).push(rr);
  }

  const offers = [];
  for (const o of offersBase) {
    const mineOwner = (authUser.org_id === o.org_id && authUser.location_id === o.location_id);
    const requestsIn = reqByOffer.get(Number(o.id)) || [];
    const requestsOut = [];

    for (const rr of requestsIn) {
      const canSee = ssCanSeeSensitive(
        authUser,
        Number(o.org_id), Number(o.location_id),
        Number(rr.requester_org_id), Number(rr.requester_location_id)
      );
      const mine = (authUser.org_id === rr.requester_org_id && authUser.location_id === rr.requester_location_id);

      requestsOut.push({
        id: rr.id,
        offer_id: rr.offer_id,
        quantity_requested: Number(rr.quantity_requested || 0),
        is_private: canSee ? 0 : 1,
        requester_display: canSee ? ((rr.requester_org_name || "") + " — " + (rr.requester_location_name || "")) : "",
        note: canSee ? (rr.note || "") : "",
        mine: mine ? 1 : 0
      });
    }

    offers.push({
      id: o.id,
      org_id: o.org_id,
      org_name: o.org_name || "",
      location_id: o.location_id,
      location_name: o.location_name || "",
      entry_date: o.entry_date,
      item_name: o.item_name,
      description: o.description || "",
      batch: o.batch || "",
      expiry_date: o.expiry_date || null,
      quantity_available: Number(o.quantity_available || 0),
      is_closed: Number(o.is_closed || 0),
      total_requested: Number(o.total_requested || 0),
      remaining_quantity: Number(o.quantity_available || 0) - Number(o.total_requested || 0),
      mine_owner: mineOwner ? 1 : 0,
      requests: requestsOut
    });
  }

  return jsonResponse({ ok: true, offers }, 200, corsOkHeaders);
}

// ----- Offers create/update/delete
async function handleScarceOfferCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const body = await readJson(request);
  const entry_date = ssText(body.entry_date, 40);
  const item_name = ssText(body.item_name, 220);
  const description = ssText(body.description, 2000);
  const batch = ssText(body.batch, 120);
  const expiry_date = ssText(body.expiry_date, 40);
  const qty = ssIntNonNeg(body.quantity_available);
  const is_closed = ssBool01(body.is_closed);

  if (!isValidYmd(entry_date)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!item_name) return jsonResponse({ ok: false, error: "Missing item_name" }, 400, corsOkHeaders);
  if (expiry_date && !isValidYmd(expiry_date)) return jsonResponse({ ok: false, error: "Invalid expiry_date (YYYY-MM-DD or empty)" }, 400, corsOkHeaders);
  if (qty === null) return jsonResponse({ ok: false, error: "Invalid quantity_available (>= 0)" }, 400, corsOkHeaders);

  const res = await dbRun(env, `
    INSERT INTO scarce_stock_offers
      (org_id, location_id, entry_date, item_name, description, batch, expiry_date, quantity_available, is_closed, created_by, created_at, updated_at, updated_by)
    VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'), ?)
  `, [
    authUser.org_id, authUser.location_id,
    entry_date, item_name, description, batch,
    expiry_date || null,
    qty, is_closed ? 1 : 0,
    authUser.user_id, authUser.user_id
  ]);

  const insertedId = res?.meta?.last_row_id || null;
  await writeAudit(env, authUser.org_id, authUser.user_id, "SCARCE_OFFER_CREATE", "scarce_stock_offers", String(insertedId || ""), { item_name, quantity_available: qty });
  return jsonResponse({ ok: true, id: insertedId }, 200, corsOkHeaders);
}

async function handleScarceOfferUpdate(request, env, corsOkHeaders, authUser, offerId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const id = Number(offerId);
  if (!Number.isFinite(id) || id <= 0) return jsonResponse({ ok: false, error: "Invalid offer id" }, 400, corsOkHeaders);

  const existing = await dbFirst(env, `SELECT id, org_id, location_id FROM scarce_stock_offers WHERE id = ?`, [id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  if (!(existing.org_id === authUser.org_id && existing.location_id === authUser.location_id)) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const body = await readJson(request);
  const entry_date = ssText(body.entry_date, 40);
  const item_name = ssText(body.item_name, 220);
  const description = ssText(body.description, 2000);
  const batch = ssText(body.batch, 120);
  const expiry_date = ssText(body.expiry_date, 40);
  const qty = ssIntNonNeg(body.quantity_available);
  const is_closed = ssBool01(body.is_closed);

  if (!isValidYmd(entry_date)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!item_name) return jsonResponse({ ok: false, error: "Missing item_name" }, 400, corsOkHeaders);
  if (expiry_date && !isValidYmd(expiry_date)) return jsonResponse({ ok: false, error: "Invalid expiry_date (YYYY-MM-DD or empty)" }, 400, corsOkHeaders);
  if (qty === null) return jsonResponse({ ok: false, error: "Invalid quantity_available (>= 0)" }, 400, corsOkHeaders);

  await dbRun(env, `
    UPDATE scarce_stock_offers
    SET entry_date = ?, item_name = ?, description = ?, batch = ?, expiry_date = ?, quantity_available = ?, is_closed = ?,
        updated_at = datetime('now'), updated_by = ?
    WHERE id = ?
  `, [
    entry_date, item_name, description, batch, (expiry_date || null), qty, (is_closed ? 1 : 0),
    authUser.user_id, id
  ]);

  await writeAudit(env, authUser.org_id, authUser.user_id, "SCARCE_OFFER_UPDATE", "scarce_stock_offers", String(id), { item_name, quantity_available: qty, is_closed: is_closed ? 1 : 0 });
  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleScarceOfferDelete(request, env, corsOkHeaders, authUser, offerId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const id = Number(offerId);
  if (!Number.isFinite(id) || id <= 0) return jsonResponse({ ok: false, error: "Invalid offer id" }, 400, corsOkHeaders);

  const existing = await dbFirst(env, `SELECT id, org_id, location_id, item_name FROM scarce_stock_offers WHERE id = ?`, [id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  if (!(existing.org_id === authUser.org_id && existing.location_id === authUser.location_id)) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await dbRun(env, `DELETE FROM scarce_stock_offer_requests WHERE offer_id = ?`, [id]);
  await dbRun(env, `DELETE FROM scarce_stock_offers WHERE id = ?`, [id]);

  await writeAudit(env, authUser.org_id, authUser.user_id, "SCARCE_OFFER_DELETE", "scarce_stock_offers", String(id), { item_name: existing.item_name || "" });
  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

// ----- Offer requests (create/update/delete)
async function handleScarceOfferRequestCreate(request, env, corsOkHeaders, authUser, offerId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const id = Number(offerId);
  if (!Number.isFinite(id) || id <= 0) return jsonResponse({ ok: false, error: "Invalid offer id" }, 400, corsOkHeaders);

  const offer = await dbFirst(env, `SELECT id, is_closed FROM scarce_stock_offers WHERE id = ?`, [id]);
  if (!offer) return jsonResponse({ ok: false, error: "Offer not found" }, 404, corsOkHeaders);
  if (Number(offer.is_closed || 0) === 1) return jsonResponse({ ok: false, error: "Offer is closed" }, 400, corsOkHeaders);

  const body = await readJson(request);
  const qty = ssIntNonNeg(body.quantity_requested);
  const note = ssText(body.note, 4000);

  if (qty === null || qty <= 0) return jsonResponse({ ok: false, error: "Invalid quantity_requested (>= 1)" }, 400, corsOkHeaders);

  const res = await dbRun(env, `
    INSERT INTO scarce_stock_offer_requests
      (offer_id, requester_org_id, requester_location_id, quantity_requested, note, created_by, created_at, updated_at, updated_by)
    VALUES (?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'), ?)
  `, [
    id, authUser.org_id, authUser.location_id,
    qty, note,
    authUser.user_id, authUser.user_id
  ]);

  const insertedId = res?.meta?.last_row_id || null;
  await writeAudit(env, authUser.org_id, authUser.user_id, "SCARCE_REQUEST_CREATE", "scarce_stock_offer_requests", String(insertedId || ""), { offer_id: id, quantity_requested: qty });
  return jsonResponse({ ok: true, id: insertedId }, 200, corsOkHeaders);
}

async function handleScarceOfferRequestUpdate(request, env, corsOkHeaders, authUser, requestId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const id = Number(requestId);
  if (!Number.isFinite(id) || id <= 0) return jsonResponse({ ok: false, error: "Invalid request id" }, 400, corsOkHeaders);

  const existing = await dbFirst(env, `SELECT id, requester_org_id, requester_location_id FROM scarce_stock_offer_requests WHERE id = ?`, [id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  if (!(existing.requester_org_id === authUser.org_id && existing.requester_location_id === authUser.location_id)) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const body = await readJson(request);
  const qty = ssIntNonNeg(body.quantity_requested);
  const note = ssText(body.note, 4000);

  if (qty === null || qty <= 0) return jsonResponse({ ok: false, error: "Invalid quantity_requested (>= 1)" }, 400, corsOkHeaders);

  await dbRun(env, `
    UPDATE scarce_stock_offer_requests
    SET quantity_requested = ?, note = ?, updated_at = datetime('now'), updated_by = ?
    WHERE id = ?
  `, [qty, note, authUser.user_id, id]);

  await writeAudit(env, authUser.org_id, authUser.user_id, "SCARCE_REQUEST_UPDATE", "scarce_stock_offer_requests", String(id), { quantity_requested: qty });
  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleScarceOfferRequestDelete(request, env, corsOkHeaders, authUser, requestId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const id = Number(requestId);
  if (!Number.isFinite(id) || id <= 0) return jsonResponse({ ok: false, error: "Invalid request id" }, 400, corsOkHeaders);

  const existing = await dbFirst(env, `SELECT id, requester_org_id, requester_location_id, offer_id FROM scarce_stock_offer_requests WHERE id = ?`, [id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  if (!(existing.requester_org_id === authUser.org_id && existing.requester_location_id === authUser.location_id)) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await dbRun(env, `DELETE FROM scarce_stock_offer_requests WHERE id = ?`, [id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "SCARCE_REQUEST_DELETE", "scarce_stock_offer_requests", String(id), { offer_id: existing.offer_id });
  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

// ----- Needs list
async function handleScarceNeedsList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const needsBase = await dbAll(env, `
    SELECT
      n.id, n.org_id, n.location_id, n.entry_date, n.item_name, n.description, n.needed_by,
      n.quantity_needed, n.is_closed,
      org.name AS org_name,
      loc.name AS location_name,
      COALESCE(SUM(o.quantity_offered), 0) AS total_offered
    FROM scarce_stock_needs n
    JOIN orgs org ON org.id = n.org_id
    JOIN locations loc ON loc.id = n.location_id
    LEFT JOIN scarce_stock_need_offers o ON o.need_id = n.id
    GROUP BY n.id
    ORDER BY n.is_closed ASC, n.entry_date DESC, n.id DESC
  `, []);

  const needIds = needsBase.map(x => Number(x.id)).filter(n => Number.isFinite(n) && n > 0);
  let offRows = [];
  if (needIds.length) {
    const qs = needIds.map(() => "?").join(",");
    offRows = await dbAll(env, `
      SELECT
        o.id, o.need_id, o.offerer_org_id, o.offerer_location_id, o.quantity_offered, o.note,
        org.name AS offerer_org_name,
        loc.name AS offerer_location_name
      FROM scarce_stock_need_offers o
      JOIN orgs org ON org.id = o.offerer_org_id
      JOIN locations loc ON loc.id = o.offerer_location_id
      WHERE o.need_id IN (${qs})
      ORDER BY o.created_at ASC, o.id ASC
    `, needIds);
  }

  const offByNeed = new Map();
  for (const rr of offRows) {
    const nid = Number(rr.need_id);
    if (!offByNeed.has(nid)) offByNeed.set(nid, []);
    offByNeed.get(nid).push(rr);
  }

  const needs = [];
  for (const n of needsBase) {
    const mineOwner = (authUser.org_id === n.org_id && authUser.location_id === n.location_id);
    const offersIn = offByNeed.get(Number(n.id)) || [];
    const offersOut = [];

    for (const rr of offersIn) {
      const canSee = ssCanSeeSensitive(
        authUser,
        Number(n.org_id), Number(n.location_id),
        Number(rr.offerer_org_id), Number(rr.offerer_location_id)
      );
      const mine = (authUser.org_id === rr.offerer_org_id && authUser.location_id === rr.offerer_location_id);

      offersOut.push({
        id: rr.id,
        need_id: rr.need_id,
        quantity_offered: Number(rr.quantity_offered || 0),
        is_private: canSee ? 0 : 1,
        offerer_display: canSee ? ((rr.offerer_org_name || "") + " — " + (rr.offerer_location_name || "")) : "",
        note: canSee ? (rr.note || "") : "",
        mine: mine ? 1 : 0
      });
    }

    needs.push({
      id: n.id,
      org_id: n.org_id,
      org_name: n.org_name || "",
      location_id: n.location_id,
      location_name: n.location_name || "",
      entry_date: n.entry_date,
      item_name: n.item_name,
      description: n.description || "",
      needed_by: n.needed_by || null,
      quantity_needed: Number(n.quantity_needed || 0),
      is_closed: Number(n.is_closed || 0),
      total_offered: Number(n.total_offered || 0),
      remaining_quantity: Number(n.quantity_needed || 0) - Number(n.total_offered || 0),
      mine_owner: mineOwner ? 1 : 0,
      offers: offersOut
    });
  }

  return jsonResponse({ ok: true, needs }, 200, corsOkHeaders);
}

// ----- Needs create/update/delete
async function handleScarceNeedCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const body = await readJson(request);
  const entry_date = ssText(body.entry_date, 40);
  const item_name = ssText(body.item_name, 220);
  const description = ssText(body.description, 2000);
  const needed_by = ssText(body.needed_by, 40);
  const qty = ssIntNonNeg(body.quantity_needed);
  const is_closed = ssBool01(body.is_closed);

  if (!isValidYmd(entry_date)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!item_name) return jsonResponse({ ok: false, error: "Missing item_name" }, 400, corsOkHeaders);
  if (needed_by && !isValidYmd(needed_by)) return jsonResponse({ ok: false, error: "Invalid needed_by (YYYY-MM-DD or empty)" }, 400, corsOkHeaders);
  if (qty === null) return jsonResponse({ ok: false, error: "Invalid quantity_needed (>= 0)" }, 400, corsOkHeaders);

  const res = await dbRun(env, `
    INSERT INTO scarce_stock_needs
      (org_id, location_id, entry_date, item_name, description, needed_by, quantity_needed, is_closed, created_by, created_at, updated_at, updated_by)
    VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'), ?)
  `, [
    authUser.org_id, authUser.location_id,
    entry_date, item_name, description,
    (needed_by || null),
    qty, is_closed ? 1 : 0,
    authUser.user_id, authUser.user_id
  ]);

  const insertedId = res?.meta?.last_row_id || null;
  await writeAudit(env, authUser.org_id, authUser.user_id, "SCARCE_NEED_CREATE", "scarce_stock_needs", String(insertedId || ""), { item_name, quantity_needed: qty });
  return jsonResponse({ ok: true, id: insertedId }, 200, corsOkHeaders);
}

async function handleScarceNeedUpdate(request, env, corsOkHeaders, authUser, needId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const id = Number(needId);
  if (!Number.isFinite(id) || id <= 0) return jsonResponse({ ok: false, error: "Invalid need id" }, 400, corsOkHeaders);

  const existing = await dbFirst(env, `SELECT id, org_id, location_id FROM scarce_stock_needs WHERE id = ?`, [id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  if (!(existing.org_id === authUser.org_id && existing.location_id === authUser.location_id)) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const body = await readJson(request);
  const entry_date = ssText(body.entry_date, 40);
  const item_name = ssText(body.item_name, 220);
  const description = ssText(body.description, 2000);
  const needed_by = ssText(body.needed_by, 40);
  const qty = ssIntNonNeg(body.quantity_needed);
  const is_closed = ssBool01(body.is_closed);

  if (!isValidYmd(entry_date)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!item_name) return jsonResponse({ ok: false, error: "Missing item_name" }, 400, corsOkHeaders);
  if (needed_by && !isValidYmd(needed_by)) return jsonResponse({ ok: false, error: "Invalid needed_by (YYYY-MM-DD or empty)" }, 400, corsOkHeaders);
  if (qty === null) return jsonResponse({ ok: false, error: "Invalid quantity_needed (>= 0)" }, 400, corsOkHeaders);

  await dbRun(env, `
    UPDATE scarce_stock_needs
    SET entry_date = ?, item_name = ?, description = ?, needed_by = ?, quantity_needed = ?, is_closed = ?,
        updated_at = datetime('now'), updated_by = ?
    WHERE id = ?
  `, [
    entry_date, item_name, description,
    (needed_by || null),
    qty, (is_closed ? 1 : 0),
    authUser.user_id, id
  ]);

  await writeAudit(env, authUser.org_id, authUser.user_id, "SCARCE_NEED_UPDATE", "scarce_stock_needs", String(id), { item_name, quantity_needed: qty, is_closed: is_closed ? 1 : 0 });
  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleScarceNeedDelete(request, env, corsOkHeaders, authUser, needId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const id = Number(needId);
  if (!Number.isFinite(id) || id <= 0) return jsonResponse({ ok: false, error: "Invalid need id" }, 400, corsOkHeaders);

  const existing = await dbFirst(env, `SELECT id, org_id, location_id, item_name FROM scarce_stock_needs WHERE id = ?`, [id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  if (!(existing.org_id === authUser.org_id && existing.location_id === authUser.location_id)) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await dbRun(env, `DELETE FROM scarce_stock_need_offers WHERE need_id = ?`, [id]);
  await dbRun(env, `DELETE FROM scarce_stock_needs WHERE id = ?`, [id]);

  await writeAudit(env, authUser.org_id, authUser.user_id, "SCARCE_NEED_DELETE", "scarce_stock_needs", String(id), { item_name: existing.item_name || "" });
  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

// ----- Need offers (create/update/delete)
async function handleScarceNeedOfferCreate(request, env, corsOkHeaders, authUser, needId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const id = Number(needId);
  if (!Number.isFinite(id) || id <= 0) return jsonResponse({ ok: false, error: "Invalid need id" }, 400, corsOkHeaders);

  const need = await dbFirst(env, `SELECT id, is_closed FROM scarce_stock_needs WHERE id = ?`, [id]);
  if (!need) return jsonResponse({ ok: false, error: "Need not found" }, 404, corsOkHeaders);
  if (Number(need.is_closed || 0) === 1) return jsonResponse({ ok: false, error: "Need is closed" }, 400, corsOkHeaders);

  const body = await readJson(request);
  const qty = ssIntNonNeg(body.quantity_offered);
  const note = ssText(body.note, 4000);

  if (qty === null || qty <= 0) return jsonResponse({ ok: false, error: "Invalid quantity_offered (>= 1)" }, 400, corsOkHeaders);

  const res = await dbRun(env, `
    INSERT INTO scarce_stock_need_offers
      (need_id, offerer_org_id, offerer_location_id, quantity_offered, note, created_by, created_at, updated_at, updated_by)
    VALUES (?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'), ?)
  `, [
    id, authUser.org_id, authUser.location_id,
    qty, note,
    authUser.user_id, authUser.user_id
  ]);

  const insertedId = res?.meta?.last_row_id || null;
  await writeAudit(env, authUser.org_id, authUser.user_id, "SCARCE_NEED_OFFER_CREATE", "scarce_stock_need_offers", String(insertedId || ""), { need_id: id, quantity_offered: qty });
  return jsonResponse({ ok: true, id: insertedId }, 200, corsOkHeaders);
}

async function handleScarceNeedOfferUpdate(request, env, corsOkHeaders, authUser, offerId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const id = Number(offerId);
  if (!Number.isFinite(id) || id <= 0) return jsonResponse({ ok: false, error: "Invalid offer id" }, 400, corsOkHeaders);

  const existing = await dbFirst(env, `SELECT id, offerer_org_id, offerer_location_id FROM scarce_stock_need_offers WHERE id = ?`, [id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  if (!(existing.offerer_org_id === authUser.org_id && existing.offerer_location_id === authUser.location_id)) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const body = await readJson(request);
  const qty = ssIntNonNeg(body.quantity_offered);
  const note = ssText(body.note, 4000);

  if (qty === null || qty <= 0) return jsonResponse({ ok: false, error: "Invalid quantity_offered (>= 1)" }, 400, corsOkHeaders);

  await dbRun(env, `
    UPDATE scarce_stock_need_offers
    SET quantity_offered = ?, note = ?, updated_at = datetime('now'), updated_by = ?
    WHERE id = ?
  `, [qty, note, authUser.user_id, id]);

  await writeAudit(env, authUser.org_id, authUser.user_id, "SCARCE_NEED_OFFER_UPDATE", "scarce_stock_need_offers", String(id), { quantity_offered: qty });
  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleScarceNeedOfferDelete(request, env, corsOkHeaders, authUser, offerId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureScarceStockSchema(env);

  const id = Number(offerId);
  if (!Number.isFinite(id) || id <= 0) return jsonResponse({ ok: false, error: "Invalid offer id" }, 400, corsOkHeaders);

  const existing = await dbFirst(env, `SELECT id, offerer_org_id, offerer_location_id, need_id FROM scarce_stock_need_offers WHERE id = ?`, [id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  if (!(existing.offerer_org_id === authUser.org_id && existing.offerer_location_id === authUser.location_id)) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await dbRun(env, `DELETE FROM scarce_stock_need_offers WHERE id = ?`, [id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "SCARCE_NEED_OFFER_DELETE", "scarce_stock_need_offers", String(id), { need_id: existing.need_id });
  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}


// ------------------------------------------------------------
// Vaccines (Catalog + Orders + Stock)
// ------------------------------------------------------------
async function ensureVaccinesSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS vaccines_catalog (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL DEFAULT 0,
      location_id INTEGER NOT NULL DEFAULT 0,

      brand_name TEXT NOT NULL,
      vaccinates_for TEXT NOT NULL DEFAULT '',
      dosing_schedule TEXT NOT NULL DEFAULT '',
      routine_in_malta TEXT NOT NULL DEFAULT '',
      travel_always TEXT NOT NULL DEFAULT '',
      travel_highrisk TEXT NOT NULL DEFAULT '',

      created_at TEXT NOT NULL DEFAULT ''
    )`
  );

  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_vax_catalog_brand ON vaccines_catalog(brand_name)`);
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_vax_catalog_org_loc ON vaccines_catalog(org_id, location_id)`);

  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS vaccines_orders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,

      created_at TEXT NOT NULL,
      section TEXT NOT NULL DEFAULT '',         -- 'travel' | 'other'
      country_code TEXT NOT NULL DEFAULT '',
      country_name TEXT NOT NULL DEFAULT '',

      client_first TEXT NOT NULL,
      client_last TEXT NOT NULL,
      phone TEXT NOT NULL DEFAULT '',
      email TEXT NOT NULL DEFAULT ''
    )`
  );
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_vax_orders_org_loc_created ON vaccines_orders(org_id, location_id, created_at)`);

  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS vaccines_order_items (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      order_id INTEGER NOT NULL,

      vaccine_name TEXT NOT NULL,
      qty INTEGER NOT NULL DEFAULT 1
    )`
  );
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_vax_items_order ON vaccines_order_items(order_id)`);
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_vax_items_name ON vaccines_order_items(vaccine_name)`);

  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS vaccines_stock (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,

      vaccine_name TEXT NOT NULL,
      qty INTEGER NOT NULL DEFAULT 0,
      batch TEXT NOT NULL DEFAULT '',
      expiry_date TEXT NOT NULL DEFAULT '',     -- YYYY-MM-DD (optional)
      updated_at TEXT NOT NULL
    )`
  );
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_vax_stock_org_loc_name ON vaccines_stock(org_id, location_id, vaccine_name)`);
}

function vaxNormName(s) {
  return String(s == null ? "" : s).trim();
}
function vaxNormText(s) {
  return String(s == null ? "" : s);
}
function vaxNormCsv(s) {
  return String(s == null ? "" : s).trim();
}
function vaxInt(v, def = 0) {
  const n = parseInt(String(v == null ? "" : v), 10);
  return Number.isFinite(n) ? n : def;
}

async function handleVaccinesCatalogList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureVaccinesSchema(env);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  // Return global (org=0,loc=0) plus org/location scoped (org=auth, loc=0 or loc=current)
  const baseWhere = `(org_id = 0 AND location_id = 0) OR (org_id = ? AND (location_id = 0 OR location_id = ?))`;

  const sql = hasQ
    ? `SELECT id, org_id, location_id, brand_name, vaccinates_for, dosing_schedule, routine_in_malta, travel_always, travel_highrisk, created_at
       FROM vaccines_catalog
       WHERE (${baseWhere})
         AND (brand_name LIKE ? OR vaccinates_for LIKE ? OR dosing_schedule LIKE ?)
       ORDER BY brand_name COLLATE NOCASE ASC, id ASC`
    : `SELECT id, org_id, location_id, brand_name, vaccinates_for, dosing_schedule, routine_in_malta, travel_always, travel_highrisk, created_at
       FROM vaccines_catalog
       WHERE (${baseWhere})
       ORDER BY brand_name COLLATE NOCASE ASC, id ASC`;

  const bind = hasQ
    ? [authUser.org_id, authUser.location_id, qLike, qLike, qLike]
    : [authUser.org_id, authUser.location_id];

  const stmt = env.DB.prepare(sql);
  const res = await stmt.bind(...bind).all();
  const items = (res && res.results) ? res.results : [];

  return jsonResponse({ ok: true, items }, 200, corsOkHeaders);
}

async function handleVaccinesCatalogCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureVaccinesSchema(env);

  let body = null;
  try { body = await readJson(request); } catch (e) { body = null; }
  const brand_name = vaxNormName(body && body.brand_name);
  if (!brand_name) return jsonResponse({ ok: false, error: "Missing brand_name" }, 400, corsOkHeaders);

  const created_at = nowIso();

  const res = await dbRun(
    env,
    `INSERT INTO vaccines_catalog (org_id, location_id, brand_name, vaccinates_for, dosing_schedule, routine_in_malta, travel_always, travel_highrisk, created_at)
     VALUES (?, ?, ?, '', '', '', '', '', ?)`,
    [authUser.org_id, authUser.location_id, brand_name, created_at]
  );

  const newId = (res && res.meta && res.meta.last_row_id) ? Number(res.meta.last_row_id) : null;

  await writeAudit(env, authUser.org_id, authUser.user_id, "VAX_CATALOG_ADD", "vaccines_catalog", String(newId || ""), {
    brand_name
  });

  return jsonResponse({ ok: true, id: newId, created_at }, 200, corsOkHeaders);
}

async function handleVaccinesOrdersList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureVaccinesSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = month ? monthRange(month) : null;

  let ordersSql =
    `SELECT id, created_at, section, country_code, country_name, client_first, client_last, phone, email
     FROM vaccines_orders
     WHERE org_id = ? AND location_id = ?`;

  const bind = [authUser.org_id, authUser.location_id];

  if (range) {
    ordersSql += ` AND created_at >= ? AND created_at < ?`;
    bind.push(range.startStr, range.endStr);
  }

  ordersSql += ` ORDER BY id DESC LIMIT 200`;

  const ordersRes = await env.DB.prepare(ordersSql).bind(...bind).all();
  const orders = (ordersRes && ordersRes.results) ? ordersRes.results : [];

  // Items
  const ids = orders.map(o => o.id);
  let itemsByOrder = {};
  if (ids.length) {
    const placeholders = ids.map(() => "?").join(",");
    const itemsRes = await env.DB.prepare(
      `SELECT order_id, vaccine_name, qty FROM vaccines_order_items WHERE org_id = ? AND location_id = ? AND order_id IN (${placeholders}) ORDER BY id ASC`
    ).bind(authUser.org_id, authUser.location_id, ...ids).all();
    const items = (itemsRes && itemsRes.results) ? itemsRes.results : [];
    items.forEach(it => {
      const k = String(it.order_id);
      if (!itemsByOrder[k]) itemsByOrder[k] = [];
      itemsByOrder[k].push({ name: it.vaccine_name, qty: it.qty });
    });
  }

  orders.forEach(o => { o.items = itemsByOrder[String(o.id)] || []; });

  return jsonResponse({ ok: true, orders }, 200, corsOkHeaders);
}

async function applyVaccineStockDelta(env, orgId, locationId, vaccineName, deltaQty) {
  const name = vaxNormName(vaccineName);
  if (!name) return null;
  const delta = vaxInt(deltaQty, 0);
  if (!delta) return null;

  // Pick earliest expiry row first (expiry_date '' goes last). If none exists, create a default row.
  const row = await dbFirst(
    env,
    `SELECT id, qty, expiry_date
     FROM vaccines_stock
     WHERE org_id = ? AND location_id = ? AND vaccine_name = ?
     ORDER BY CASE WHEN expiry_date = '' THEN 1 ELSE 0 END, expiry_date ASC, id ASC
     LIMIT 1`,
    [orgId, locationId, name]
  );

  const ts = nowIso();

  if (!row) {
    const ins = await dbRun(
      env,
      `INSERT INTO vaccines_stock (org_id, location_id, vaccine_name, qty, batch, expiry_date, updated_at)
       VALUES (?, ?, ?, ?, '', '', ?)`,
      [orgId, locationId, name, delta, ts]
    );
    return { id: (ins && ins.meta && ins.meta.last_row_id) ? Number(ins.meta.last_row_id) : null, qty: delta };
  }

  const newQty = vaxInt(row.qty, 0) + delta;

  await dbRun(
    env,
    `UPDATE vaccines_stock SET qty = ?, updated_at = ? WHERE id = ? AND org_id = ? AND location_id = ?`,
    [newQty, ts, row.id, orgId, locationId]
  );

  return { id: row.id, qty: newQty };
}

async function handleVaccinesOrdersCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureVaccinesSchema(env);

  const body = await readJson(request);

  const section = vaxNormName(body.section || "");
  const country_code = vaxNormName(body.country_code || "");
  const country_name = vaxNormName(body.country_name || "");

  const client_first = vaxNormName(body.client_first || "");
  const client_last = vaxNormName(body.client_last || "");
  const phone = vaxNormName(body.phone || "");
  const email = vaxNormName(body.email || "");

  if (!client_first || !client_last) return jsonResponse({ ok: false, error: "Missing client name" }, 400, corsOkHeaders);
  if (!phone) return jsonResponse({ ok: false, error: "Missing phone" }, 400, corsOkHeaders);

  const itemsIn = Array.isArray(body.items) ? body.items : [];
  if (!itemsIn.length) return jsonResponse({ ok: false, error: "No items" }, 400, corsOkHeaders);

  // Normalize + aggregate duplicate vaccine names
  const agg = {};
  const items = [];
  itemsIn.forEach(it => {
    const nm = vaxNormName(it && (it.name || it.vaccine_name));
    if (!nm) return;
    let q = vaxInt(it.qty, 1);
    if (q <= 0) q = 1;
    agg[nm] = (agg[nm] || 0) + q;
  });

  Object.keys(agg).sort((a, b) => String(a).localeCompare(String(b))).forEach(nm => {
    items.push({ name: nm, qty: agg[nm] });
  });

  if (!items.length) return jsonResponse({ ok: false, error: "No valid items" }, 400, corsOkHeaders);

  const created_at = nowIso();

  const res = await dbRun(
    env,
    `INSERT INTO vaccines_orders (org_id, location_id, created_at, section, country_code, country_name, client_first, client_last, phone, email)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    [authUser.org_id, authUser.location_id, created_at, section, country_code, country_name, client_first, client_last, phone, email]
  );

  const orderId = (res && res.meta && res.meta.last_row_id) ? Number(res.meta.last_row_id) : null;
  if (!orderId) return jsonResponse({ ok: false, error: "Failed to create order" }, 500, corsOkHeaders);

  // Insert items
  for (const it of items) {
    await dbRun(
      env,
      `INSERT INTO vaccines_order_items (org_id, location_id, order_id, vaccine_name, qty)
       VALUES (?, ?, ?, ?, ?)`,
      [authUser.org_id, authUser.location_id, orderId, it.name, it.qty]
    );
  }

  // Apply stock subtraction (negative delta). This must never crash the order if stock is missing.
  let stockTouches = [];
  try {
    for (const it of items) {
      const upd = await applyVaccineStockDelta(env, authUser.org_id, authUser.location_id, it.name, -Math.abs(vaxInt(it.qty, 1)));
      if (upd) stockTouches.push(upd);
    }
  } catch (e) {
    // Ignore stock errors; orders must still be saved.
  }

  await writeAudit(env, authUser.org_id, authUser.user_id, "VAX_ORDER_CREATE", "vaccines_orders", String(orderId), {
    section, country_code, country_name, client_first, client_last, phone, email, items
  });

  return jsonResponse({
    ok: true,
    order: {
      id: orderId,
      created_at,
      section,
      country_code,
      country_name,
      client_first,
      client_last,
      phone,
      email,
      items
    },
    stock: stockTouches
  }, 200, corsOkHeaders);
}

async function handleVaccinesStockRowsList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureVaccinesSchema(env);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  const sql = hasQ
    ? `SELECT id, vaccine_name, qty, batch, expiry_date, updated_at
       FROM vaccines_stock
       WHERE org_id = ? AND location_id = ?
         AND (vaccine_name LIKE ? OR batch LIKE ? OR expiry_date LIKE ?)
       ORDER BY vaccine_name COLLATE NOCASE ASC, expiry_date ASC, id ASC`
    : `SELECT id, vaccine_name, qty, batch, expiry_date, updated_at
       FROM vaccines_stock
       WHERE org_id = ? AND location_id = ?
       ORDER BY vaccine_name COLLATE NOCASE ASC, expiry_date ASC, id ASC`;

  const bind = hasQ
    ? [authUser.org_id, authUser.location_id, qLike, qLike, qLike]
    : [authUser.org_id, authUser.location_id];

  const res = await env.DB.prepare(sql).bind(...bind).all();
  const rows = (res && res.results) ? res.results : [];

  return jsonResponse({ ok: true, rows }, 200, corsOkHeaders);
}

async function handleVaccinesStockRowCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureVaccinesSchema(env);

  const body = await readJson(request);

  const vaccine_name = vaxNormName(body.vaccine_name || body.name || "");
  if (!vaccine_name) return jsonResponse({ ok: false, error: "Missing vaccine_name" }, 400, corsOkHeaders);

  const qty = vaxInt(body.qty, 0);
  const batch = vaxNormText(body.batch || "").trim();
  const expiry_date = vaxNormText(body.expiry_date || "").trim();
  const updated_at = nowIso();

  const res = await dbRun(
    env,
    `INSERT INTO vaccines_stock (org_id, location_id, vaccine_name, qty, batch, expiry_date, updated_at)
     VALUES (?, ?, ?, ?, ?, ?, ?)`,
    [authUser.org_id, authUser.location_id, vaccine_name, qty, batch, expiry_date, updated_at]
  );

  const id = (res && res.meta && res.meta.last_row_id) ? Number(res.meta.last_row_id) : null;

  await writeAudit(env, authUser.org_id, authUser.user_id, "VAX_STOCK_CREATE", "vaccines_stock", String(id || ""), {
    vaccine_name, qty, batch, expiry_date
  });

  return jsonResponse({ ok: true, id, updated_at }, 200, corsOkHeaders);
}

async function handleVaccinesStockRowUpdate(request, env, corsOkHeaders, authUser, id) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }
  await ensureVaccinesSchema(env);

  const row = await dbFirst(env, `SELECT id, vaccine_name FROM vaccines_stock WHERE id = ? AND org_id = ? AND location_id = ?`, [id, authUser.org_id, authUser.location_id]);
  if (!row) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const qty = vaxInt(body.qty, 0);
  const batch = vaxNormText(body.batch || "").trim();
  const expiry_date = vaxNormText(body.expiry_date || "").trim();
  const updated_at = nowIso();

  await dbRun(
    env,
    `UPDATE vaccines_stock
     SET qty = ?, batch = ?, expiry_date = ?, updated_at = ?
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [qty, batch, expiry_date, updated_at, id, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "VAX_STOCK_UPDATE", "vaccines_stock", String(id), {
    vaccine_name: row.vaccine_name, qty, batch, expiry_date
  });

  return jsonResponse({ ok: true, id, updated_at }, 200, corsOkHeaders);
}

// ── Pharmacy Calculators ────────────────────────────────────────────────────

async function ensurePharmacyCalcSchema(env) {
  await dbRun(env, `CREATE TABLE IF NOT EXISTS pharmacy_calc_patients (
    id           INTEGER PRIMARY KEY AUTOINCREMENT,
    org_id       INTEGER NOT NULL,
    location_id  INTEGER NOT NULL,
    patient_name TEXT    NOT NULL DEFAULT '',
    id_card      TEXT    NOT NULL DEFAULT '',
    created_at   TEXT    NOT NULL DEFAULT (datetime('now')),
    updated_at   TEXT    NOT NULL DEFAULT (datetime('now')),
    UNIQUE(org_id, location_id, id_card)
  )`, []);
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_pharm_calc_patients_org_loc
    ON pharmacy_calc_patients (org_id, location_id, id_card)`, []);
  await dbRun(env, `CREATE TABLE IF NOT EXISTS pharmacy_calc_records (
    id               INTEGER PRIMARY KEY AUTOINCREMENT,
    org_id           INTEGER NOT NULL,
    location_id      INTEGER NOT NULL,
    patient_name     TEXT    NOT NULL DEFAULT '',
    id_card          TEXT    NOT NULL DEFAULT '',
    start_date       TEXT    NOT NULL DEFAULT '',
    calc_type        TEXT    NOT NULL DEFAULT '',
    calc_data_json   TEXT    NOT NULL DEFAULT '{}',
    created_at       TEXT    NOT NULL DEFAULT (datetime('now')),
    created_by       INTEGER
  )`, []);
  await dbRun(env, `CREATE INDEX IF NOT EXISTS idx_pharm_calc_records_org_loc
    ON pharmacy_calc_records (org_id, location_id, created_at DESC)`, []);
}

async function handlePharmacyCalcPatientsList(request, env, corsOkHeaders, authUser) {
  await ensurePharmacyCalcSchema(env);
  const rows = await dbAll(env,
    `SELECT id, patient_name, id_card FROM pharmacy_calc_patients
     WHERE org_id = ? AND location_id = ?
     ORDER BY patient_name ASC`,
    [authUser.org_id, authUser.location_id]
  );
  return jsonResponse({ ok: true, patients: rows || [] }, 200, corsOkHeaders);
}

async function handlePharmacyCalcRecordsList(request, env, corsOkHeaders, authUser) {
  await ensurePharmacyCalcSchema(env);
  const rows = await dbAll(env,
    `SELECT id, patient_name, id_card, start_date, calc_type, created_at
     FROM pharmacy_calc_records
     WHERE org_id = ? AND location_id = ?
     ORDER BY created_at DESC
     LIMIT 200`,
    [authUser.org_id, authUser.location_id]
  );
  return jsonResponse({ ok: true, records: rows || [] }, 200, corsOkHeaders);
}

async function handlePharmacyCalcRecordsCreate(request, env, corsOkHeaders, authUser) {
  await ensurePharmacyCalcSchema(env);
  const body = await request.json().catch(() => ({}));
  const patientName  = String(body.patient_name  || "").trim();
  const idCard       = String(body.id_card        || "").trim();
  const startDate    = String(body.start_date     || "").trim();
  const calcType     = String(body.calc_type      || "").trim();
  const calcDataJson = typeof body.calc_data_json === "string"
    ? body.calc_data_json
    : JSON.stringify(body.calc_data_json || {});

  if (!patientName) return jsonResponse({ ok: false, error: "patient_name is required" }, 400, corsOkHeaders);
  if (!idCard)      return jsonResponse({ ok: false, error: "id_card is required" },      400, corsOkHeaders);
  if (!calcType)    return jsonResponse({ ok: false, error: "calc_type is required" },    400, corsOkHeaders);

  // Upsert patient — unique key is (org_id, location_id, id_card)
  await dbRun(env,
    `INSERT INTO pharmacy_calc_patients
       (org_id, location_id, patient_name, id_card, created_at, updated_at)
     VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))
     ON CONFLICT(org_id, location_id, id_card) DO UPDATE SET
       patient_name = excluded.patient_name,
       updated_at   = datetime('now')`,
    [authUser.org_id, authUser.location_id, patientName, idCard]
  );

  const row = await dbFirst(env,
    `INSERT INTO pharmacy_calc_records
       (org_id, location_id, patient_name, id_card, start_date, calc_type, calc_data_json, created_at, created_by)
     VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), ?)
     RETURNING id`,
    [authUser.org_id, authUser.location_id, patientName, idCard, startDate, calcType, calcDataJson, authUser.user_id]
  );

  return jsonResponse({ ok: true, id: row ? row.id : null }, 201, corsOkHeaders);
}

async function handlePharmacyCalcRecordDelete(request, env, corsOkHeaders, authUser, recordId) {
  await ensurePharmacyCalcSchema(env);
  const existing = await dbFirst(env,
    `SELECT id FROM pharmacy_calc_records WHERE id = ? AND org_id = ? AND location_id = ?`,
    [recordId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Record not found" }, 404, corsOkHeaders);
  await dbRun(env,
    `DELETE FROM pharmacy_calc_records WHERE id = ? AND org_id = ? AND location_id = ?`,
    [recordId, authUser.org_id, authUser.location_id]
  );
  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);

    // UI assets
    if (url.pathname.startsWith("/ui/")) {
      return await handleUiAsset(request, env, url);
    }

    if (url.pathname === "/health") {
      return jsonResponse({ ok: true, time: nowIso() }, 200, { "Cache-Control": "no-store" });
    }

    if (url.pathname === "/bootstrap" && request.method === "GET") return await handleBootstrapGet(request, env);
    if (url.pathname === "/bootstrap" && request.method === "POST") return await handleBootstrapPost(request, env);

    if (url.pathname === "/su" && request.method === "GET") return await handleSuPage(request, env);

    const cors = corsHeadersForRequest(request, env);
    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: cors.headers });
    }
    const corsOkHeaders = cors.ok ? cors.headers : { "Vary": "Origin" };

    if (url.pathname === "/auth/login" && request.method === "POST") {
      if (!cors.ok) return jsonResponse({ ok: false, error: "CORS blocked" }, 403, corsOkHeaders);
      return await handleLogin(request, env, corsOkHeaders);
    }

    // Superuser admin API (requires Bearer token of allowlisted superuser)
    if (url.pathname.startsWith("/su/api/")) {
      if (!cors.ok) return jsonResponse({ ok: false, error: "CORS blocked" }, 403, corsOkHeaders);
      const su = await requireSuperuser(request, env, corsOkHeaders);
      if (!su.ok) return su.res;

      const path = url.pathname.replace(/^\/su\/api\//, "");
      const parts = path.split("/").filter(Boolean);

      if (parts.length === 1 && parts[0] === "overview" && request.method === "GET") {
        return await handleSuOverview(request, env, corsOkHeaders);
      }
      if (parts.length === 1 && parts[0] === "account" && request.method === "POST") {
        return await handleSuCreateAccount(request, env, corsOkHeaders);
      }

      
      // Orgs
      if (parts.length === 2 && parts[0] === "orgs") {
        const orgId = Number(parts[1]);
        if (!Number.isInteger(orgId) || orgId <= 0) return jsonResponse({ ok:false, error:"invalid org id" }, 400, corsOkHeaders);
        if (request.method === "GET") return await handleSuGetOrg(request, env, corsOkHeaders, orgId);
        if (request.method === "PUT") return await handleSuUpdateOrg(request, env, corsOkHeaders, orgId);
        if (request.method === "DELETE") {
          const force = url.searchParams.get("force") === "1";
          return await handleSuDeleteOrg(request, env, corsOkHeaders, orgId, force);
        }
      }

// Users
      if (parts.length === 2 && parts[0] === "users") {
        const userId = Number(parts[1]);
        if (!Number.isInteger(userId) || userId <= 0) return jsonResponse({ ok:false, error:"invalid user id" }, 400, corsOkHeaders);
        if (request.method === "GET") return await handleSuGetUser(request, env, corsOkHeaders, userId);
        if (request.method === "PUT") return await handleSuUpdateUser(request, env, corsOkHeaders, userId);
        if (request.method === "DELETE") return await handleSuDeleteUser(request, env, corsOkHeaders, userId);
      }
      if (parts.length === 3 && parts[0] === "users" && parts[2] === "password" && request.method === "POST") {
        const userId = Number(parts[1]);
        if (!Number.isInteger(userId) || userId <= 0) return jsonResponse({ ok:false, error:"invalid user id" }, 400, corsOkHeaders);
        return await handleSuResetPassword(request, env, corsOkHeaders, userId);
      }

      // Locations
      if (parts.length === 2 && parts[0] === "locations") {
        const locationId = Number(parts[1]);
        if (!Number.isInteger(locationId) || locationId <= 0) return jsonResponse({ ok:false, error:"invalid location id" }, 400, corsOkHeaders);
        if (request.method === "GET") return await handleSuGetLocation(request, env, corsOkHeaders, locationId);
        if (request.method === "PUT") return await handleSuUpdateLocation(request, env, corsOkHeaders, locationId);
        if (request.method === "DELETE") return await handleSuDeleteLocation(request, env, corsOkHeaders, locationId);
      }
      if (parts.length === 3 && parts[0] === "locations" && parts[2] === "wipe" && request.method === "POST") {
        const locationId = Number(parts[1]);
        if (!Number.isInteger(locationId) || locationId <= 0) return jsonResponse({ ok:false, error:"invalid location id" }, 400, corsOkHeaders);
        return await handleSuWipeLocation(request, env, corsOkHeaders, locationId);
      }

      return jsonResponse({ ok:false, error:"Not found" }, 404, corsOkHeaders);
    }

    const authUser = await authFromRequest(request, env);
    if (!authUser) return jsonResponse({ ok: false, error: "Unauthorized" }, 401, corsOkHeaders);
    if (!cors.ok) return jsonResponse({ ok: false, error: "CORS blocked" }, 403, corsOkHeaders);

    if (url.pathname === "/auth/me" && request.method === "GET") {
      return await handleMe(env, corsOkHeaders, authUser);
    }

    // End Of Day (EOD) — GET record (all paths the UI may try)
    if (request.method === "GET" && (url.pathname === "/eod/get" || url.pathname === "/eod/record" || url.pathname === "/eod" || url.pathname === "/endofday/record" || url.pathname === "/endofday")) {
      return await handleEodGet(request, env, corsOkHeaders, authUser, url);
    }
    // EOD — upsert record (POST or PUT, all paths the UI may try)
    if ((request.method === "POST" || request.method === "PUT") && (url.pathname === "/eod/upsert" || url.pathname === "/eod/record" || url.pathname === "/eod" || url.pathname === "/endofday/record" || url.pathname === "/endofday")) {
      return await handleEodUpsert(request, env, corsOkHeaders, authUser);
    }
    // EOD — lock
    if (url.pathname === "/eod/lock" && request.method === "POST") return await handleEodLock(request, env, corsOkHeaders, authUser);
    // EOD — list dates for month (all paths the UI may try)
    if (request.method === "GET" && (url.pathname === "/eod/dates" || url.pathname === "/eod/month" || url.pathname === "/eod/list" || url.pathname === "/endofday/dates" || url.pathname === "/endofday/month" || url.pathname === "/endofday/list")) {
      return await handleEodListDates(request, env, corsOkHeaders, authUser, url);
    }
    // EOD Contacts — list (GET, all paths the UI may try)
    if (request.method === "GET" && (url.pathname === "/eod/contacts" || url.pathname === "/endofday/contacts" || url.pathname === "/eod/contact" || url.pathname === "/endofday/contact")) {
      return await handleEodContactsList(request, env, corsOkHeaders, authUser);
    }
    // EOD Contacts — bulk save (PUT, all paths)
    if (request.method === "PUT" && (url.pathname === "/eod/contacts" || url.pathname === "/endofday/contacts")) {
      return await handleEodContactsBulkPut(request, env, corsOkHeaders, authUser);
    }
    // EOD Contacts — create (POST, all paths)
    if (request.method === "POST" && (url.pathname === "/eod/contacts" || url.pathname === "/endofday/contacts")) {
      return await handleEodContactsCreate(request, env, corsOkHeaders, authUser);
    }
    // EOD Contacts — update/delete individual
    { const m = url.pathname.match(/^\/(?:eod|endofday)\/contacts\/(\d+)$/); if (m && request.method === "PUT") return await handleEodContactsUpdate(request, env, corsOkHeaders, authUser, Number(m[1])); if (m && request.method === "DELETE") return await handleEodContactsDeactivate(request, env, corsOkHeaders, authUser, Number(m[1])); }


    // Instructions (global + daily handover)
    if (url.pathname === "/instructions/global" && request.method === "GET") {
      return await handleInstructionsGlobalGet(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname === "/instructions/global" && request.method === "PUT") {
      return await handleInstructionsGlobalPut(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname === "/instructions/daily" && request.method === "GET") {
      return await handleInstructionsDailyGetOrList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/instructions/daily" && request.method === "PUT") {
      return await handleInstructionsDailyPut(request, env, corsOkHeaders, authUser);
    }


    // Scarce Stock
    if (url.pathname === "/scarce-stock/offers" && request.method === "GET") {
      return await handleScarceOffersList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/scarce-stock/offers" && request.method === "POST") {
      return await handleScarceOfferCreate(request, env, corsOkHeaders, authUser);
    }

    // Offer requests
    if (url.pathname.startsWith("/scarce-stock/offers/") && url.pathname.endsWith("/requests") && request.method === "POST") {
      const parts = url.pathname.split("/").filter(Boolean); // scarce-stock, offers, :id, requests
      const offerId = parseInt(parts[2], 10);
      if (!Number.isInteger(offerId) || offerId <= 0) return jsonResponse({ ok: false, error: "Invalid offer id" }, 400, corsOkHeaders);
      return await handleScarceOfferRequestCreate(request, env, corsOkHeaders, authUser, offerId);
    }
    if (url.pathname.startsWith("/scarce-stock/offer-requests/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean); // scarce-stock, offer-requests, :id
      const reqId = parseInt(parts[2], 10);
      if (!Number.isInteger(reqId) || reqId <= 0) return jsonResponse({ ok: false, error: "Invalid request id" }, 400, corsOkHeaders);
      return await handleScarceOfferRequestUpdate(request, env, corsOkHeaders, authUser, reqId);
    }
    if (url.pathname.startsWith("/scarce-stock/offer-requests/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const reqId = parseInt(parts[2], 10);
      if (!Number.isInteger(reqId) || reqId <= 0) return jsonResponse({ ok: false, error: "Invalid request id" }, 400, corsOkHeaders);
      return await handleScarceOfferRequestDelete(request, env, corsOkHeaders, authUser, reqId);
    }

    // Offer update/delete
    if (url.pathname.startsWith("/scarce-stock/offers/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean); // scarce-stock, offers, :id
      const offerId = parseInt(parts[2], 10);
      if (!Number.isInteger(offerId) || offerId <= 0) return jsonResponse({ ok: false, error: "Invalid offer id" }, 400, corsOkHeaders);
      return await handleScarceOfferUpdate(request, env, corsOkHeaders, authUser, offerId);
    }
    if (url.pathname.startsWith("/scarce-stock/offers/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const offerId = parseInt(parts[2], 10);
      if (!Number.isInteger(offerId) || offerId <= 0) return jsonResponse({ ok: false, error: "Invalid offer id" }, 400, corsOkHeaders);
      return await handleScarceOfferDelete(request, env, corsOkHeaders, authUser, offerId);
    }

    // Needs
    if (url.pathname === "/scarce-stock/needs" && request.method === "GET") {
      return await handleScarceNeedsList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/scarce-stock/needs" && request.method === "POST") {
      return await handleScarceNeedCreate(request, env, corsOkHeaders, authUser);
    }

    // Need offers
    if (url.pathname.startsWith("/scarce-stock/needs/") && url.pathname.endsWith("/offers") && request.method === "POST") {
      const parts = url.pathname.split("/").filter(Boolean); // scarce-stock, needs, :id, offers
      const needId = parseInt(parts[2], 10);
      if (!Number.isInteger(needId) || needId <= 0) return jsonResponse({ ok: false, error: "Invalid need id" }, 400, corsOkHeaders);
      return await handleScarceNeedOfferCreate(request, env, corsOkHeaders, authUser, needId);
    }
    if (url.pathname.startsWith("/scarce-stock/need-offers/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean); // scarce-stock, need-offers, :id
      const offerId = parseInt(parts[2], 10);
      if (!Number.isInteger(offerId) || offerId <= 0) return jsonResponse({ ok: false, error: "Invalid offer id" }, 400, corsOkHeaders);
      return await handleScarceNeedOfferUpdate(request, env, corsOkHeaders, authUser, offerId);
    }
    if (url.pathname.startsWith("/scarce-stock/need-offers/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const offerId = parseInt(parts[2], 10);
      if (!Number.isInteger(offerId) || offerId <= 0) return jsonResponse({ ok: false, error: "Invalid offer id" }, 400, corsOkHeaders);
      return await handleScarceNeedOfferDelete(request, env, corsOkHeaders, authUser, offerId);
    }

    // Need update/delete
    if (url.pathname.startsWith("/scarce-stock/needs/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean); // scarce-stock, needs, :id
      const needId = parseInt(parts[2], 10);
      if (!Number.isInteger(needId) || needId <= 0) return jsonResponse({ ok: false, error: "Invalid need id" }, 400, corsOkHeaders);
      return await handleScarceNeedUpdate(request, env, corsOkHeaders, authUser, needId);
    }
    if (url.pathname.startsWith("/scarce-stock/needs/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const needId = parseInt(parts[2], 10);
      if (!Number.isInteger(needId) || needId <= 0) return jsonResponse({ ok: false, error: "Invalid need id" }, 400, corsOkHeaders);
      return await handleScarceNeedDelete(request, env, corsOkHeaders, authUser, needId);
    }


    // Temperature
    if (url.pathname === "/temperature/devices" && request.method === "GET") {
      return await handleTempDevicesList(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname === "/temperature/devices" && request.method === "POST") {
      return await handleTempDevicesCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/temperature/devices/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid device id" }, 400, corsOkHeaders);
      return await handleTempDevicesUpdate(request, env, corsOkHeaders, authUser, id);
    }

    if (url.pathname === "/temperature/entries" && request.method === "GET") {
      return await handleTempEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/temperature/entries" && request.method === "POST") {
      return await handleTempEntriesUpsert(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/temperature/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleTempEntryDelete(request, env, corsOkHeaders, authUser, id);
    }

    if (url.pathname === "/temperature/report" && request.method === "GET") {
      return await handleTempReport(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/temperature/report/html" && request.method === "GET") {
      return await handleTempReportHtml(request, env, corsOkHeaders, authUser, url);
    }

// Vaccines
if (url.pathname === "/vaccines/catalog" && request.method === "GET") {
  return await handleVaccinesCatalogList(request, env, corsOkHeaders, authUser, url);
}
if (url.pathname === "/vaccines/catalog" && request.method === "POST") {
  return await handleVaccinesCatalogCreate(request, env, corsOkHeaders, authUser);
}
if (url.pathname === "/vaccines/orders" && request.method === "GET") {
  return await handleVaccinesOrdersList(request, env, corsOkHeaders, authUser, url);
}
if (url.pathname === "/vaccines/orders" && request.method === "POST") {
  return await handleVaccinesOrdersCreate(request, env, corsOkHeaders, authUser);
}
if (url.pathname === "/vaccines/stock/rows" && request.method === "GET") {
  return await handleVaccinesStockRowsList(request, env, corsOkHeaders, authUser, url);
}
if (url.pathname === "/vaccines/stock/rows" && request.method === "POST") {
  return await handleVaccinesStockRowCreate(request, env, corsOkHeaders, authUser);
}
if (url.pathname.startsWith("/vaccines/stock/rows/") && request.method === "PUT") {
  const parts = url.pathname.split("/").filter(Boolean);
  const id = parseInt(parts[3], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid stock row id" }, 400, corsOkHeaders);
  return await handleVaccinesStockRowUpdate(request, env, corsOkHeaders, authUser, id);
}


// Client Orders
if (url.pathname === "/client-orders/entries" && request.method === "GET") {
  return await handleClientOrdersEntriesList(request, env, corsOkHeaders, authUser, url);
}
if (url.pathname === "/client-orders/entries" && request.method === "POST") {
  return await handleClientOrdersEntryCreate(request, env, corsOkHeaders, authUser);
}
if (url.pathname.startsWith("/client-orders/entries/") && request.method === "PUT") {
  const parts = url.pathname.split("/").filter(Boolean);
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  return await handleClientOrdersEntryUpdate(request, env, corsOkHeaders, authUser, id);
}
if (url.pathname.startsWith("/client-orders/entries/") && request.method === "DELETE") {
  const parts = url.pathname.split("/").filter(Boolean);
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  return await handleClientOrdersEntryDelete(request, env, corsOkHeaders, authUser, id);
}
// Near Expiry
if (url.pathname === "/near-expiry/entries" && request.method === "GET") {
  return await handleNearExpiryEntriesList(request, env, corsOkHeaders, authUser, url);
}
if (url.pathname === "/near-expiry/entries" && request.method === "POST") {
  return await handleNearExpiryEntryCreate(request, env, corsOkHeaders, authUser);
}
if (url.pathname.startsWith("/near-expiry/entries/") && request.method === "PUT") {
  const parts = url.pathname.split("/").filter(Boolean);
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  return await handleNearExpiryEntryUpdate(request, env, corsOkHeaders, authUser, id);
}
if (url.pathname.startsWith("/near-expiry/entries/") && request.method === "DELETE") {
  const parts = url.pathname.split("/").filter(Boolean);
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  return await handleNearExpiryEntryDelete(request, env, corsOkHeaders, authUser, id);
}



    // Cleaning
    if (url.pathname === "/cleaning/entries" && request.method === "GET") {
      return await handleCleaningEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/cleaning/entries" && request.method === "POST") {
      return await handleCleaningEntryCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/cleaning/entries/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleCleaningEntryUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/cleaning/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleCleaningEntryDelete(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname === "/cleaning/report" && request.method === "GET") {
      return await handleCleaningReport(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/cleaning/report/html" && request.method === "GET") {
      return await handleCleaningReportHtml(request, env, corsOkHeaders, authUser, url);
    }

    // Locum Register
    if (url.pathname === "/locumregister/entries" && request.method === "GET") {
      return await handleLocumRegisterEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/locumregister/entries" && request.method === "POST") {
      return await handleLocumRegisterEntryCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/locumregister/entries/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleLocumRegisterEntryUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/locumregister/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleLocumRegisterEntryDelete(request, env, corsOkHeaders, authUser, id);
    }


    

    // Locum Receipts
    if (url.pathname === "/locumreceipts/receipts" && request.method === "GET") {
      return await handleLocumReceiptsList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/locumreceipts/receipts" && request.method === "POST") {
      return await handleLocumReceiptCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/locumreceipts/receipts/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid receipt id" }, 400, corsOkHeaders);
      return await handleLocumReceiptUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/locumreceipts/receipts/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid receipt id" }, 400, corsOkHeaders);
      return await handleLocumReceiptDelete(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname === "/locumreceipts/report" && request.method === "GET") {
      return await handleLocumReceiptsReport(request, env, corsOkHeaders, authUser, url);
    }

    // POCT (Point of Care Testing) — cloud state sync
    if (url.pathname === "/poct/state" && request.method === "GET") {
      return await handlePoctStateGet(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/poct/state" && request.method === "PUT") {
      return await handlePoctStatePut(request, env, corsOkHeaders, authUser);
    }

// Daily Register (PATCH: use /daily-register/* not /daily_register/*)
    if (url.pathname === "/daily-register/entries" && request.method === "GET") {
      return await handleDailyRegisterEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/daily-register/entries" && request.method === "POST") {
      return await handleDailyRegisterEntryCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/daily-register/entries/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDailyRegisterEntryUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/daily-register/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDailyRegisterEntryDelete(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname === "/daily-register/report" && request.method === "GET") {
      return await handleDailyRegisterReport(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/daily-register/report/html" && request.method === "GET") {
      return await handleDailyRegisterReportHtml(request, env, corsOkHeaders, authUser, url);
    }

// Alerts
if (url.pathname === "/alerts/entries" && request.method === "GET") {
  return await handleAlertsEntriesList(request, env, corsOkHeaders, authUser, url);
}
if (url.pathname === "/alerts/entries" && request.method === "POST") {
  return await handleAlertsEntryCreate(request, env, corsOkHeaders, authUser);
}
if (url.pathname.startsWith("/alerts/entries/")) {
  const parts = url.pathname.split("/").filter(Boolean);
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  if (request.method === "PUT") return await handleAlertsEntryUpdate(request, env, corsOkHeaders, authUser, id);
  if (request.method === "DELETE") return await handleAlertsEntryDelete(request, env, corsOkHeaders, authUser, id);
}

    // Returns
    if (url.pathname === "/returns/entries" && request.method === "GET") {
      return await handleReturnsEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/returns/entries" && request.method === "POST") {
      return await handleReturnsEntryCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/returns/entries/")) {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      if (request.method === "PUT") return await handleReturnsEntryUpdate(request, env, corsOkHeaders, authUser, id);
      if (request.method === "DELETE") return await handleReturnsEntryDelete(request, env, corsOkHeaders, authUser, id);
    }



    // DDA Sales  <-- ADDED ROUTES
    if (url.pathname === "/dda-sales/client" && request.method === "GET") {
      return await handleDdaSalesClientLookup(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/dda-sales/doctors" && request.method === "GET") {
      return await handleDdaSalesDoctorsLookup(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/dda-sales/entries" && request.method === "GET") {
      return await handleDdaSalesEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/dda-sales/entries" && request.method === "POST") {
      return await handleDdaSalesEntryCreate(request, env, corsOkHeaders, authUser);
    }
        if (url.pathname === "/dda-sales/entries/delete" && request.method === "POST") {
      return await handleDdaSalesEntryDeleteByBody(request, env, corsOkHeaders, authUser);
    }
if (url.pathname.startsWith("/dda-sales/entries/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDdaSalesEntryUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/dda-sales/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDdaSalesEntryDelete(request, env, corsOkHeaders, authUser, id);
    }
    // Fallback: some environments may block DELETE; allow POST /dda-sales/entries/:id/delete
    if (url.pathname.startsWith("/dda-sales/entries/") && request.method === "POST") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      const action = parts[3] || "";
      if (action !== "delete") return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDdaSalesEntryDelete(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname === "/dda-sales/report" && request.method === "GET") {
      return await handleDdaSalesReport(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/dda-sales/report/html" && request.method === "GET") {
      return await handleDdaSalesReportHtml(request, env, corsOkHeaders, authUser, url);
    }

    // Repeat Prescriptions
    if (url.pathname === "/repeat-prescriptions/entries" && request.method === "GET") {
      return await handleRepeatPrescriptionsEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/repeat-prescriptions/entries" && request.method === "POST") {
      return await handleRepeatPrescriptionsEntryCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/repeat-prescriptions/entries/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleRepeatPrescriptionsEntryUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/repeat-prescriptions/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleRepeatPrescriptionsEntryDelete(request, env, corsOkHeaders, authUser, id);
    }


    // DDA POYC  <-- ADDED ROUTES (NEW)
    if (url.pathname === "/dda-poyc/entries" && request.method === "GET") {
      return await handleDdaPoycEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/dda-poyc/entries" && request.method === "POST") {
      return await handleDdaPoycEntryCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/dda-poyc/entries/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDdaPoycEntryUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/dda-poyc/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDdaPoycEntryDelete(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname === "/dda-poyc/report" && request.method === "GET") {
      return await handleDdaPoycReport(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/dda-poyc/report/html" && request.method === "GET") {
      return await handleDdaPoycReportHtml(request, env, corsOkHeaders, authUser, url);
    }

    // DDA Purchases  <-- NEW ROUTES
if (url.pathname === "/dda-purchases/entries" && request.method === "GET") {
  return await handleDdaPurchasesEntriesList(request, env, corsOkHeaders, authUser, url);
}
if (url.pathname === "/dda-purchases/entries" && request.method === "POST") {
  return await handleDdaPurchasesEntryCreate(request, env, corsOkHeaders, authUser);
}
if (url.pathname.startsWith("/dda-purchases/entries/") && request.method === "PUT") {
  const parts = url.pathname.split("/").filter(Boolean);
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  return await handleDdaPurchasesEntryUpdate(request, env, corsOkHeaders, authUser, id);
}
if (url.pathname.startsWith("/dda-purchases/entries/") && request.method === "DELETE") {
  const parts = url.pathname.split("/").filter(Boolean);
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  return await handleDdaPurchasesEntryDelete(request, env, corsOkHeaders, authUser, id);
}
if (url.pathname === "/dda-purchases/report" && request.method === "GET") {
  return await handleDdaPurchasesReport(request, env, corsOkHeaders, authUser, url);
}
if (url.pathname === "/dda-purchases/report/html" && request.method === "GET") {
  return await handleDdaPurchasesReportHtml(request, env, corsOkHeaders, authUser, url);
}

    // ✅ DDA Stock Takes (NEW)
if (url.pathname === "/dda-stocktakes/stocktakes" && request.method === "GET")
  return await handleDdaStockTakesList(request, env, corsOkHeaders, authUser);

if (url.pathname === "/dda-stocktakes/stocktakes" && request.method === "POST")
  return await handleDdaStockTakeCreate(request, env, corsOkHeaders, authUser);

if (url.pathname.startsWith("/dda-stocktakes/stocktakes/")) {
  const parts = url.pathname.split("/").filter(Boolean); // ["dda-stocktakes","stocktakes",":id", ...]
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid stocktake id" }, 400, corsOkHeaders);

  // /dda-stocktakes/stocktakes/:id
  if (parts.length === 3 && request.method === "GET")
    return await handleDdaStockTakeGet(request, env, corsOkHeaders, authUser, id);

  if (parts.length === 3 && request.method === "PUT")
    return await handleDdaStockTakeUpdate(request, env, corsOkHeaders, authUser, id);

  // /dda-stocktakes/stocktakes/:id/items
  if (parts.length === 4 && parts[3] === "items" && request.method === "POST")
    return await handleDdaStockTakeItemAdd(request, env, corsOkHeaders, authUser, id);

  // /dda-stocktakes/stocktakes/:id/report/html
  if (parts.length === 5 && parts[3] === "report" && parts[4] === "html" && request.method === "GET")
    return await handleDdaStockTakeReportHtml(request, env, corsOkHeaders, authUser, id);
}

if (url.pathname.startsWith("/dda-stocktakes/items/")) {
  const parts = url.pathname.split("/").filter(Boolean); // ["dda-stocktakes","items",":itemId"]
  const itemId = parseInt(parts[2], 10);
  if (!itemId) return jsonResponse({ ok: false, error: "Invalid item id" }, 400, corsOkHeaders);

  if (request.method === "PUT")
    return await handleDdaStockTakeItemUpdate(request, env, corsOkHeaders, authUser, itemId);

  if (request.method === "DELETE")
    return await handleDdaStockTakeItemDelete(request, env, corsOkHeaders, authUser, itemId);
}


    // Certificates (DOWNLOAD) - PATCH
    if (url.pathname.startsWith("/certificates/items/") && (request.method === "GET" || request.method === "HEAD")) {
      const parts = url.pathname.split("/").filter(Boolean);
      const idOrKey = parts[2];
      const tail = parts[3] || "";

      if ((tail === "download" || tail === "file") && idOrKey) {
        const res = await handleCertificatesDownload(request, env, corsOkHeaders, authUser, idOrKey);
        if (request.method === "HEAD") {
          const h = new Headers(res.headers);
          return new Response(null, { status: res.status, headers: h });
        }
        return res;
      }
    }

    // Certificates
    if (url.pathname === "/certificates/items" && request.method === "GET") {
      return await handleCertificatesItemsList(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/certificates/items/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const idOrKey = parts[2]; // /certificates/items/:idOrKey
      if (!idOrKey) return jsonResponse({ ok: false, error: "Invalid item id/key" }, 400, corsOkHeaders);
      return await handleCertificatesItemUpdate(request, env, corsOkHeaders, authUser, idOrKey);
    }
    if (url.pathname.startsWith("/certificates/items/") && request.method === "POST") {
      const parts = url.pathname.split("/").filter(Boolean);
      const idOrKey = parts[2]; // /certificates/items/:idOrKey/upload
      const tail = parts[3] || "";
      if (tail !== "upload") return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
      if (!idOrKey) return jsonResponse({ ok: false, error: "Invalid item id/key" }, 400, corsOkHeaders);
      return await handleCertificatesUpload(request, env, corsOkHeaders, authUser, idOrKey);
    }

    // ── Pharmacy Calculators ─────────────────────────────────────────────────
    if (url.pathname === "/pharmacy-calc/patients" && request.method === "GET")
      return await handlePharmacyCalcPatientsList(request, env, corsOkHeaders, authUser);

    if (url.pathname === "/pharmacy-calc/records" && request.method === "GET")
      return await handlePharmacyCalcRecordsList(request, env, corsOkHeaders, authUser);

    if (url.pathname === "/pharmacy-calc/records" && request.method === "POST")
      return await handlePharmacyCalcRecordsCreate(request, env, corsOkHeaders, authUser);

    if (url.pathname.startsWith("/pharmacy-calc/records/")) {
      const parts = url.pathname.split("/").filter(Boolean); // ["pharmacy-calc","records",":id"]
      const recId = parseInt(parts[2], 10);
      if (!recId) return jsonResponse({ ok: false, error: "Invalid record id" }, 400, corsOkHeaders);
      if (request.method === "DELETE")
        return await handlePharmacyCalcRecordDelete(request, env, corsOkHeaders, authUser, recId);
    }

    return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
    } catch (e) {
      // Never let an exception become Cloudflare 1101 HTML again.
      console.log("[worker] exception", e && (e.stack || e.message || String(e)));

      let corsHeaders = { "Vary": "Origin" };
      try {
        const cors = corsHeadersForRequest(request, env);
        corsHeaders = cors.ok ? cors.headers : { "Vary": "Origin" };
      } catch {}

      const debugStack = String(env.DEBUG_STACK || "").trim() === "1";
      const payload = {
        ok: false,
        error: "Worker threw exception",
        message: (e && e.message) ? e.message : String(e)
      };
      if (debugStack) payload.stack = e && e.stack ? e.stack : "";

      return jsonResponse(payload, 500, corsHeaders);
    }
  }
};
 
