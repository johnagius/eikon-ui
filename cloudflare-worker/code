function nowIso() {
  return new Date().toISOString();
}

function jsonResponse(data, status = 200, extraHeaders = {}) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Cache-Control": "no-store",
      "Pragma": "no-cache",
      ...extraHeaders
    }
  });
}

function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, (c) => ({
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }[c]));
}

function parseAllowedOrigins(env) {
  const raw = (env.ALLOWED_ORIGINS || "").trim();
  if (!raw) return [];
  return raw.split(",").map(s => s.trim()).filter(Boolean);
}

function corsHeadersForRequest(request, env) {
  const origin = request.headers.get("Origin") || "";
  const allowed = parseAllowedOrigins(env);
  const selfOrigin = new URL(request.url).origin;

  // If Origin is missing (same-origin requests often omit it), allow.
  if (!origin) {
    return { ok: true, headers: { "Vary": "Origin" } };
  }

  // Always allow same-origin
  if (origin === selfOrigin) {
    return {
      ok: true,
      headers: {
        "Access-Control-Allow-Origin": origin,
        "Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS,HEAD",
        "Access-Control-Allow-Headers": "Content-Type, Authorization",
        "Access-Control-Max-Age": "86400",
        "Vary": "Origin"
      }
    };
  }

  if (allowed.length === 0) {
    return { ok: false, headers: { "Vary": "Origin" } };
  }

  const matched = allowed.includes(origin);
  if (!matched) {
    return { ok: false, headers: { "Vary": "Origin" } };
  }

  return {
    ok: true,
    headers: {
      "Access-Control-Allow-Origin": origin,
      "Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS,HEAD",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Max-Age": "86400",
      "Vary": "Origin"
    }
  };
}

function base64FromBytes(bytes) {
  let binary = "";
  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

function bytesFromBase64(b64) {
  const bin = atob(b64);
  const out = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
  return out;
}

function base64UrlFromBytes(bytes) {
  return base64FromBytes(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function constantTimeEqual(a, b) {
  if (a.length !== b.length) return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++) diff |= (a[i] ^ b[i]);
  return diff === 0;
}

async function sha256B64FromString(s) {
  const enc = new TextEncoder();
  const digest = await crypto.subtle.digest("SHA-256", enc.encode(s));
  return base64FromBytes(new Uint8Array(digest));
}

async function pbkdf2Hash(password, saltBytes, iterations) {
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    { name: "PBKDF2" },
    false,
    ["deriveBits"]
  );

  const bits = await crypto.subtle.deriveBits(
    {
      name: "PBKDF2",
      hash: "SHA-256",
      salt: saltBytes,
      iterations
    },
    keyMaterial,
    256
  );

  return new Uint8Array(bits);
}

async function readJson(request) {
  const ct = request.headers.get("Content-Type") || "";
  if (!ct.toLowerCase().includes("application/json")) {
    throw new Error("Expected application/json");
  }
  return await request.json();
}

async function dbFirst(env, sql, bind = []) {
  const stmt = env.DB.prepare(sql);
  const res = bind.length ? await stmt.bind(...bind).first() : await stmt.first();
  return res || null;
}

async function dbAll(env, sql, bind = []) {
  const stmt = env.DB.prepare(sql);
  const res = bind.length ? await stmt.bind(...bind).all() : await stmt.all();
  return res.results || [];
}

async function dbRun(env, sql, bind = []) {
  const stmt = env.DB.prepare(sql);
  const res = bind.length ? await stmt.bind(...bind).run() : await stmt.run();
  return res;
}

async function writeAudit(env, orgId, userId, action, entityType, entityId, detailsObj) {
  const detailsJson = JSON.stringify(detailsObj || {});
  await dbRun(
    env,
    `INSERT INTO audit_log (org_id, user_id, action, entity_type, entity_id, details_json, created_at)
     VALUES (?, ?, ?, ?, ?, ?, datetime('now'))`,
    [orgId, userId || null, action, entityType, entityId || "", detailsJson]
  );
}

function requireRole(user, roles) {
  return user && roles.includes(user.role);
}

async function authFromRequest(request, env) {
  const auth = request.headers.get("Authorization") || "";
  const m = auth.match(/^Bearer\s+(.+)$/i);
  if (!m) return null;

  const token = m[1].trim();
  if (!token) return null;

  const tokenHashB64 = await sha256B64FromString(token);

  const sess = await dbFirst(
    env,
    `SELECT
       s.id AS session_id,
       s.user_id,
       s.expires_at,
       u.org_id,
       u.email,
       u.full_name,
       u.role,
       u.is_active,
       u.default_location_id
     FROM sessions s
     JOIN users u ON u.id = s.user_id
     WHERE s.token_hash_b64 = ?`,
    [tokenHashB64]
  );

  if (!sess) return null;
  if (sess.is_active !== 1) return null;

  const now = new Date();
  const exp = new Date(sess.expires_at);
  if (!(exp > now)) return null;

  const locId = sess.default_location_id ? Number(sess.default_location_id) : null;
  if (!locId) return null;

  const loc = await dbFirst(env, "SELECT id, name FROM locations WHERE id = ? AND org_id = ?", [locId, sess.org_id]);
  if (!loc) return null;

  const org = await dbFirst(env, "SELECT id, name FROM orgs WHERE id = ?", [sess.org_id]);

  return {
    session_id: sess.session_id,
    user_id: sess.user_id,
    org_id: sess.org_id,
    org_name: org ? org.name : "",
    email: sess.email,
    full_name: sess.full_name,
    role: sess.role,
    location_id: loc.id,
    location_name: loc.name
  };
}

function htmlPage(title, bodyHtml) {
  return new Response(
    `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>${escapeHtml(title)}</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;max-width:820px;margin:40px auto;padding:0 16px;}
  .card{border:1px solid #ddd;border-radius:12px;padding:18px;margin-top:16px;}
  label{display:block;margin-top:10px;font-weight:700;}
  input{width:100%;padding:10px;border:1px solid #ccc;border-radius:10px;margin-top:6px;}
  button{margin-top:16px;padding:10px 14px;border:0;border-radius:10px;background:#111;color:#fff;font-weight:800;cursor:pointer;}
  code{background:#f6f6f6;padding:2px 6px;border-radius:6px;}
  .ok{color:green;font-weight:800;}
  .err{color:#b00020;font-weight:800;}
</style>
</head>
<body>
${bodyHtml}
</body>
</html>`,
    { headers: { "Content-Type": "text/html; charset=utf-8" } }
  );
}

async function parseForm(request) {
  const ct = (request.headers.get("Content-Type") || "").toLowerCase();
  if (!ct.includes("application/x-www-form-urlencoded") && !ct.includes("multipart/form-data")) {
    return null;
  }
  const form = await request.formData();
  const obj = {};
  for (const [k, v] of form.entries()) obj[k] = String(v);
  return obj;
}

async function handleBootstrapGet(request, env) {
  const usersCountRow = await dbFirst(env, "SELECT COUNT(*) AS c FROM users", []);
  const hasUsers = usersCountRow && usersCountRow.c > 0;

  const body = `
<h1>Eikon API Bootstrap</h1>
<div class="card">
  <p>This creates the <b>first</b> org, location, and admin user.</p>
  <p>Status: ${hasUsers ? `<span class="err">Bootstrap disabled (users already exist)</span>` : `<span class="ok">Ready</span>`}</p>
  <form method="POST" action="/bootstrap">
    <label>Bootstrap Token</label>
    <input name="bootstrap_token" required />
    <label>Org / Client Name</label>
    <input name="org_name" required value="Demo Pharmacy"/>
    <label>Default Location Name</label>
    <input name="location_name" required value="Main Branch"/>
    <label>Admin Email</label>
    <input name="admin_email" required value="admin@example.com"/>
    <label>Admin Full Name</label>
    <input name="admin_full_name" required value="Admin"/>
    <label>Admin Password</label>
    <input name="admin_password" type="password" required />
    <button type="submit" ${hasUsers ? "disabled" : ""}>Create Admin</button>
  </form>
  <p style="margin-top:12px;color:#555;">Note: location is tied to account (no switching).</p>
</div>`;
  return htmlPage("Bootstrap", body);
}

async function handleBootstrapPost(request, env) {
  try {
    const usersCountRow = await dbFirst(env, "SELECT COUNT(*) AS c FROM users", []);
    const hasUsers = usersCountRow && usersCountRow.c > 0;
    if (hasUsers) {
      return htmlPage("Bootstrap", `<h1>Bootstrap disabled</h1><p class="err">Users already exist.</p>`);
    }

    let payload = await parseForm(request);
    if (!payload) {
      try { payload = await readJson(request); } catch { payload = {}; }
    }

    const bootstrapToken = (payload.bootstrap_token || "").trim();
    const orgName = (payload.org_name || "").trim();
    const locationName = (payload.location_name || "").trim();
    const adminEmail = (payload.admin_email || "").trim().toLowerCase();
    const adminFullName = (payload.admin_full_name || "").trim();
    const adminPassword = (payload.admin_password || "").trim();

    if (!bootstrapToken || !orgName || !locationName || !adminEmail || !adminPassword) {
      return htmlPage("Bootstrap error", `<h1>Bootstrap error</h1><p class="err">Missing required fields.</p>`);
    }

    if ((env.BOOTSTRAP_TOKEN || "").trim() !== bootstrapToken) {
      return htmlPage("Bootstrap error", `<h1>Bootstrap error</h1><p class="err">Invalid bootstrap token.</p>`);
    }

    const orgRow = await dbFirst(
      env,
      "INSERT INTO orgs (name, created_at) VALUES (?, datetime('now')) RETURNING id",
      [orgName]
    );
    const orgId = orgRow.id;

    const locRow = await dbFirst(
      env,
      "INSERT INTO locations (org_id, name, created_at) VALUES (?, ?, datetime('now')) RETURNING id",
      [orgId, locationName]
    );
    const locationId = locRow.id;

    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iters = 100000;
    const hash = await pbkdf2Hash(adminPassword, salt, iters);
    const saltB64 = base64FromBytes(salt);
    const hashB64 = base64FromBytes(hash);

    const userRow = await dbFirst(
      env,
      `INSERT INTO users (org_id, email, full_name, role, pass_salt_b64, pass_hash_b64, pass_iters, is_active, default_location_id, created_at)
       VALUES (?, ?, ?, 'admin', ?, ?, ?, 1, ?, datetime('now'))
       RETURNING id`,
      [orgId, adminEmail, adminFullName, saltB64, hashB64, iters, locationId]
    );
    const userId = userRow.id;

    await writeAudit(env, orgId, userId, "BOOTSTRAP_CREATE", "org", String(orgId), { org_name: orgName });
    await writeAudit(env, orgId, userId, "BOOTSTRAP_CREATE", "location", String(locationId), { location_name: locationName });
    await writeAudit(env, orgId, userId, "BOOTSTRAP_CREATE", "user", String(userId), { email: adminEmail, role: "admin", default_location_id: locationId });

    return htmlPage(
      "Bootstrap complete",
      `<h1>Bootstrap complete</h1>
<div class="card">
  <p class="ok">Created org, location, and admin user.</p>
  <p><b>Org ID:</b> ${orgId}</p>
  <p><b>Location ID:</b> ${locationId}</p>
  <p><b>Admin Email:</b> ${escapeHtml(adminEmail)}</p>
  <p>Next: log in via <code>POST /auth/login</code>.</p>
</div>`
    );
  } catch (e) {
    return htmlPage(
      "Bootstrap error",
      `<h1>Bootstrap error</h1>
<p class="err">The Worker caught an exception.</p>
<pre style="white-space:pre-wrap;background:#f6f6f6;padding:12px;border-radius:10px;border:1px solid #ddd;">${escapeHtml(e && (e.stack || e.message || String(e)))}</pre>`
    );
  }
}

async function handleLogin(request, env, corsOkHeaders) {
  const body = await readJson(request);
  const email = (body.email || "").trim().toLowerCase();
  const password = (body.password || "").trim();

  if (!email || !password) {
    return jsonResponse({ ok: false, error: "Missing email or password" }, 400, corsOkHeaders);
  }

  const user = await dbFirst(
    env,
    `SELECT id, org_id, email, full_name, role, pass_salt_b64, pass_hash_b64, pass_iters, is_active, default_location_id
     FROM users WHERE email = ?`,
    [email]
  );

  if (!user || user.is_active !== 1) {
    return jsonResponse({ ok: false, error: "Invalid credentials" }, 401, corsOkHeaders);
  }

  const saltBytes = bytesFromBase64(user.pass_salt_b64);
  const derived = await pbkdf2Hash(password, saltBytes, user.pass_iters);
  const stored = bytesFromBase64(user.pass_hash_b64);

  if (!constantTimeEqual(derived, stored)) {
    return jsonResponse({ ok: false, error: "Invalid credentials" }, 401, corsOkHeaders);
  }

  const locId = user.default_location_id ? Number(user.default_location_id) : null;
  if (!locId) return jsonResponse({ ok: false, error: "Account has no assigned location" }, 403, corsOkHeaders);

  const loc = await dbFirst(env, "SELECT id, name FROM locations WHERE id = ? AND org_id = ?", [locId, user.org_id]);
  if (!loc) return jsonResponse({ ok: false, error: "Assigned location invalid" }, 403, corsOkHeaders);

  const ttl = parseInt(env.SESSION_TTL_SECONDS || "2592000", 10);
  const tokenRaw = crypto.getRandomValues(new Uint8Array(32));
  const token = base64UrlFromBytes(tokenRaw);
  const tokenHashB64 = await sha256B64FromString(token);
  const exp = new Date(Date.now() + ttl * 1000).toISOString();

  await dbRun(
    env,
    "INSERT INTO sessions (user_id, token_hash_b64, expires_at, created_at) VALUES (?, ?, ?, datetime('now'))",
    [user.id, tokenHashB64, exp]
  );

  await writeAudit(env, user.org_id, user.id, "LOGIN", "user", String(user.id), { email: user.email });

  return jsonResponse(
    {
      ok: true,
      token,
      user: {
        id: user.id,
        org_id: user.org_id,
        email: user.email,
        full_name: user.full_name,
        role: user.role,
        location_id: loc.id,
        location_name: loc.name,
        org_name: (await dbFirst(env, "SELECT name FROM orgs WHERE id = ?", [user.org_id]))?.name || ""
      }
    },
    200,
    corsOkHeaders
  );
}

async function handleMe(env, corsOkHeaders, authUser) {
  return jsonResponse({ ok: true, user: authUser }, 200, corsOkHeaders);
}

function isValidYmd(s) {
  return /^\d{4}-\d{2}-\d{2}$/.test(String(s || "").trim());
}

function isValidYm(s) {
  return /^\d{4}-\d{2}$/.test(String(s || "").trim());
}

function isValidHm(s) {
  return /^([01]\d|2[0-3]):[0-5]\d$/.test(String(s || "").trim());
}

async function ensureEndOfDaySchema(env) { await dbRun(env, "CREATE TABLE IF NOT EXISTS end_of_day (id INTEGER PRIMARY KEY AUTOINCREMENT, org_id INTEGER NOT NULL, location_id INTEGER NOT NULL, eod_date TEXT NOT NULL, time_of_day TEXT NOT NULL DEFAULT 'AM', staff_name TEXT NOT NULL, float_amount REAL NOT NULL DEFAULT 500, x_json TEXT NOT NULL DEFAULT '[]', epos_json TEXT NOT NULL DEFAULT '[]', cheques_json TEXT NOT NULL DEFAULT '[]', paid_outs_json TEXT NOT NULL DEFAULT '[]', cash_json TEXT NOT NULL DEFAULT '{}', bov_deposit_json TEXT NOT NULL DEFAULT '{}', bov_bag_number TEXT NOT NULL DEFAULT '', bov_contact_id INTEGER, notes TEXT NOT NULL DEFAULT '', saved_at TEXT, locked_at TEXT, created_at TEXT NOT NULL DEFAULT (datetime('now')), updated_at TEXT NOT NULL DEFAULT (datetime('now')), created_by INTEGER, updated_by INTEGER, UNIQUE(org_id, location_id, eod_date))", []); await dbRun(env, "CREATE TABLE IF NOT EXISTS end_of_day_contacts (id INTEGER PRIMARY KEY AUTOINCREMENT, org_id INTEGER NOT NULL, location_id INTEGER NOT NULL, display_name TEXT NOT NULL, phone TEXT NOT NULL DEFAULT '', email TEXT NOT NULL DEFAULT '', is_active INTEGER NOT NULL DEFAULT 1, created_at TEXT NOT NULL DEFAULT (datetime('now')), updated_at TEXT NOT NULL DEFAULT (datetime('now')), created_by INTEGER, updated_by INTEGER, UNIQUE(org_id, location_id, display_name))", []); await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_end_of_day_org_loc_date ON end_of_day (org_id, location_id, eod_date)", []); await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_end_of_day_contacts_org_loc_active ON end_of_day_contacts (org_id, location_id, is_active, display_name)", []); try { await dbRun(env, "ALTER TABLE end_of_day_contacts ADD COLUMN email TEXT NOT NULL DEFAULT ''", []); } catch (e) { /* column may already exist */ } }

function clampToOneDecimal(n) {
  if (n === null || n === undefined) return null;
  if (n === "") return null;
  const v = Number(n);
  if (!Number.isFinite(v)) return null;
  return Math.round(v * 10) / 10;
}

function monthRange(yyyyMm) {
  const m = String(yyyyMm || "").trim();
  if (!/^\d{4}-\d{2}$/.test(m)) return null;
  const [y, mo] = m.split("-").map(n => parseInt(n, 10));
  const start = new Date(Date.UTC(y, mo - 1, 1));
  const end = new Date(Date.UTC(y, mo, 1));
  return {
    startStr: start.toISOString().slice(0, 10),
    endStr: end.toISOString().slice(0, 10)
  };
}

async function ensureDefaultTempDevicesIfMissing(env, authUser) {
  const existing = await dbAll(
    env,
    "SELECT id FROM temperature_devices WHERE org_id = ? AND location_id = ? AND active = 1",
    [authUser.org_id, authUser.location_id]
  );
  if (existing.length > 0) return;

  if (!requireRole(authUser, ["admin"])) return;

  const defaults = [
    { name: "Pharmacy", device_type: "room", min_limit: 15, max_limit: 25 },
    { name: "Pharmacy Fridge", device_type: "fridge", min_limit: 2, max_limit: 8 }
  ];

  for (const d of defaults) {
    await dbRun(
      env,
      `INSERT INTO temperature_devices (org_id, location_id, name, device_type, min_limit, max_limit, active, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, 1, datetime('now'), datetime('now'))`,
      [authUser.org_id, authUser.location_id, d.name, d.device_type, d.min_limit, d.max_limit]
    );
  }

  await writeAudit(env, authUser.org_id, authUser.user_id, "TEMP_DEFAULT_DEVICES_CREATE", "location", String(authUser.location_id), {});
}

async function handleTempDevicesList(request, env, corsOkHeaders, authUser) {
  await ensureDefaultTempDevicesIfMissing(env, authUser);

  const includeInactive = (new URL(request.url)).searchParams.get("include_inactive") === "1";

  const devices = await dbAll(
    env,
    `SELECT id, name, device_type, min_limit, max_limit, active, created_at, updated_at
     FROM temperature_devices
     WHERE org_id = ? AND location_id = ?
       ${includeInactive ? "" : "AND active = 1"}
     ORDER BY active DESC, id ASC`,
    [authUser.org_id, authUser.location_id]
  );

  return jsonResponse({ ok: true, devices }, 200, corsOkHeaders);
}

async function handleTempDevicesCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const body = await readJson(request);
  const name = (body.name || "").trim();
  const deviceType = (body.device_type || "other").trim();
  const minLimit = body.min_limit === null || body.min_limit === undefined ? null : Number(body.min_limit);
  const maxLimit = body.max_limit === null || body.max_limit === undefined ? null : Number(body.max_limit);

  if (!name) return jsonResponse({ ok: false, error: "Missing name" }, 400, corsOkHeaders);
  if (!["room", "fridge", "other"].includes(deviceType)) return jsonResponse({ ok: false, error: "Invalid device_type" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO temperature_devices (org_id, location_id, name, device_type, min_limit, max_limit, active, created_at, updated_at)
     VALUES (?, ?, ?, ?, ?, ?, 1, datetime('now'), datetime('now'))
     RETURNING id`,
    [authUser.org_id, authUser.location_id, name, deviceType, minLimit, maxLimit]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "TEMP_DEVICE_CREATE", "temperature_devices", String(row.id), { name, device_type: deviceType });

  return jsonResponse({ ok: true, device_id: row.id }, 200, corsOkHeaders);
}

async function handleTempDevicesUpdate(request, env, corsOkHeaders, authUser, deviceId) {
  if (!requireRole(authUser, ["admin"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const body = await readJson(request);
  const name = body.name !== undefined ? String(body.name || "").trim() : undefined;
  const deviceType = body.device_type !== undefined ? String(body.device_type || "").trim() : undefined;
  const minLimit = body.min_limit !== undefined ? (body.min_limit === null ? null : Number(body.min_limit)) : undefined;
  const maxLimit = body.max_limit !== undefined ? (body.max_limit === null ? null : Number(body.max_limit)) : undefined;
  const active = body.active !== undefined ? (body.active ? 1 : 0) : undefined;

  const existing = await dbFirst(
    env,
    `SELECT id, name, device_type, min_limit, max_limit, active
     FROM temperature_devices
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [deviceId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const newName = name !== undefined ? name : existing.name;
  const newType = deviceType !== undefined ? deviceType : existing.device_type;
  const newMin = minLimit !== undefined ? minLimit : existing.min_limit;
  const newMax = maxLimit !== undefined ? maxLimit : existing.max_limit;
  const newActive = active !== undefined ? active : existing.active;

  if (!newName) return jsonResponse({ ok: false, error: "Name cannot be empty" }, 400, corsOkHeaders);
  if (!["room", "fridge", "other"].includes(newType)) return jsonResponse({ ok: false, error: "Invalid device_type" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE temperature_devices
     SET name = ?, device_type = ?, min_limit = ?, max_limit = ?, active = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [newName, newType, newMin, newMax, newActive, deviceId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "TEMP_DEVICE_UPDATE", "temperature_devices", String(deviceId), {
    name: newName,
    device_type: newType,
    min_limit: newMin,
    max_limit: newMax,
    active: newActive
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function assertDeviceBelongsActive(env, orgId, locationId, deviceId) {
  const row = await dbFirst(
    env,
    `SELECT id, name, device_type, min_limit, max_limit, active
     FROM temperature_devices
     WHERE id = ? AND org_id = ? AND location_id = ? AND active = 1`,
    [deviceId, orgId, locationId]
  );
  return row || null;
}

async function handleTempEntriesList(request, env, corsOkHeaders, authUser, url) {
  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const entries = await dbAll(
    env,
    `SELECT
       e.id,
       e.entry_date,
       e.min_temp,
       e.max_temp,
       e.notes,
       e.created_by,
       e.created_at,
       e.updated_at,
       d.id AS device_id,
       d.name AS device_name,
       d.device_type,
       d.min_limit,
       d.max_limit,
       d.active AS device_active
     FROM temperature_entries e
     JOIN temperature_devices d ON d.id = e.device_id
     WHERE e.org_id = ?
       AND e.location_id = ?
       AND e.entry_date >= ?
       AND e.entry_date < ?
     ORDER BY e.entry_date DESC, d.id ASC`,
    [authUser.org_id, authUser.location_id, range.startStr, range.endStr]
  );

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleTempEntriesUpsert(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDefaultTempDevicesIfMissing(env, authUser);

  const body = await readJson(request);
  const deviceId = parseInt(body.device_id, 10);
  const entryDate = (body.entry_date || "").trim();
  const minTemp = clampToOneDecimal(body.min_temp);
  const maxTemp = clampToOneDecimal(body.max_temp);
  const notes = (body.notes || "").trim();

  if (!deviceId) return jsonResponse({ ok: false, error: "Missing device_id" }, 400, corsOkHeaders);
  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);

  const dev = await assertDeviceBelongsActive(env, authUser.org_id, authUser.location_id, deviceId);
  if (!dev) return jsonResponse({ ok: false, error: "Invalid device" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO temperature_entries
       (org_id, location_id, device_id, entry_date, min_temp, max_temp, notes, created_by, created_at, updated_at)
     VALUES
       (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     ON CONFLICT(org_id, location_id, device_id, entry_date)
     DO UPDATE SET
       min_temp = excluded.min_temp,
       max_temp = excluded.max_temp,
       notes = excluded.notes,
       updated_at = datetime('now')
     RETURNING id`,
    [authUser.org_id, authUser.location_id, deviceId, entryDate, minTemp, maxTemp, notes, authUser.user_id]
  );

  await dbRun(
    env,
    `INSERT INTO sync_jobs (org_id, module, op, payload_json, status, attempts, next_run_at, created_at, updated_at)
     VALUES (?, 'temperature', 'upsert_entry', ?, 'pending', 0, datetime('now'), datetime('now'), datetime('now'))`,
    [authUser.org_id, JSON.stringify({ entry_id: row.id })]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "TEMP_ENTRY_UPSERT", "temperature_entries", String(row.id), {
    entry_date: entryDate,
    device_id: deviceId,
    min_temp: minTemp,
    max_temp: maxTemp
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleTempEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const existing = await dbFirst(
    env,
    `SELECT id, device_id, entry_date
     FROM temperature_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM temperature_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await dbRun(
    env,
    `INSERT INTO sync_jobs (org_id, module, op, payload_json, status, attempts, next_run_at, created_at, updated_at)
     VALUES (?, 'temperature', 'delete_entry', ?, 'pending', 0, datetime('now'), datetime('now'), datetime('now'))`,
    [authUser.org_id, JSON.stringify({ entry_id: entryId })]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "TEMP_ENTRY_DELETE", "temperature_entries", String(entryId), {
    entry_date: existing.entry_date,
    device_id: existing.device_id
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleTempReport(request, env, corsOkHeaders, authUser, url) {
  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();
  if (!isValidYmd(from) || !isValidYmd(to)) {
    return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (to < from) {
    return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
  }

  const devices = await dbAll(
    env,
    `SELECT d.id, d.name, d.device_type, d.min_limit, d.max_limit, d.active
     FROM temperature_devices d
     WHERE d.org_id = ? AND d.location_id = ?
       AND (
         d.active = 1
         OR EXISTS (
           SELECT 1 FROM temperature_entries e
           WHERE e.device_id = d.id
             AND e.org_id = d.org_id
             AND e.location_id = d.location_id
             AND e.entry_date >= ?
             AND e.entry_date <= ?
         )
       )
     ORDER BY d.id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  const entries = await dbAll(
    env,
    `SELECT id, entry_date, device_id, min_temp, max_temp, notes
     FROM temperature_entries
     WHERE org_id = ? AND location_id = ?
       AND entry_date >= ?
       AND entry_date <= ?
     ORDER BY entry_date ASC, device_id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  return jsonResponse(
    {
      ok: true,
      org_name: authUser.org_name,
      location_name: authUser.location_name,
      from,
      to,
      devices,
      entries
    },
    200,
    corsOkHeaders
  );
}

function ymFromYmd(ymd) {
  return String(ymd || "").slice(0, 7);
}

function htmlReportPage(title, htmlBody) {
  return new Response(
    `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>${escapeHtml(title)}</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:22px;color:#111;}
  h1{margin:0 0 6px 0;font-size:20px;}
  .meta{color:#444;margin:0 0 16px 0;font-size:13px;}
  h2{margin:18px 0 8px 0;font-size:16px;}
  table{width:100%;border-collapse:collapse;margin-top:8px;}
  th,td{border:1px solid #bbb;padding:6px 8px;font-size:12px;vertical-align:top;}
  th{background:#f2f2f2;}
  .small{font-size:11px;color:#444;}
  @media print{
    .no-print{display:none;}
    body{margin:0;}
  }
</style>
</head>
<body>
<div class="no-print" style="margin-bottom:10px;">
  <button onclick="window.print()" style="padding:8px 12px;font-weight:700;">Print</button>
</div>
${htmlBody}
</body>
</html>`,
    {
      headers: {
        "Content-Type": "text/html; charset=utf-8",
        "Cache-Control": "no-store"
      }
    }
  );
}

async function handleTempReportHtml(request, env, corsOkHeaders, authUser, url) {
  const out = await handleTempReport(request, env, corsOkHeaders, authUser, url);
  const data = await out.json();

  if (!data.ok) return out;

  const devices = data.devices || [];
  const entries = data.entries || [];

  // Build map by date -> device_id -> {min,max}
  const map = new Map(); // date -> Map(device_id -> cell)
  for (const e of entries) {
    const d = e.entry_date;
    if (!map.has(d)) map.set(d, new Map());
    map.get(d).set(Number(e.device_id), {
      min: e.min_temp,
      max: e.max_temp
    });
  }

  // Group dates by month
  const dates = Array.from(map.keys()).sort();
  const byMonth = new Map();
  for (const d of dates) {
    const ym = ymFromYmd(d);
    if (!byMonth.has(ym)) byMonth.set(ym, []);
    byMonth.get(ym).push(d);
  }

  let body = "";
  body += `<h1>${escapeHtml(data.org_name || "Pharmacy")} â€” Temperature Report</h1>`;
  body += `<p class="meta">Location: ${escapeHtml(data.location_name || "")}<br/>Range: ${escapeHtml(data.from)} to ${escapeHtml(data.to)}</p>`;

  for (const [ym, dlist] of byMonth.entries()) {
    body += `<h2>${escapeHtml(ym)}</h2>`;
    body += `<table><thead><tr><th>Date</th>`;
    for (const dev of devices) {
      body += `<th>${escapeHtml(dev.name)}<div class="small">${escapeHtml(dev.device_type)}</div></th>`;
    }
    body += `</tr></thead><tbody>`;
    for (const d of dlist) {
      body += `<tr><td>${escapeHtml(d)}</td>`;
      const rowMap = map.get(d) || new Map();
      for (const dev of devices) {
        const cell = rowMap.get(Number(dev.id));
        if (!cell) body += `<td></td>`;
        else {
          const min = (cell.min === null || cell.min === undefined) ? "" : Number(cell.min).toFixed(1);
          const max = (cell.max === null || cell.max === undefined) ? "" : Number(cell.max).toFixed(1);
          body += `<td>${escapeHtml(min)}${min && max ? " / " : ""}${escapeHtml(max)}</td>`;
        }
      }
      body += `</tr>`;
    }
    body += `</tbody></table>`;
  }

  return htmlReportPage("Temperature Report", body);
}

/* =========================
   CLIENT ORDERS MODULE (API)
   ========================= */

async function ensureClientOrdersSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS client_orders_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,

      order_date TEXT NOT NULL,               -- YYYY-MM-DD
      client_name TEXT NOT NULL,
      client_phone TEXT NOT NULL DEFAULT '',
      client_alt_phone TEXT NOT NULL DEFAULT '',
      client_email TEXT NOT NULL DEFAULT '',
      client_address TEXT NOT NULL DEFAULT '',

      items_text TEXT NOT NULL,               -- free text (what they ordered)
      priority INTEGER NOT NULL DEFAULT 2,     -- 1=high,2=normal,3=low
      needed_by TEXT,                         -- YYYY-MM-DD or NULL
      pickup_date TEXT,                       -- YYYY-MM-DD or NULL
      deposit_amount REAL NOT NULL DEFAULT 0,  -- optional

      fulfilled INTEGER NOT NULL DEFAULT 0,    -- 0/1
      fulfilled_at TEXT,                      -- datetime when marked fulfilled

      notes TEXT NOT NULL DEFAULT '',

      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_client_orders_org_loc_date ON client_orders_entries (org_id, location_id, order_date)",
    []
  );
  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_client_orders_org_loc_fulfilled ON client_orders_entries (org_id, location_id, fulfilled, order_date)",
    []
  );
  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_client_orders_org_loc_client ON client_orders_entries (org_id, location_id, client_name)",
    []
  );
  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_client_orders_org_loc_priority ON client_orders_entries (org_id, location_id, priority)",
    []
  );

  // Backfill schema for existing deployments (safe if column already exists)
  const adds = [
    "ALTER TABLE client_orders_entries ADD COLUMN client_phone TEXT NOT NULL DEFAULT ''",
    "ALTER TABLE client_orders_entries ADD COLUMN client_alt_phone TEXT NOT NULL DEFAULT ''",
    "ALTER TABLE client_orders_entries ADD COLUMN client_email TEXT NOT NULL DEFAULT ''",
    "ALTER TABLE client_orders_entries ADD COLUMN client_address TEXT NOT NULL DEFAULT ''",
    "ALTER TABLE client_orders_entries ADD COLUMN items_text TEXT NOT NULL DEFAULT ''",
    "ALTER TABLE client_orders_entries ADD COLUMN pickup_date TEXT",
    "ALTER TABLE client_orders_entries ADD COLUMN deposit_amount REAL NOT NULL DEFAULT 0"
  ];

  for (const sql of adds) {
    try { await dbRun(env, sql, []); } catch (e) { /* ignore duplicate column */ }
  }

}

function normalizePriority(p) {
  const n = Number(p);
  if (!Number.isFinite(n)) return 2;
  const i = Math.floor(n);
  if (i === 1 || i === 2 || i === 3) return i;
  return 2;
}

function normalizeMoney(n) {
  if (n === null || n === undefined || n === "") return 0;
  const v = Number(n);
  if (!Number.isFinite(v) || v < 0) return null;
  // keep 2dp-ish
  return Math.round(v * 100) / 100;
}

function normalizeMaybeYmd(s) {
  const t = String(s ?? "").trim();
  if (!t) return null;
  return isValidYmd(t) ? t : "__INVALID__";
}

function clientOrderRowToUi(r) {
  if (!r) return r;
  const phone = r.client_phone || "";
  const alt = r.client_alt_phone || "";
  const email = r.client_email || "";
  const addr = r.client_address || "";
  const items = r.items_text || "";
  const orderDate = r.order_date || "";
  const pickup = r.pickup_date || null;
  const deposit = (r.deposit_amount === null || r.deposit_amount === undefined) ? 0 : r.deposit_amount;

  return {
    // DB names (keep for compatibility)
    ...r,

    // UI aliases (what your front-end likely expects)
    entry_date: orderDate,
    contact: phone,
    alternate: alt,
    email,
    address: addr,
    items,
    pick_up_date: pickup,
    deposit
  };
}

async function handleClientOrdersEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureClientOrdersSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  // fulfilled filter: "0", "1", or omit for all
  const fulfilledParam = (url.searchParams.get("fulfilled") || "").trim();
  const hasFulfilled = fulfilledParam === "0" || fulfilledParam === "1";
  const fulfilledVal = hasFulfilled ? Number(fulfilledParam) : null;

  const sql = `
    SELECT
      id,
      order_date,
      client_name,
      client_phone,
      client_alt_phone,
      client_email,
      client_address,
      items_text,
      priority,
      needed_by,
      pickup_date,
      deposit_amount,
      fulfilled,
      fulfilled_at,
      notes,
      created_by,
      created_at,
      updated_at
    FROM client_orders_entries
    WHERE org_id = ?
      AND location_id = ?
      AND order_date >= ?
      AND order_date < ?
      ${hasFulfilled ? "AND fulfilled = ?" : ""}
      ${hasQ ? `AND (
        order_date LIKE ?
        OR client_name LIKE ?
        OR client_phone LIKE ?
        OR client_email LIKE ?
        OR client_address LIKE ?
        OR items_text LIKE ?
        OR notes LIKE ?
      )` : ""}
    ORDER BY fulfilled ASC, order_date DESC, priority ASC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id, range.startStr, range.endStr];
  if (hasFulfilled) bind.push(fulfilledVal);
  if (hasQ) bind.push(qLike, qLike, qLike, qLike, qLike, qLike, qLike);

  const rows = await dbAll(env, sql, bind);
  const entries = rows.map(clientOrderRowToUi);
  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleClientOrdersEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureClientOrdersSchema(env);

  const body = await readJson(request);

  const orderDate = String(body.order_date || body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientPhone = String(body.client_phone || "").trim();
  const clientAltPhone = String(body.client_alt_phone ?? body.alternate ?? "").trim();
  const clientEmail = String(body.client_email || "").trim();
  const clientAddress = String(body.client_address || "").trim();
  const itemsText = String(body.items_text || body.items || "").trim();
  const priority = normalizePriority(body.priority);
  const neededBy = normalizeMaybeYmd(body.needed_by);
  const pickupDate = normalizeMaybeYmd(body.pickup_date);
  const depositAmount = normalizeMoney(body.deposit_amount);
  const fulfilled = body.fulfilled ? 1 : 0;
  const notes = String(body.notes || "").trim();

  if (!isValidYmd(orderDate)) return jsonResponse({ ok: false, error: "Invalid order_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!itemsText) return jsonResponse({ ok: false, error: "Missing items_text" }, 400, corsOkHeaders);

  if (neededBy === "__INVALID__") return jsonResponse({ ok: false, error: "Invalid needed_by (YYYY-MM-DD or empty)" }, 400, corsOkHeaders);
  if (pickupDate === "__INVALID__") return jsonResponse({ ok: false, error: "Invalid pickup_date (YYYY-MM-DD or empty)" }, 400, corsOkHeaders);
  if (depositAmount === null) return jsonResponse({ ok: false, error: "Invalid deposit_amount (>= 0)" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO client_orders_entries
    (org_id, location_id, order_date, client_name, client_phone, client_alt_phone, client_email, client_address,
    items_text, priority, needed_by, pickup_date, deposit_amount,
    fulfilled, fulfilled_at, notes, created_by, created_at, updated_at)
     VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CASE WHEN ? THEN datetime('now') ELSE NULL END, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [
      authUser.org_id,
      authUser.location_id,
      orderDate,
      clientName,
      clientPhone,
      clientAltPhone,
      clientEmail,
      clientAddress,
      itemsText,
      priority,
      neededBy,
      pickupDate,
      depositAmount,
      fulfilled,
      fulfilled ? 1 : 0,
      notes,
      authUser.user_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CLIENT_ORDER_CREATE", "client_orders_entries", String(row.id), {
    order_date: orderDate,
    client_name: clientName,
    priority,
    fulfilled
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleClientOrdersEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureClientOrdersSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id, fulfilled
     FROM client_orders_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const orderDate = String(body.order_date || body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientAltPhone = String(body.client_alt_phone ?? body.alternate ?? "").trim();
  const clientPhone = String(body.client_phone || "").trim();
  const clientEmail = String(body.client_email || "").trim();
  const clientAddress = String(body.client_address || "").trim();
  const itemsText = String(body.items_text || body.items || "").trim();
  const priority = normalizePriority(body.priority);
  const neededBy = normalizeMaybeYmd(body.needed_by);
  const pickupDate = normalizeMaybeYmd(body.pickup_date);
  const depositAmount = normalizeMoney(body.deposit_amount);
  const fulfilled = body.fulfilled ? 1 : 0;
  const notes = String(body.notes || "").trim();

  if (!isValidYmd(orderDate)) return jsonResponse({ ok: false, error: "Invalid order_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!itemsText) return jsonResponse({ ok: false, error: "Missing items_text" }, 400, corsOkHeaders);

  if (neededBy === "__INVALID__") return jsonResponse({ ok: false, error: "Invalid needed_by (YYYY-MM-DD or empty)" }, 400, corsOkHeaders);
  if (pickupDate === "__INVALID__") return jsonResponse({ ok: false, error: "Invalid pickup_date (YYYY-MM-DD or empty)" }, 400, corsOkHeaders);
  if (depositAmount === null) return jsonResponse({ ok: false, error: "Invalid deposit_amount (>= 0)" }, 400, corsOkHeaders);

  const wasFulfilled = existing.fulfilled ? 1 : 0;
  const turningOn = (wasFulfilled === 0 && fulfilled === 1);
  const turningOff = (wasFulfilled === 1 && fulfilled === 0);

  await dbRun(
    env,
    `UPDATE client_orders_entries
     SET order_date = ?,
         client_name = ?,
         client_phone = ?,
         client_alt_phone = ?,
         client_email = ?,
         client_address = ?,
         items_text = ?,
         priority = ?,
         needed_by = ?,
         pickup_date = ?,
         deposit_amount = ?,
         fulfilled = ?,
         fulfilled_at = CASE
            WHEN ? THEN datetime('now')
            WHEN ? THEN NULL
            ELSE fulfilled_at
         END,
         notes = ?,
         updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      orderDate,
      clientName,
      clientPhone,
      clientAltPhone,
      clientEmail,
      clientAddress,
      itemsText,
      priority,
      neededBy,
      pickupDate,
      depositAmount,
      fulfilled,
      turningOn ? 1 : 0,
      turningOff ? 1 : 0,
      notes,
      entryId,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CLIENT_ORDER_UPDATE", "client_orders_entries", String(entryId), {
    order_date: orderDate,
    client_name: clientName,
    priority,
    fulfilled
  });

  // Optional: add explicit audit for fulfill/unfulfill if you want
  if (turningOn) {
    await writeAudit(env, authUser.org_id, authUser.user_id, "CLIENT_ORDER_FULFILLED", "client_orders_entries", String(entryId), {});
  } else if (turningOff) {
    await writeAudit(env, authUser.org_id, authUser.user_id, "CLIENT_ORDER_UNFULFILLED", "client_orders_entries", String(entryId), {});
  }

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleClientOrdersEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureClientOrdersSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id, order_date, client_name
     FROM client_orders_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM client_orders_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CLIENT_ORDER_DELETE", "client_orders_entries", String(entryId), {
    order_date: existing.order_date,
    client_name: existing.client_name
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

/* =========================
   END OF DAY (EOD) MODULE (API)
   ========================= */

function eodRowToUi(row) {
  if (!row) return null;
  function safeParse(s, fallback) { try { return JSON.parse(s); } catch (e) { return fallback; } }
  return {
    id: row.id,
    date: row.eod_date,
    eod_date: row.eod_date,
    time_of_day: row.time_of_day || "AM",
    staff: row.staff_name || "",
    staff_name: row.staff_name || "",
    float_amount: row.float_amount != null ? String(row.float_amount) : "500",
    x: safeParse(row.x_json, []),
    epos: safeParse(row.epos_json, []),
    cheques: safeParse(row.cheques_json, []),
    paid_outs: safeParse(row.paid_outs_json, []),
    cash: safeParse(row.cash_json, {}),
    deposit: safeParse(row.bov_deposit_json, {}),
    bov_deposit: safeParse(row.bov_deposit_json, {}),
    bag_number: row.bov_bag_number || "",
    bov_bag_number: row.bov_bag_number || "",
    contact_id: row.bov_contact_id != null ? String(row.bov_contact_id) : "",
    bov_contact_id: row.bov_contact_id,
    notes: row.notes || "",
    saved_at: row.saved_at || "",
    locked_at: row.locked_at || "",
    created_at: row.created_at || "",
    updated_at: row.updated_at || "",
    location_name: row.location_name || "",
    org_id: row.org_id,
    location_id: row.location_id
  };
}

async function handleEodGet(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);
  const date = String(url.searchParams.get("date") || "").trim();
  if (!isValidYmd(date)) return jsonResponse({ ok: false, error: "Invalid date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  const row = await dbFirst(env, "SELECT e.*, l.name AS location_name FROM end_of_day e LEFT JOIN locations l ON l.id = e.location_id AND l.org_id = e.org_id WHERE e.org_id = ? AND e.location_id = ? AND e.eod_date = ?", [authUser.org_id, authUser.location_id, date]);
  const uiRow = eodRowToUi(row);
  if (uiRow && !uiRow.location_name && authUser.location_name) uiRow.location_name = authUser.location_name;
  return jsonResponse({ ok: true, eod: uiRow, record: uiRow, item: uiRow }, 200, corsOkHeaders);
}

async function handleEodUpsert(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureEndOfDaySchema(env);

  let body = await readJson(request); // UI sends { record: { ... } }
  if (body && typeof body === "object" && body.record && typeof body.record === "object") {
    body = body.record;
  }

  const date = String(body.eod_date || body.date || "").trim();
  if (!isValidYmd(date)) {
    return jsonResponse({ ok: false, error: "Invalid date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }

  // Read locked_at intent (explicit)
  const hasLockedAtField =
    body &&
    typeof body === "object" &&
    (Object.prototype.hasOwnProperty.call(body, "locked_at") ||
      Object.prototype.hasOwnProperty.call(body, "lockedAt"));

  const lockedAtRaw = hasLockedAtField
    ? (Object.prototype.hasOwnProperty.call(body, "locked_at") ? body.locked_at : body.lockedAt)
    : undefined;

  const wantsLock = !!(lockedAtRaw && String(lockedAtRaw).trim());

  // Load existing early so we can allow UNLOCK without requiring staff/float validation
  const existing = await dbFirst(
    env,
    "SELECT id, locked_at FROM end_of_day WHERE org_id = ? AND location_id = ? AND eod_date = ?",
    [authUser.org_id, authUser.location_id, date]
  );

  const wantsUnlock =
    !!(existing && existing.locked_at) &&
    (
      lockedAtRaw === "" ||
      lockedAtRaw === null ||
      body.unlock === true ||
      body.action === "UNLOCK"
    );

  // âœ… PATCH: allow explicit unlock for locked records
  if (existing && existing.locked_at) {
    if (wantsUnlock) {
      await dbRun(
        env,
        `UPDATE end_of_day
         SET locked_at = NULL,
             updated_at = datetime('now'),
             updated_by = ?
         WHERE id = ? AND org_id = ? AND location_id = ?`,
        [authUser.user_id, existing.id, authUser.org_id, authUser.location_id]
      );

      await writeAudit(
        env,
        authUser.org_id,
        authUser.user_id,
        "EOD_UNLOCK",
        "end_of_day",
        String(existing.id),
        { eod_date: date }
      );

      const row = await dbFirst(
        env,
        "SELECT e.*, l.name AS location_name FROM end_of_day e LEFT JOIN locations l ON l.id = e.location_id AND l.org_id = e.org_id WHERE e.org_id = ? AND e.location_id = ? AND e.eod_date = ?",
        [authUser.org_id, authUser.location_id, date]
      );
      const uiRow = eodRowToUi(row);
      if (uiRow && !uiRow.location_name && authUser.location_name) uiRow.location_name = authUser.location_name;

      return jsonResponse({ ok: true, eod: uiRow, record: uiRow, item: uiRow }, 200, corsOkHeaders);
    }

    // idempotent lock call: return existing locked state
    if (wantsLock) {
      return jsonResponse({ ok: true, id: existing.id, locked_at: existing.locked_at }, 200, corsOkHeaders);
    }

    // still block normal updates while locked
    return jsonResponse({ ok: false, error: "Locked - cannot update" }, 409, corsOkHeaders);
  }

  // Normal validation for create/update (unlocked)
  const staffName = String(body.staff_name || body.staff || "").trim();
  const floatAmount = Number(body.float_amount ?? body.float ?? body.floatAmount ?? 500);

  if (!staffName) {
    return jsonResponse({ ok: false, error: "Missing staff/staff_name" }, 400, corsOkHeaders);
  }
  if (!Number.isFinite(floatAmount) || floatAmount < 0) {
    return jsonResponse({ ok: false, error: "Invalid float_amount (>= 0)" }, 400, corsOkHeaders);
  }

  const timeOfDay = String(body.time_of_day || "AM").trim() || "AM";

  const xJson = JSON.stringify(Array.isArray(body.x) ? body.x : []);
  const eposJson = JSON.stringify(Array.isArray(body.epos) ? body.epos : []);
  const chequesJson = JSON.stringify(Array.isArray(body.cheques) ? body.cheques : []);
  const paidOutsJson = JSON.stringify(Array.isArray(body.paid_outs) ? body.paid_outs : []);
  const cashJson = JSON.stringify(body.cash && typeof body.cash === "object" ? body.cash : {});

  const bovDeposit = body.bov_deposit || body.deposit || {};
  const bovDepositJson = JSON.stringify(bovDeposit && typeof bovDeposit === "object" ? bovDeposit : {});
  const bovBagNumber = String(body.bov_bag_number || body.bag_number || "").trim();
  const bovContactId = body.bov_contact_id != null ? body.bov_contact_id : (body.contact_id != null ? body.contact_id : null);

  const notes = String(body.notes || "").trim();

  // Insert or update
  if (!existing) {
    const row = await dbFirst(
      env,
      `INSERT INTO end_of_day
       (org_id, location_id, eod_date, time_of_day, staff_name, float_amount,
        x_json, epos_json, cheques_json, paid_outs_json, cash_json,
        bov_deposit_json, bov_bag_number, bov_contact_id, notes,
        saved_at, locked_at, created_at, updated_at, updated_by)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), CASE WHEN ? THEN datetime('now') ELSE NULL END, datetime('now'), datetime('now'), ?)
       RETURNING id`,
      [
        authUser.org_id, authUser.location_id, date, timeOfDay, staffName, floatAmount,
        xJson, eposJson, chequesJson, paidOutsJson, cashJson,
        bovDepositJson, bovBagNumber || null, bovContactId, notes || null,
        wantsLock ? 1 : 0, // NOTE: kept original behavior pattern
        authUser.user_id
      ]
    );

    await writeAudit(env, authUser.org_id, authUser.user_id, "EOD_CREATE", "end_of_day", String(row.id), { eod_date: date, locked: wantsLock });

  } else {
    await dbRun(
      env,
      `UPDATE end_of_day SET
         time_of_day = ?,
         staff_name = ?,
         float_amount = ?,
         x_json = ?,
         epos_json = ?,
         cheques_json = ?,
         paid_outs_json = ?,
         cash_json = ?,
         bov_deposit_json = ?,
         bov_bag_number = ?,
         bov_contact_id = ?,
         notes = ?,
         saved_at = datetime('now'),
         locked_at = CASE WHEN ? THEN datetime('now') ELSE locked_at END,
         updated_at = datetime('now'),
         updated_by = ?
       WHERE id = ? AND org_id = ? AND location_id = ?`,
      [
        timeOfDay,
        staffName,
        floatAmount,
        xJson,
        eposJson,
        chequesJson,
        paidOutsJson,
        cashJson,
        bovDepositJson,
        bovBagNumber || null,
        bovContactId,
        notes || null,
        wantsLock ? 1 : 0,
        authUser.user_id,
        existing.id,
        authUser.org_id,
        authUser.location_id
      ]
    );

    await writeAudit(env, authUser.org_id, authUser.user_id, wantsLock ? "EOD_LOCK" : "EOD_UPDATE", "end_of_day", String(existing.id), { eod_date: date });
  }

  const row = await dbFirst(
    env,
    "SELECT e.*, l.name AS location_name FROM end_of_day e LEFT JOIN locations l ON l.id = e.location_id AND l.org_id = e.org_id WHERE e.org_id = ? AND e.location_id = ? AND e.eod_date = ?",
    [authUser.org_id, authUser.location_id, date]
  );

  const uiRow = eodRowToUi(row);
  if (uiRow && !uiRow.location_name && authUser.location_name) uiRow.location_name = authUser.location_name;

  return jsonResponse({ ok: true, eod: uiRow, record: uiRow, item: uiRow }, 200, corsOkHeaders);
}

async function handleEodLock(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);

  const body = await readJson(request);
  const date = String(body.eod_date || "").trim();
  if (!isValidYmd(date)) return jsonResponse({ ok: false, error: "Invalid eod_date (YYYY-MM-DD)" }, 400, corsOkHeaders);

  const existing = await dbFirst(env, "SELECT id, locked_at FROM end_of_day WHERE org_id = ? AND location_id = ? AND eod_date = ?", [authUser.org_id, authUser.location_id, date]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
  if (existing.locked_at) return jsonResponse({ ok: true, id: existing.id, locked_at: existing.locked_at }, 200, corsOkHeaders);

  await dbRun(env, "UPDATE end_of_day SET locked_at = datetime('now'), updated_at = datetime('now'), updated_by = ? WHERE id = ? AND org_id = ? AND location_id = ?", [authUser.user_id, existing.id, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "EOD_LOCK", "end_of_day", String(existing.id), { eod_date: date });

  const locked = await dbFirst(env, "SELECT locked_at FROM end_of_day WHERE id = ? AND org_id = ? AND location_id = ?", [existing.id, authUser.org_id, authUser.location_id]);
  return jsonResponse({ ok: true, id: existing.id, locked_at: locked ? locked.locked_at : null }, 200, corsOkHeaders);
}

async function handleEodListDates(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);
  const month = String(url.searchParams.get("month") || "").trim();
  if (!isValidYm(month)) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Invalid month" }, 400, corsOkHeaders);
  const rows = await dbAll(env, "SELECT eod_date FROM end_of_day WHERE org_id = ? AND location_id = ? AND eod_date >= ? AND eod_date < ? ORDER BY eod_date ASC", [authUser.org_id, authUser.location_id, range.startStr, range.endStr]);
  const dates = rows.map(r => r.eod_date);
  return jsonResponse({ ok: true, dates: dates, items: dates, records: dates }, 200, corsOkHeaders);
}

async function handleEodContactsList(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);
  const rows = await dbAll(env, "SELECT id, display_name, phone, email FROM end_of_day_contacts WHERE org_id = ? AND location_id = ? AND is_active = 1 ORDER BY display_name ASC", [authUser.org_id, authUser.location_id]);
  return jsonResponse({ ok: true, contacts: rows }, 200, corsOkHeaders);
}

async function handleEodContactsCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);

  const body = await readJson(request);

  // UI sends { contacts: [...] } for bulk save â€” handle that case
  if (Array.isArray(body.contacts)) {
    return await handleEodContactsBulkSave(body.contacts, env, corsOkHeaders, authUser);
  }

  const name = String(body.display_name || body.name || "").trim();
  const phone = String(body.phone || "").trim();
  const email = String(body.email || "").trim();
  if (!name) return jsonResponse({ ok: false, error: "Missing display_name" }, 400, corsOkHeaders);

  const row = await dbFirst(env, "INSERT INTO end_of_day_contacts (org_id, location_id, display_name, phone, email, is_active, created_at, updated_at, created_by, updated_by) VALUES (?, ?, ?, ?, ?, 1, datetime('now'), datetime('now'), ?, ?) RETURNING id", [authUser.org_id, authUser.location_id, name, phone, email, authUser.user_id, authUser.user_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "EOD_CONTACT_CREATE", "end_of_day_contacts", String(row.id), { display_name: name });

  return jsonResponse({ ok: true, id: row.id }, 200, corsOkHeaders);
}

async function handleEodContactsBulkSave(contacts, env, corsOkHeaders, authUser) {
  // Bulk save: deactivate all existing, then upsert each contact from the UI list
  await ensureEndOfDaySchema(env);

  // Mark all existing contacts inactive
  await dbRun(env, "UPDATE end_of_day_contacts SET is_active = 0, updated_at = datetime('now'), updated_by = ? WHERE org_id = ? AND location_id = ?", [authUser.user_id, authUser.org_id, authUser.location_id]);

  const ids = [];
  for (const c of contacts) {
    const name = String(c.display_name || c.name || "").trim();
    const phone = String(c.phone || "").trim();
    const email = String(c.email || "").trim();
    if (!name) continue;

    // Try to re-activate existing by name, or insert new
    const existing = await dbFirst(env, "SELECT id FROM end_of_day_contacts WHERE org_id = ? AND location_id = ? AND display_name = ?", [authUser.org_id, authUser.location_id, name]);
    if (existing) {
      await dbRun(env, "UPDATE end_of_day_contacts SET phone = ?, email = ?, is_active = 1, updated_at = datetime('now'), updated_by = ? WHERE id = ?", [phone, email, authUser.user_id, existing.id]);
      ids.push(existing.id);
    } else {
      const row = await dbFirst(env, "INSERT INTO end_of_day_contacts (org_id, location_id, display_name, phone, email, is_active, created_at, updated_at, created_by, updated_by) VALUES (?, ?, ?, ?, ?, 1, datetime('now'), datetime('now'), ?, ?) RETURNING id", [authUser.org_id, authUser.location_id, name, phone, email, authUser.user_id, authUser.user_id]);
      ids.push(row.id);
    }
  }

  await writeAudit(env, authUser.org_id, authUser.user_id, "EOD_CONTACTS_BULK_SAVE", "end_of_day_contacts", "", { count: ids.length });
  return jsonResponse({ ok: true, ids: ids }, 200, corsOkHeaders);
}

async function handleEodContactsBulkPut(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);

  const body = await readJson(request);
  const contacts = body.contacts || body;
  if (!Array.isArray(contacts)) return jsonResponse({ ok: false, error: "Expected contacts array" }, 400, corsOkHeaders);
  return await handleEodContactsBulkSave(contacts, env, corsOkHeaders, authUser);
}

async function handleEodContactsUpdate(request, env, corsOkHeaders, authUser, contactId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);

  const existing = await dbFirst(env, "SELECT id FROM end_of_day_contacts WHERE id = ? AND org_id = ? AND location_id = ?", [contactId, authUser.org_id, authUser.location_id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);
  const name = String(body.display_name || body.name || "").trim();
  const phone = String(body.phone || "").trim();
  const email = String(body.email || "").trim();
  if (!name) return jsonResponse({ ok: false, error: "Missing display_name" }, 400, corsOkHeaders);

  await dbRun(env, "UPDATE end_of_day_contacts SET display_name = ?, phone = ?, email = ?, updated_at = datetime('now'), updated_by = ? WHERE id = ? AND org_id = ? AND location_id = ?", [name, phone, email, authUser.user_id, contactId, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "EOD_CONTACT_UPDATE", "end_of_day_contacts", String(contactId), { display_name: name });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleEodContactsDeactivate(request, env, corsOkHeaders, authUser, contactId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureEndOfDaySchema(env);

  const existing = await dbFirst(env, "SELECT id, display_name FROM end_of_day_contacts WHERE id = ? AND org_id = ? AND location_id = ?", [contactId, authUser.org_id, authUser.location_id]);
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(env, "UPDATE end_of_day_contacts SET is_active = 0, updated_at = datetime('now'), updated_by = ? WHERE id = ? AND org_id = ? AND location_id = ?", [authUser.user_id, contactId, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "EOD_CONTACT_DEACTIVATE", "end_of_day_contacts", String(contactId), { display_name: existing.display_name });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

/* =========================
   CLEANING MODULE (API)
   ========================= */

async function handleCleaningEntriesList(request, env, corsOkHeaders, authUser, url) {
  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       time_in,
       time_out,
       cleaner_name,
       staff_name,
       notes,
       created_by,
       created_at,
       updated_at
     FROM cleaning_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date < ?
     ORDER BY entry_date DESC, time_in DESC, id DESC`,
    [authUser.org_id, authUser.location_id, range.startStr, range.endStr]
  );

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleCleaningEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const timeIn = String(body.time_in || "").trim();
  const timeOut = String(body.time_out || "").trim();
  const cleanerName = String(body.cleaner_name || "").trim();
  const staffName = String(body.staff_name || "").trim();
  const notes = String(body.notes || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!isValidHm(timeIn)) return jsonResponse({ ok: false, error: "Invalid time_in (HH:mm)" }, 400, corsOkHeaders);
  if (timeOut && !isValidHm(timeOut)) return jsonResponse({ ok: false, error: "Invalid time_out (HH:mm or empty)" }, 400, corsOkHeaders);
  if (!cleanerName) return jsonResponse({ ok: false, error: "Missing cleaner_name" }, 400, corsOkHeaders);
  if (!staffName) return jsonResponse({ ok: false, error: "Missing staff_name" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO cleaning_entries
       (org_id, location_id, entry_date, time_in, time_out, cleaner_name, staff_name, notes, created_by, created_at, updated_at)
     VALUES
       (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [authUser.org_id, authUser.location_id, entryDate, timeIn, timeOut || "", cleanerName, staffName, notes, authUser.user_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CLEANING_ENTRY_CREATE", "cleaning_entries", String(row.id), {
    entry_date: entryDate,
    time_in: timeIn,
    time_out: timeOut || "",
    cleaner_name: cleanerName,
    staff_name: staffName
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleCleaningEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM cleaning_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const timeIn = String(body.time_in || "").trim();
  const timeOut = String(body.time_out || "").trim();
  const cleanerName = String(body.cleaner_name || "").trim();
  const staffName = String(body.staff_name || "").trim();
  const notes = String(body.notes || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!isValidHm(timeIn)) return jsonResponse({ ok: false, error: "Invalid time_in (HH:mm)" }, 400, corsOkHeaders);
  if (timeOut && !isValidHm(timeOut)) return jsonResponse({ ok: false, error: "Invalid time_out (HH:mm or empty)" }, 400, corsOkHeaders);
  if (!cleanerName) return jsonResponse({ ok: false, error: "Missing cleaner_name" }, 400, corsOkHeaders);
  if (!staffName) return jsonResponse({ ok: false, error: "Missing staff_name" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE cleaning_entries
     SET entry_date = ?, time_in = ?, time_out = ?, cleaner_name = ?, staff_name = ?, notes = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryDate, timeIn, timeOut || "", cleanerName, staffName, notes, entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CLEANING_ENTRY_UPDATE", "cleaning_entries", String(entryId), {
    entry_date: entryDate,
    time_in: timeIn,
    time_out: timeOut || "",
    cleaner_name: cleanerName,
    staff_name: staffName
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleCleaningEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM cleaning_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM cleaning_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CLEANING_ENTRY_DELETE", "cleaning_entries", String(entryId), {});

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleCleaningReport(request, env, corsOkHeaders, authUser, url) {
  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();

  if (!isValidYmd(from) || !isValidYmd(to)) {
    return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (to < from) {
    return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
  }

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       time_in,
       time_out,
       cleaner_name,
       staff_name,
       notes
     FROM cleaning_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date <= ?
     ORDER BY entry_date ASC, time_in ASC, id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  return jsonResponse(
    {
      ok: true,
      org_name: authUser.org_name,
      location_name: authUser.location_name,
      from,
      to,
      entries
    },
    200,
    corsOkHeaders
  );
}

async function handleCleaningReportHtml(request, env, corsOkHeaders, authUser, url) {
  const out = await handleCleaningReport(request, env, corsOkHeaders, authUser, url);
  const data = await out.json();
  if (!data.ok) return out;

  const entries = data.entries || [];

  // Group by month
  const byMonth = new Map();
  for (const e of entries) {
    const ym = ymFromYmd(e.entry_date);
    if (!byMonth.has(ym)) byMonth.set(ym, []);
    byMonth.get(ym).push(e);
  }

  let body = "";
  body += `<h1>${escapeHtml(data.org_name || "Pharmacy")} â€” Cleaning Report</h1>`;
  body += `<p class="meta">Location: ${escapeHtml(data.location_name || "")}<br/>Range: ${escapeHtml(data.from)} to ${escapeHtml(data.to)}</p>`;

  for (const [ym, list] of byMonth.entries()) {
    body += `<h2>${escapeHtml(ym)}</h2>`;
    body += `<table><thead><tr><th>Date</th><th>Time in</th><th>Time out</th><th>Cleaner</th><th>Staff</th><th>Notes</th></tr></thead><tbody>`;
    for (const r of list) {
      body += `<tr>
        <td>${escapeHtml(r.entry_date)}</td>
        <td>${escapeHtml(r.time_in)}</td>
        <td>${escapeHtml(r.time_out || "")}</td>
        <td>${escapeHtml(r.cleaner_name)}</td>
        <td>${escapeHtml(r.staff_name)}</td>
        <td>${escapeHtml(r.notes || "")}</td>
      </tr>`;
    }
    body += `</tbody></table>`;
  }

  return htmlReportPage("Cleaning Report", body);
}

/* =========================
   LOCUM REGISTER MODULE (API)
   ========================= */

async function ensureLocumRegisterSchema(env) {
  // Table may already exist (you created it), but this is safe.
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS locum_register_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      entry_date TEXT NOT NULL,
      time_in TEXT NOT NULL,
      time_out TEXT NOT NULL,
      locum_full_name TEXT NOT NULL,
      registration_number TEXT NOT NULL,
      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_locum_register_org_loc_date ON locum_register_entries (org_id, location_id, entry_date)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_locum_register_org_loc_regno ON locum_register_entries (org_id, location_id, registration_number)",
    []
  );
}

async function handleLocumRegisterEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureLocumRegisterSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       time_in,
       time_out,
       locum_full_name,
       registration_number,
       created_by,
       created_at,
       updated_at
     FROM locum_register_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date < ?
     ORDER BY entry_date DESC, time_in DESC, id DESC`,
    [authUser.org_id, authUser.location_id, range.startStr, range.endStr]
  );

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleLocumRegisterEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureLocumRegisterSchema(env);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const timeIn = String(body.time_in || "").trim();
  const timeOut = String(body.time_out || "").trim();
  const fullName = String(body.locum_full_name || "").trim();
  const regNo = String(body.registration_number || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!isValidHm(timeIn)) return jsonResponse({ ok: false, error: "Invalid time_in (HH:mm)" }, 400, corsOkHeaders);
  if (timeOut && !isValidHm(timeOut)) return jsonResponse({ ok: false, error: "Invalid time_out (HH:mm or empty)" }, 400, corsOkHeaders);
  if (!fullName) return jsonResponse({ ok: false, error: "Missing locum_full_name" }, 400, corsOkHeaders);
  if (!regNo) return jsonResponse({ ok: false, error: "Missing registration_number" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO locum_register_entries
       (org_id, location_id, entry_date, time_in, time_out, locum_full_name, registration_number, created_by, created_at, updated_at)
     VALUES
       (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [authUser.org_id, authUser.location_id, entryDate, timeIn, timeOut || "", fullName, regNo, authUser.user_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "LOCUM_REGISTER_ENTRY_CREATE", "locum_register_entries", String(row.id), {
    entry_date: entryDate,
    time_in: timeIn,
    time_out: timeOut || "",
    locum_full_name: fullName,
    registration_number: regNo
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleLocumRegisterEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureLocumRegisterSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM locum_register_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const timeIn = String(body.time_in || "").trim();
  const timeOut = String(body.time_out || "").trim();
  const fullName = String(body.locum_full_name || "").trim();
  const regNo = String(body.registration_number || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!isValidHm(timeIn)) return jsonResponse({ ok: false, error: "Invalid time_in (HH:mm)" }, 400, corsOkHeaders);
  if (timeOut && !isValidHm(timeOut)) return jsonResponse({ ok: false, error: "Invalid time_out (HH:mm or empty)" }, 400, corsOkHeaders);
  if (!fullName) return jsonResponse({ ok: false, error: "Missing locum_full_name" }, 400, corsOkHeaders);
  if (!regNo) return jsonResponse({ ok: false, error: "Missing registration_number" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE locum_register_entries
     SET entry_date = ?, time_in = ?, time_out = ?, locum_full_name = ?, registration_number = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryDate, timeIn, timeOut || "", fullName, regNo, entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "LOCUM_REGISTER_ENTRY_UPDATE", "locum_register_entries", String(entryId), {
    entry_date: entryDate,
    time_in: timeIn,
    time_out: timeOut || "",
    locum_full_name: fullName,
    registration_number: regNo
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleLocumRegisterEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureLocumRegisterSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM locum_register_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM locum_register_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "LOCUM_REGISTER_ENTRY_DELETE", "locum_register_entries", String(entryId), {});

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}


/* =========================
   DAILY REGISTER MODULE (API)
   ========================= */

async function ensureDailyRegisterSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS daily_register_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      entry_date TEXT NOT NULL,
      client_name TEXT NOT NULL,
      client_id TEXT NOT NULL,
      medicine_name_dose TEXT NOT NULL,
      posology TEXT NOT NULL,
      prescriber_name TEXT NOT NULL,
      prescriber_reg_no TEXT NOT NULL,
      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_daily_register_org_loc_date ON daily_register_entries (org_id, location_id, entry_date)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_daily_register_org_loc_client ON daily_register_entries (org_id, location_id, client_id)",
    []
  );
}

async function handleDailyRegisterEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDailyRegisterSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  const sql = `
    SELECT
      id,
      entry_date,
      client_name,
      client_id,
      medicine_name_dose,
      posology,
      prescriber_name,
      prescriber_reg_no,
      created_by,
      created_at,
      updated_at
    FROM daily_register_entries
    WHERE org_id = ?
      AND location_id = ?
      AND entry_date >= ?
      AND entry_date < ?
      ${hasQ ? `AND (
        entry_date LIKE ?
        OR client_name LIKE ?
        OR client_id LIKE ?
        OR medicine_name_dose LIKE ?
        OR posology LIKE ?
        OR prescriber_name LIKE ?
        OR prescriber_reg_no LIKE ?
      )` : ""}
    ORDER BY entry_date DESC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id, range.startStr, range.endStr];
  if (hasQ) {
    bind.push(qLike, qLike, qLike, qLike, qLike, qLike, qLike);
  }

  const entries = await dbAll(env, sql, bind);

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleDailyRegisterEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDailyRegisterSchema(env);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientId = String(body.client_id || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const posology = String(body.posology || "").trim();
  const prescriberName = String(body.prescriber_name || "").trim();
  const prescriberRegNo = String(body.prescriber_reg_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientId) return jsonResponse({ ok: false, error: "Missing client_id" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!posology) return jsonResponse({ ok: false, error: "Missing posology" }, 400, corsOkHeaders);
  if (!prescriberName) return jsonResponse({ ok: false, error: "Missing prescriber_name" }, 400, corsOkHeaders);
  if (!prescriberRegNo) return jsonResponse({ ok: false, error: "Missing prescriber_reg_no" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO daily_register_entries
      (org_id, location_id, entry_date, client_name, client_id, medicine_name_dose, posology, prescriber_name, prescriber_reg_no, created_by, created_at, updated_at)
     VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [
      authUser.org_id,
      authUser.location_id,
      entryDate,
      clientName,
      clientId,
      medicineNameDose,
      posology,
      prescriberName,
      prescriberRegNo,
      authUser.user_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DAILY_REGISTER_ENTRY_CREATE", "daily_register_entries", String(row.id), {
    entry_date: entryDate,
    client_id: clientId,
    medicine_name_dose: medicineNameDose
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleDailyRegisterEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDailyRegisterSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM daily_register_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientId = String(body.client_id || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const posology = String(body.posology || "").trim();
  const prescriberName = String(body.prescriber_name || "").trim();
  const prescriberRegNo = String(body.prescriber_reg_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientId) return jsonResponse({ ok: false, error: "Missing client_id" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!posology) return jsonResponse({ ok: false, error: "Missing posology" }, 400, corsOkHeaders);
  if (!prescriberName) return jsonResponse({ ok: false, error: "Missing prescriber_name" }, 400, corsOkHeaders);
  if (!prescriberRegNo) return jsonResponse({ ok: false, error: "Missing prescriber_reg_no" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE daily_register_entries
     SET entry_date = ?, client_name = ?, client_id = ?, medicine_name_dose = ?, posology = ?, prescriber_name = ?, prescriber_reg_no = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      entryDate,
      clientName,
      clientId,
      medicineNameDose,
      posology,
      prescriberName,
      prescriberRegNo,
      entryId,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DAILY_REGISTER_ENTRY_UPDATE", "daily_register_entries", String(entryId), {
    entry_date: entryDate,
    client_id: clientId,
    medicine_name_dose: medicineNameDose
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleDailyRegisterEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDailyRegisterSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id, entry_date, client_id
     FROM daily_register_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM daily_register_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DAILY_REGISTER_ENTRY_DELETE", "daily_register_entries", String(entryId), {
    entry_date: existing.entry_date,
    client_id: existing.client_id
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleDailyRegisterReport(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDailyRegisterSchema(env);

  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();

  if (!isValidYmd(from) || !isValidYmd(to)) {
    return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (to < from) {
    return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
  }

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       client_name,
       client_id,
       medicine_name_dose,
       posology,
       prescriber_name,
       prescriber_reg_no
     FROM daily_register_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date <= ?
     ORDER BY entry_date ASC, id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  return jsonResponse(
    {
      ok: true,
      org_name: authUser.org_name,
      location_name: authUser.location_name,
      from,
      to,
      entries
    },
    200,
    corsOkHeaders
  );
}

async function handleDailyRegisterReportHtml(request, env, corsOkHeaders, authUser, url) {
  const out = await handleDailyRegisterReport(request, env, corsOkHeaders, authUser, url);
  const data = await out.json();
  if (!data.ok) return out;

  const entries = data.entries || [];

  // Group by month
  const byMonth = new Map();
  for (const e of entries) {
    const ym = ymFromYmd(e.entry_date);
    if (!byMonth.has(ym)) byMonth.set(ym, []);
    byMonth.get(ym).push(e);
  }

  let body = "";
  body += `<h1>${escapeHtml(data.org_name || "Pharmacy")} â€” Daily Register Report</h1>`;
  body += `<p class="meta">Location: ${escapeHtml(data.location_name || "")}<br/>Range: ${escapeHtml(data.from)} to ${escapeHtml(data.to)}</p>`;

  for (const [ym, list] of byMonth.entries()) {
    body += `<h2>${escapeHtml(ym)}</h2>`;
    body += `<table><thead><tr>
      <th>Date</th>
      <th>Client Name &amp; Surname</th>
      <th>Client ID</th>
      <th>Medicine Name &amp; Dose</th>
      <th>Posology</th>
      <th>Prescriber Name</th>
      <th>Prescriber Reg No.</th>
    </tr></thead><tbody>`;

    for (const r of list) {
      body += `<tr>
        <td>${escapeHtml(r.entry_date)}</td>
        <td>${escapeHtml(r.client_name)}</td>
        <td>${escapeHtml(r.client_id)}</td>
        <td>${escapeHtml(r.medicine_name_dose)}</td>
        <td>${escapeHtml(r.posology)}</td>
        <td>${escapeHtml(r.prescriber_name)}</td>
        <td>${escapeHtml(r.prescriber_reg_no)}</td>
      </tr>`;
    }

    body += `</tbody></table>`;
  }

  return htmlReportPage("Daily Register Report", body);
}

/* =========================
   REPEAT PRESCRIPTIONS MODULE (API)
   ========================= */

async function ensureRepeatPrescriptionsSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS repeat_prescription_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      entry_date TEXT NOT NULL,
      client_name TEXT NOT NULL,
      client_id TEXT NOT NULL,
      medicine_name_dose TEXT NOT NULL,
      posology TEXT NOT NULL,
      prescriber_name TEXT NOT NULL,
      prescriber_reg_no TEXT NOT NULL,
      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_repeat_rx_org_loc_date ON repeat_prescription_entries (org_id, location_id, entry_date)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_repeat_rx_org_loc_client ON repeat_prescription_entries (org_id, location_id, client_id)",
    []
  );
}

async function handleRepeatPrescriptionsEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureRepeatPrescriptionsSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  const sql = `
    SELECT
      id,
      entry_date,
      client_name,
      client_id,
      medicine_name_dose,
      posology,
      prescriber_name,
      prescriber_reg_no,
      created_by,
      created_at,
      updated_at
    FROM repeat_prescription_entries
    WHERE org_id = ?
      AND location_id = ?
      AND entry_date >= ?
      AND entry_date < ?
      ${hasQ ? `AND (
        entry_date LIKE ?
        OR client_name LIKE ?
        OR client_id LIKE ?
        OR medicine_name_dose LIKE ?
        OR posology LIKE ?
        OR prescriber_name LIKE ?
        OR prescriber_reg_no LIKE ?
      )` : ""}
    ORDER BY entry_date DESC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id, range.startStr, range.endStr];
  if (hasQ) bind.push(qLike, qLike, qLike, qLike, qLike, qLike, qLike);

  const entries = await dbAll(env, sql, bind);

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleRepeatPrescriptionsEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureRepeatPrescriptionsSchema(env);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientId = String(body.client_id || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const posology = String(body.posology || "").trim();
  const prescriberName = String(body.prescriber_name || "").trim();
  const prescriberRegNo = String(body.prescriber_reg_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientId) return jsonResponse({ ok: false, error: "Missing client_id" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!posology) return jsonResponse({ ok: false, error: "Missing posology" }, 400, corsOkHeaders);
  if (!prescriberName) return jsonResponse({ ok: false, error: "Missing prescriber_name" }, 400, corsOkHeaders);
  if (!prescriberRegNo) return jsonResponse({ ok: false, error: "Missing prescriber_reg_no" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO repeat_prescription_entries
      (org_id, location_id, entry_date, client_name, client_id, medicine_name_dose, posology, prescriber_name, prescriber_reg_no, created_by, created_at, updated_at)
     VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [
      authUser.org_id,
      authUser.location_id,
      entryDate,
      clientName,
      clientId,
      medicineNameDose,
      posology,
      prescriberName,
      prescriberRegNo,
      authUser.user_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "REPEAT_RX_ENTRY_CREATE", "repeat_prescription_entries", String(row.id), {
    entry_date: entryDate,
    client_id: clientId,
    medicine_name_dose: medicineNameDose
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleRepeatPrescriptionsEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureRepeatPrescriptionsSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM repeat_prescription_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientId = String(body.client_id || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const posology = String(body.posology || "").trim();
  const prescriberName = String(body.prescriber_name || "").trim();
  const prescriberRegNo = String(body.prescriber_reg_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientId) return jsonResponse({ ok: false, error: "Missing client_id" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!posology) return jsonResponse({ ok: false, error: "Missing posology" }, 400, corsOkHeaders);
  if (!prescriberName) return jsonResponse({ ok: false, error: "Missing prescriber_name" }, 400, corsOkHeaders);
  if (!prescriberRegNo) return jsonResponse({ ok: false, error: "Missing prescriber_reg_no" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE repeat_prescription_entries
     SET entry_date = ?, client_name = ?, client_id = ?, medicine_name_dose = ?, posology = ?, prescriber_name = ?, prescriber_reg_no = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      entryDate,
      clientName,
      clientId,
      medicineNameDose,
      posology,
      prescriberName,
      prescriberRegNo,
      entryId,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "REPEAT_RX_ENTRY_UPDATE", "repeat_prescription_entries", String(entryId), {
    entry_date: entryDate,
    client_id: clientId,
    medicine_name_dose: medicineNameDose
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleRepeatPrescriptionsEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureRepeatPrescriptionsSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id, entry_date, client_id
     FROM repeat_prescription_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM repeat_prescription_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "REPEAT_RX_ENTRY_DELETE", "repeat_prescription_entries", String(entryId), {
    entry_date: existing.entry_date,
    client_id: existing.client_id
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}


/* =========================
   DDA SALES MODULE (API)  <-- ADDED
   ========================= */

async function ensureDdaSalesSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS dda_sales_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      entry_date TEXT NOT NULL,
      client_name TEXT NOT NULL,
      client_id_card TEXT NOT NULL,
      client_address TEXT NOT NULL,
      medicine_name_dose TEXT NOT NULL,
      quantity INTEGER NOT NULL,
      doctor_name TEXT NOT NULL,
      doctor_reg_no TEXT NOT NULL,
      prescription_serial_no TEXT NOT NULL,
      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_sales_org_loc_date ON dda_sales_entries (org_id, location_id, entry_date)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_sales_org_loc_client ON dda_sales_entries (org_id, location_id, client_id_card)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_sales_org_loc_serial ON dda_sales_entries (org_id, location_id, prescription_serial_no)",
    []
  );
}



function normalizeIntPositive(n) {
  if (n === null || n === undefined) return null;
  if (n === "") return null;
  const v = Number(n);
  if (!Number.isFinite(v)) return null;
  const i = Math.floor(v);
  if (String(i) !== String(v) && v !== i) {
    // If they send 3.0, Number(v) is 3; still okay. If they send 3.2, reject.
    if (!Number.isInteger(v)) return null;
  }
  return i;
}

async function handleDdaSalesEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  const sql = `
    SELECT
      id,
      entry_date,
      client_name,
      client_id_card,
      client_address,
      medicine_name_dose,
      quantity,
      doctor_name,
      doctor_reg_no,
      prescription_serial_no,
      created_by,
      created_at,
      updated_at
    FROM dda_sales_entries
    WHERE org_id = ?
      AND location_id = ?
      AND entry_date >= ?
      AND entry_date < ?
      ${hasQ ? `AND (
        entry_date LIKE ?
        OR client_name LIKE ?
        OR client_id_card LIKE ?
        OR client_address LIKE ?
        OR medicine_name_dose LIKE ?
        OR doctor_name LIKE ?
        OR doctor_reg_no LIKE ?
        OR prescription_serial_no LIKE ?
      )` : ""}
    ORDER BY entry_date DESC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id, range.startStr, range.endStr];
  if (hasQ) {
    bind.push(qLike, qLike, qLike, qLike, qLike, qLike, qLike, qLike);
  }

  const entries = await dbAll(env, sql, bind);

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleDdaSalesEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientIdCard = String(body.client_id_card || "").trim();
  const clientAddress = String(body.client_address || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const quantity = normalizeIntPositive(body.quantity);
  const doctorName = String(body.doctor_name || "").trim();
  const doctorRegNo = String(body.doctor_reg_no || "").trim();
  const prescriptionSerialNo = String(body.prescription_serial_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientIdCard) return jsonResponse({ ok: false, error: "Missing client_id_card" }, 400, corsOkHeaders);
  if (!clientAddress) return jsonResponse({ ok: false, error: "Missing client_address" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!quantity || quantity < 1) return jsonResponse({ ok: false, error: "Invalid quantity (must be >= 1)" }, 400, corsOkHeaders);
  if (!doctorName) return jsonResponse({ ok: false, error: "Missing doctor_name" }, 400, corsOkHeaders);
  if (!doctorRegNo) return jsonResponse({ ok: false, error: "Missing doctor_reg_no" }, 400, corsOkHeaders);
  if (!prescriptionSerialNo) return jsonResponse({ ok: false, error: "Missing prescription_serial_no" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO dda_sales_entries
      (org_id, location_id, entry_date, client_name, client_id_card, client_address, medicine_name_dose, quantity, doctor_name, doctor_reg_no, prescription_serial_no, created_by, created_at, updated_at)
     VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [
      authUser.org_id,
      authUser.location_id,
      entryDate,
      clientName,
      clientIdCard,
      clientAddress,
      medicineNameDose,
      quantity,
      doctorName,
      doctorRegNo,
      prescriptionSerialNo,
      authUser.user_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_SALES_ENTRY_CREATE", "dda_sales_entries", String(row.id), {
    entry_date: entryDate,
    client_id_card: clientIdCard,
    prescription_serial_no: prescriptionSerialNo,
    quantity: quantity
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleDdaSalesEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM dda_sales_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientIdCard = String(body.client_id_card || "").trim();
  const clientAddress = String(body.client_address || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const quantity = normalizeIntPositive(body.quantity);
  const doctorName = String(body.doctor_name || "").trim();
  const doctorRegNo = String(body.doctor_reg_no || "").trim();
  const prescriptionSerialNo = String(body.prescription_serial_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientIdCard) return jsonResponse({ ok: false, error: "Missing client_id_card" }, 400, corsOkHeaders);
  if (!clientAddress) return jsonResponse({ ok: false, error: "Missing client_address" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!quantity || quantity < 1) return jsonResponse({ ok: false, error: "Invalid quantity (must be >= 1)" }, 400, corsOkHeaders);
  if (!doctorName) return jsonResponse({ ok: false, error: "Missing doctor_name" }, 400, corsOkHeaders);
  if (!doctorRegNo) return jsonResponse({ ok: false, error: "Missing doctor_reg_no" }, 400, corsOkHeaders);
  if (!prescriptionSerialNo) return jsonResponse({ ok: false, error: "Missing prescription_serial_no" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE dda_sales_entries
     SET entry_date = ?, client_name = ?, client_id_card = ?, client_address = ?, medicine_name_dose = ?, quantity = ?, doctor_name = ?, doctor_reg_no = ?, prescription_serial_no = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      entryDate,
      clientName,
      clientIdCard,
      clientAddress,
      medicineNameDose,
      quantity,
      doctorName,
      doctorRegNo,
      prescriptionSerialNo,
      entryId,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_SALES_ENTRY_UPDATE", "dda_sales_entries", String(entryId), {
    entry_date: entryDate,
    client_id_card: clientIdCard,
    prescription_serial_no: prescriptionSerialNo,
    quantity: quantity
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleDdaSalesEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id, entry_date, client_id_card, prescription_serial_no
     FROM dda_sales_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM dda_sales_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_SALES_ENTRY_DELETE", "dda_sales_entries", String(entryId), {
    entry_date: existing.entry_date,
    client_id_card: existing.client_id_card,
    prescription_serial_no: existing.prescription_serial_no
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleDdaSalesReport(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaSalesSchema(env);

  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();

  if (!isValidYmd(from) || !isValidYmd(to)) {
    return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (to < from) {
    return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
  }

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       client_name,
       client_id_card,
       client_address,
       medicine_name_dose,
       quantity,
       doctor_name,
       doctor_reg_no,
       prescription_serial_no
     FROM dda_sales_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date <= ?
     ORDER BY entry_date ASC, id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  return jsonResponse(
    {
      ok: true,
      org_name: authUser.org_name,
      location_name: authUser.location_name,
      from,
      to,
      entries
    },
    200,
    corsOkHeaders
  );
}

async function handleDdaSalesReportHtml(request, env, corsOkHeaders, authUser, url) {
  const out = await handleDdaSalesReport(request, env, corsOkHeaders, authUser, url);
  const data = await out.json();
  if (!data.ok) return out;

  const entries = data.entries || [];

  const byMonth = new Map();
  for (const e of entries) {
    const ym = ymFromYmd(e.entry_date);
    if (!byMonth.has(ym)) byMonth.set(ym, []);
    byMonth.get(ym).push(e);
  }

  let body = "";
  body += `<h1>${escapeHtml(data.org_name || "Pharmacy")} â€” DDA Sales Report</h1>`;
  body += `<p class="meta">Location: ${escapeHtml(data.location_name || "")}<br/>Range: ${escapeHtml(data.from)} to ${escapeHtml(data.to)}</p>`;

  for (const [ym, list] of byMonth.entries()) {
    body += `<h2>${escapeHtml(ym)}</h2>`;
    body += `<table><thead><tr>
      <th>Date</th>
      <th>Client Name</th>
      <th>ID Card</th>
      <th>Address</th>
      <th>Medicine Name &amp; Dose</th>
      <th>Qty</th>
      <th>Doctor Name</th>
      <th>Doctor Reg No.</th>
      <th>Prescription Serial No.</th>
    </tr></thead><tbody>`;

    for (const r of list) {
      body += `<tr>
        <td>${escapeHtml(r.entry_date)}</td>
        <td>${escapeHtml(r.client_name)}</td>
        <td>${escapeHtml(r.client_id_card)}</td>
        <td>${escapeHtml(r.client_address)}</td>
        <td>${escapeHtml(r.medicine_name_dose)}</td>
        <td>${escapeHtml(String(r.quantity))}</td>
        <td>${escapeHtml(r.doctor_name)}</td>
        <td>${escapeHtml(r.doctor_reg_no)}</td>
        <td>${escapeHtml(r.prescription_serial_no)}</td>
      </tr>`;
    }

    body += `</tbody></table>`;
  }

  return htmlReportPage("DDA Sales Report", body);
}

/* =========================
   DDA POYC MODULE (API)  <-- ADDED (NEW)
   ========================= */

async function ensureDdaPoycSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS dda_poyc_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      entry_date TEXT NOT NULL,
      client_name TEXT NOT NULL,
      client_id_card TEXT NOT NULL,
      client_address TEXT NOT NULL,
      medicine_name_dose TEXT NOT NULL,
      quantity INTEGER NOT NULL,
      doctor_name TEXT NOT NULL,
      doctor_reg_no TEXT NOT NULL,
      prescription_serial_no TEXT NOT NULL,
      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_poyc_org_loc_date ON dda_poyc_entries (org_id, location_id, entry_date)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_poyc_org_loc_client ON dda_poyc_entries (org_id, location_id, client_id_card)",
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_poyc_org_loc_serial ON dda_poyc_entries (org_id, location_id, prescription_serial_no)",
    []
  );
}

async function handleDdaPoycEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPoycSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  const sql = `
    SELECT
      id,
      entry_date,
      client_name,
      client_id_card,
      client_address,
      medicine_name_dose,
      quantity,
      doctor_name,
      doctor_reg_no,
      prescription_serial_no,
      created_by,
      created_at,
      updated_at
    FROM dda_poyc_entries
    WHERE org_id = ?
      AND location_id = ?
      AND entry_date >= ?
      AND entry_date < ?
      ${hasQ ? `AND (
        entry_date LIKE ?
        OR client_name LIKE ?
        OR client_id_card LIKE ?
        OR client_address LIKE ?
        OR medicine_name_dose LIKE ?
        OR doctor_name LIKE ?
        OR doctor_reg_no LIKE ?
        OR prescription_serial_no LIKE ?
      )` : ""}
    ORDER BY entry_date DESC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id, range.startStr, range.endStr];
  if (hasQ) {
    bind.push(qLike, qLike, qLike, qLike, qLike, qLike, qLike, qLike);
  }

  const entries = await dbAll(env, sql, bind);

  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleDdaPoycEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPoycSchema(env);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientIdCard = String(body.client_id_card || "").trim();
  const clientAddress = String(body.client_address || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const quantity = normalizeIntPositive(body.quantity);
  const doctorName = String(body.doctor_name || "").trim();
  const doctorRegNo = String(body.doctor_reg_no || "").trim();
  const prescriptionSerialNo = String(body.prescription_serial_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientIdCard) return jsonResponse({ ok: false, error: "Missing client_id_card" }, 400, corsOkHeaders);
  if (!clientAddress) return jsonResponse({ ok: false, error: "Missing client_address" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!quantity || quantity < 1) return jsonResponse({ ok: false, error: "Invalid quantity (must be >= 1)" }, 400, corsOkHeaders);
  if (!doctorName) return jsonResponse({ ok: false, error: "Missing doctor_name" }, 400, corsOkHeaders);
  if (!doctorRegNo) return jsonResponse({ ok: false, error: "Missing doctor_reg_no" }, 400, corsOkHeaders);
  if (!prescriptionSerialNo) return jsonResponse({ ok: false, error: "Missing prescription_serial_no" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO dda_poyc_entries
      (org_id, location_id, entry_date, client_name, client_id_card, client_address, medicine_name_dose, quantity, doctor_name, doctor_reg_no, prescription_serial_no, created_by, created_at, updated_at)
     VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [
      authUser.org_id,
      authUser.location_id,
      entryDate,
      clientName,
      clientIdCard,
      clientAddress,
      medicineNameDose,
      quantity,
      doctorName,
      doctorRegNo,
      prescriptionSerialNo,
      authUser.user_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_POYC_ENTRY_CREATE", "dda_poyc_entries", String(row.id), {
    entry_date: entryDate,
    client_id_card: clientIdCard,
    prescription_serial_no: prescriptionSerialNo,
    quantity: quantity
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleDdaPoycEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPoycSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM dda_poyc_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const clientName = String(body.client_name || "").trim();
  const clientIdCard = String(body.client_id_card || "").trim();
  const clientAddress = String(body.client_address || "").trim();
  const medicineNameDose = String(body.medicine_name_dose || "").trim();
  const quantity = normalizeIntPositive(body.quantity);
  const doctorName = String(body.doctor_name || "").trim();
  const doctorRegNo = String(body.doctor_reg_no || "").trim();
  const prescriptionSerialNo = String(body.prescription_serial_no || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!clientName) return jsonResponse({ ok: false, error: "Missing client_name" }, 400, corsOkHeaders);
  if (!clientIdCard) return jsonResponse({ ok: false, error: "Missing client_id_card" }, 400, corsOkHeaders);
  if (!clientAddress) return jsonResponse({ ok: false, error: "Missing client_address" }, 400, corsOkHeaders);
  if (!medicineNameDose) return jsonResponse({ ok: false, error: "Missing medicine_name_dose" }, 400, corsOkHeaders);
  if (!quantity || quantity < 1) return jsonResponse({ ok: false, error: "Invalid quantity (must be >= 1)" }, 400, corsOkHeaders);
  if (!doctorName) return jsonResponse({ ok: false, error: "Missing doctor_name" }, 400, corsOkHeaders);
  if (!doctorRegNo) return jsonResponse({ ok: false, error: "Missing doctor_reg_no" }, 400, corsOkHeaders);
  if (!prescriptionSerialNo) return jsonResponse({ ok: false, error: "Missing prescription_serial_no" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE dda_poyc_entries
     SET entry_date = ?, client_name = ?, client_id_card = ?, client_address = ?, medicine_name_dose = ?, quantity = ?, doctor_name = ?, doctor_reg_no = ?, prescription_serial_no = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      entryDate,
      clientName,
      clientIdCard,
      clientAddress,
      medicineNameDose,
      quantity,
      doctorName,
      doctorRegNo,
      prescriptionSerialNo,
      entryId,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_POYC_ENTRY_UPDATE", "dda_poyc_entries", String(entryId), {
    entry_date: entryDate,
    client_id_card: clientIdCard,
    prescription_serial_no: prescriptionSerialNo,
    quantity: quantity
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleDdaPoycEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPoycSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id, entry_date, client_id_card, prescription_serial_no
     FROM dda_poyc_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM dda_poyc_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_POYC_ENTRY_DELETE", "dda_poyc_entries", String(entryId), {
    entry_date: existing.entry_date,
    client_id_card: existing.client_id_card,
    prescription_serial_no: existing.prescription_serial_no
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleDdaPoycReport(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPoycSchema(env);

  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();

  if (!isValidYmd(from) || !isValidYmd(to)) {
    return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (to < from) {
    return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
  }

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       client_name,
       client_id_card,
       client_address,
       medicine_name_dose,
       quantity,
       doctor_name,
       doctor_reg_no,
       prescription_serial_no
     FROM dda_poyc_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date <= ?
     ORDER BY entry_date ASC, id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  return jsonResponse(
    {
      ok: true,
      org_name: authUser.org_name,
      location_name: authUser.location_name,
      from,
      to,
      entries
    },
    200,
    corsOkHeaders
  );
}

async function handleDdaPoycReportHtml(request, env, corsOkHeaders, authUser, url) {
  const out = await handleDdaPoycReport(request, env, corsOkHeaders, authUser, url);
  const data = await out.json();
  if (!data.ok) return out;

  const entries = data.entries || [];

  const byMonth = new Map();
  for (const e of entries) {
    const ym = ymFromYmd(e.entry_date);
    if (!byMonth.has(ym)) byMonth.set(ym, []);
    byMonth.get(ym).push(e);
  }

  let body = "";
  body += `<h1>${escapeHtml(data.org_name || "Pharmacy")} â€” DDA POYC Report</h1>`;
  body += `<p class="meta">Location: ${escapeHtml(data.location_name || "")}<br/>Range: ${escapeHtml(data.from)} to ${escapeHtml(data.to)}</p>`;

  for (const [ym, list] of byMonth.entries()) {
    body += `<h2>${escapeHtml(ym)}</h2>`;
    body += `<table><thead><tr>
      <th>Date</th>
      <th>Client Name</th>
      <th>ID Card</th>
      <th>Address</th>
      <th>Medicine Name &amp; Dose</th>
      <th>Qty</th>
      <th>Doctor Name</th>
      <th>Doctor Reg No.</th>
      <th>Prescription Serial No.</th>
    </tr></thead><tbody>`;

    for (const r of list) {
      body += `<tr>
        <td>${escapeHtml(r.entry_date)}</td>
        <td>${escapeHtml(r.client_name)}</td>
        <td>${escapeHtml(r.client_id_card)}</td>
        <td>${escapeHtml(r.client_address)}</td>
        <td>${escapeHtml(r.medicine_name_dose)}</td>
        <td>${escapeHtml(String(r.quantity))}</td>
        <td>${escapeHtml(r.doctor_name)}</td>
        <td>${escapeHtml(r.doctor_reg_no)}</td>
        <td>${escapeHtml(r.prescription_serial_no)}</td>
      </tr>`;
    }

    body += `</tbody></table>`;
  }

  return htmlReportPage("DDA POYC Report", body);
}

/* =========================
   DDA PURCHASES MODULE (API)  <-- NEW
   ========================= */

async function ensureDdaPurchasesSchema(env) {
  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS dda_purchases_entries (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      entry_date TEXT NOT NULL,
      dda_name_dose TEXT NOT NULL,
      quantity INTEGER NOT NULL,
      agent TEXT NOT NULL,
      invoice_number TEXT NOT NULL,
      created_by INTEGER,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now'))
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_purchases_org_loc_date ON dda_purchases_entries (org_id, location_id, entry_date)",
    []
  );
  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_purchases_org_loc_invoice ON dda_purchases_entries (org_id, location_id, invoice_number)",
    []
  );
  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_dda_purchases_org_loc_dda ON dda_purchases_entries (org_id, location_id, dda_name_dose)",
    []
  );
}

async function handleDdaPurchasesEntriesList(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPurchasesSchema(env);

  const month = (url.searchParams.get("month") || "").trim();
  const range = monthRange(month);
  if (!range) return jsonResponse({ ok: false, error: "Missing/invalid month (YYYY-MM)" }, 400, corsOkHeaders);

  const q = (url.searchParams.get("q") || "").trim();
  const hasQ = !!q;
  const qLike = `%${q}%`;

  const sql = `
    SELECT
      id,
      entry_date,
      dda_name_dose,
      quantity,
      agent,
      invoice_number,
      created_by,
      created_at,
      updated_at
    FROM dda_purchases_entries
    WHERE org_id = ?
      AND location_id = ?
      AND entry_date >= ?
      AND entry_date < ?
      ${hasQ ? `AND (
        entry_date LIKE ?
        OR dda_name_dose LIKE ?
        OR agent LIKE ?
        OR invoice_number LIKE ?
      )` : ""}
    ORDER BY entry_date DESC, id DESC
  `;

  const bind = [authUser.org_id, authUser.location_id, range.startStr, range.endStr];
  if (hasQ) bind.push(qLike, qLike, qLike, qLike);

  const entries = await dbAll(env, sql, bind);
  return jsonResponse({ ok: true, entries }, 200, corsOkHeaders);
}

async function handleDdaPurchasesEntryCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPurchasesSchema(env);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const ddaNameDose = String(body.dda_name_dose || "").trim();
  const quantity = normalizeIntPositive(body.quantity);
  const agent = String(body.agent || "").trim();
  const invoiceNumber = String(body.invoice_number || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!ddaNameDose) return jsonResponse({ ok: false, error: "Missing dda_name_dose" }, 400, corsOkHeaders);
  if (!quantity || quantity < 1) return jsonResponse({ ok: false, error: "Invalid quantity (must be >= 1)" }, 400, corsOkHeaders);
  if (!agent) return jsonResponse({ ok: false, error: "Missing agent" }, 400, corsOkHeaders);
  if (!invoiceNumber) return jsonResponse({ ok: false, error: "Missing invoice_number" }, 400, corsOkHeaders);

  const row = await dbFirst(
    env,
    `INSERT INTO dda_purchases_entries
      (org_id, location_id, entry_date, dda_name_dose, quantity, agent, invoice_number, created_by, created_at, updated_at)
     VALUES
      (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
     RETURNING id`,
    [
      authUser.org_id,
      authUser.location_id,
      entryDate,
      ddaNameDose,
      quantity,
      agent,
      invoiceNumber,
      authUser.user_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_PURCHASES_ENTRY_CREATE", "dda_purchases_entries", String(row.id), {
    entry_date: entryDate,
    dda_name_dose: ddaNameDose,
    invoice_number: invoiceNumber,
    quantity
  });

  return jsonResponse({ ok: true, entry_id: row.id }, 200, corsOkHeaders);
}

async function handleDdaPurchasesEntryUpdate(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPurchasesSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id
     FROM dda_purchases_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);

  const entryDate = String(body.entry_date || "").trim();
  const ddaNameDose = String(body.dda_name_dose || "").trim();
  const quantity = normalizeIntPositive(body.quantity);
  const agent = String(body.agent || "").trim();
  const invoiceNumber = String(body.invoice_number || "").trim();

  if (!isValidYmd(entryDate)) return jsonResponse({ ok: false, error: "Invalid entry_date (YYYY-MM-DD)" }, 400, corsOkHeaders);
  if (!ddaNameDose) return jsonResponse({ ok: false, error: "Missing dda_name_dose" }, 400, corsOkHeaders);
  if (!quantity || quantity < 1) return jsonResponse({ ok: false, error: "Invalid quantity (must be >= 1)" }, 400, corsOkHeaders);
  if (!agent) return jsonResponse({ ok: false, error: "Missing agent" }, 400, corsOkHeaders);
  if (!invoiceNumber) return jsonResponse({ ok: false, error: "Missing invoice_number" }, 400, corsOkHeaders);

  await dbRun(
    env,
    `UPDATE dda_purchases_entries
     SET entry_date = ?, dda_name_dose = ?, quantity = ?, agent = ?, invoice_number = ?, updated_at = datetime('now')
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      entryDate,
      ddaNameDose,
      quantity,
      agent,
      invoiceNumber,
      entryId,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_PURCHASES_ENTRY_UPDATE", "dda_purchases_entries", String(entryId), {
    entry_date: entryDate,
    dda_name_dose: ddaNameDose,
    invoice_number: invoiceNumber,
    quantity
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleDdaPurchasesEntryDelete(request, env, corsOkHeaders, authUser, entryId) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPurchasesSchema(env);

  const existing = await dbFirst(
    env,
    `SELECT id, entry_date, dda_name_dose, invoice_number
     FROM dda_purchases_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );
  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(
    env,
    `DELETE FROM dda_purchases_entries
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [entryId, authUser.org_id, authUser.location_id]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_PURCHASES_ENTRY_DELETE", "dda_purchases_entries", String(entryId), {
    entry_date: existing.entry_date,
    dda_name_dose: existing.dda_name_dose,
    invoice_number: existing.invoice_number
  });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleDdaPurchasesReport(request, env, corsOkHeaders, authUser, url) {
  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDdaPurchasesSchema(env);

  const from = (url.searchParams.get("from") || "").trim();
  const to = (url.searchParams.get("to") || "").trim();

  if (!isValidYmd(from) || !isValidYmd(to)) {
    return jsonResponse({ ok: false, error: "Invalid from/to (YYYY-MM-DD)" }, 400, corsOkHeaders);
  }
  if (to < from) {
    return jsonResponse({ ok: false, error: "to must be >= from" }, 400, corsOkHeaders);
  }

  const entries = await dbAll(
    env,
    `SELECT
       id,
       entry_date,
       dda_name_dose,
       quantity,
       agent,
       invoice_number
     FROM dda_purchases_entries
     WHERE org_id = ?
       AND location_id = ?
       AND entry_date >= ?
       AND entry_date <= ?
     ORDER BY entry_date ASC, id ASC`,
    [authUser.org_id, authUser.location_id, from, to]
  );

  return jsonResponse(
    {
      ok: true,
      org_name: authUser.org_name,
      location_name: authUser.location_name,
      from,
      to,
      entries
    },
    200,
    corsOkHeaders
  );
}

async function handleDdaPurchasesReportHtml(request, env, corsOkHeaders, authUser, url) {
  const out = await handleDdaPurchasesReport(request, env, corsOkHeaders, authUser, url);
  const data = await out.json();
  if (!data.ok) return out;

  const entries = data.entries || [];

  const byMonth = new Map();
  for (const e of entries) {
    const ym = ymFromYmd(e.entry_date);
    if (!byMonth.has(ym)) byMonth.set(ym, []);
    byMonth.get(ym).push(e);
  }

  let body = "";
  body += `<h1>${escapeHtml(data.org_name || "Pharmacy")} â€” DDA Purchases Report</h1>`;
  body += `<p class="meta">Location: ${escapeHtml(data.location_name || "")}<br/>Range: ${escapeHtml(data.from)} to ${escapeHtml(data.to)}</p>`;

  for (const [ym, list] of byMonth.entries()) {
    body += `<h2>${escapeHtml(ym)}</h2>`;
    body += `<table><thead><tr>
      <th>Date</th>
      <th>DDA Name &amp; Dose</th>
      <th>Qty</th>
      <th>Agent</th>
      <th>Invoice No.</th>
    </tr></thead><tbody>`;

    for (const r of list) {
      body += `<tr>
        <td>${escapeHtml(r.entry_date)}</td>
        <td>${escapeHtml(r.dda_name_dose)}</td>
        <td>${escapeHtml(String(r.quantity))}</td>
        <td>${escapeHtml(r.agent)}</td>
        <td>${escapeHtml(r.invoice_number)}</td>
      </tr>`;
    }

    body += `</tbody></table>`;
  }

  return htmlReportPage("DDA Purchases Report", body);
}

/* ========================= DDA STOCK TAKES MODULE (API) ========================= */
async function ensureDdaStockTakesSchema(env) {
  await dbRun(env, `CREATE TABLE IF NOT EXISTS dda_stocktakes (id INTEGER PRIMARY KEY AUTOINCREMENT, org_id INTEGER NOT NULL, location_id INTEGER NOT NULL, created_at TEXT NOT NULL DEFAULT (datetime('now')), created_by INTEGER, closed_at TEXT, updated_at TEXT NOT NULL DEFAULT (datetime('now')))`, []);
  await dbRun(env, `CREATE TABLE IF NOT EXISTS dda_stocktake_items (id INTEGER PRIMARY KEY AUTOINCREMENT, org_id INTEGER NOT NULL, location_id INTEGER NOT NULL, stocktake_id INTEGER NOT NULL, item_name TEXT NOT NULL, dosage TEXT, qty_tablets INTEGER NOT NULL DEFAULT 0, created_at TEXT NOT NULL DEFAULT (datetime('now')), updated_at TEXT NOT NULL DEFAULT (datetime('now')))`, []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_dda_stocktakes_org_loc_created ON dda_stocktakes (org_id, location_id, created_at)", []);
  await dbRun(env, "CREATE INDEX IF NOT EXISTS idx_dda_stocktake_items_stocktake ON dda_stocktake_items (org_id, location_id, stocktake_id)", []);
}

async function handleDdaStockTakesList(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const stocktakes = await dbAll(env, `
    SELECT s.id, s.created_at, s.closed_at, s.updated_at,
      (SELECT COUNT(*) FROM dda_stocktake_items i
        WHERE i.org_id=s.org_id AND i.location_id=s.location_id AND i.stocktake_id=s.id) AS item_count
    FROM dda_stocktakes s
    WHERE s.org_id = ? AND s.location_id = ?
    ORDER BY s.created_at DESC, s.id DESC
  `, [authUser.org_id, authUser.location_id]);

  return jsonResponse({ ok: true, stocktakes }, 200, corsOkHeaders);
}

async function handleDdaStockTakeCreate(request, env, corsOkHeaders, authUser) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const row = await dbFirst(env, `
    INSERT INTO dda_stocktakes (org_id, location_id, created_by, created_at, updated_at)
    VALUES (?, ?, ?, datetime('now'), datetime('now'))
    RETURNING id, created_at
  `, [authUser.org_id, authUser.location_id, authUser.user_id]);

  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_STOCKTAKE_CREATE", "dda_stocktakes", String(row.id), { created_at: row.created_at });
  return jsonResponse({ ok: true, stocktake_id: row.id, created_at: row.created_at }, 200, corsOkHeaders);
}

async function handleDdaStockTakeGet(request, env, corsOkHeaders, authUser, stocktakeId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const st = await dbFirst(env, `
    SELECT id, created_at, created_by, closed_at, updated_at
    FROM dda_stocktakes
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [stocktakeId, authUser.org_id, authUser.location_id]);

  if (!st) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const items = await dbAll(env, `
    SELECT id, stocktake_id, item_name, dosage, qty_tablets, created_at, updated_at
    FROM dda_stocktake_items
    WHERE stocktake_id = ? AND org_id = ? AND location_id = ?
    ORDER BY item_name COLLATE NOCASE ASC, id ASC
  `, [stocktakeId, authUser.org_id, authUser.location_id]);

  return jsonResponse({ ok: true, stocktake: st, items }, 200, corsOkHeaders);
}

async function handleDdaStockTakeUpdate(request, env, corsOkHeaders, authUser, stocktakeId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const st = await dbFirst(env, `SELECT id, closed_at FROM dda_stocktakes WHERE id = ? AND org_id = ? AND location_id = ?`, [stocktakeId, authUser.org_id, authUser.location_id]);
  if (!st) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);
  const close = body && (body.closed === 1 || body.closed === true);
  const reopen = body && (body.closed === 0 || body.closed === false);

  if (close) {
    await dbRun(env, `
      UPDATE dda_stocktakes
      SET closed_at = COALESCE(closed_at, datetime('now')),
          updated_at = datetime('now')
      WHERE id = ? AND org_id = ? AND location_id = ?
    `, [stocktakeId, authUser.org_id, authUser.location_id]);

    await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_STOCKTAKE_CLOSE", "dda_stocktakes", String(stocktakeId), {});
  } else if (reopen) {
    await dbRun(env, `
      UPDATE dda_stocktakes
      SET closed_at = NULL,
          updated_at = datetime('now')
      WHERE id = ? AND org_id = ? AND location_id = ?
    `, [stocktakeId, authUser.org_id, authUser.location_id]);

    await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_STOCKTAKE_REOPEN", "dda_stocktakes", String(stocktakeId), {});
  }

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleDdaStockTakeItemAdd(request, env, corsOkHeaders, authUser, stocktakeId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const st = await dbFirst(env, `SELECT id FROM dda_stocktakes WHERE id = ? AND org_id = ? AND location_id = ?`, [stocktakeId, authUser.org_id, authUser.location_id]);
  if (!st) return jsonResponse({ ok: false, error: "Stock take not found" }, 404, corsOkHeaders);

  const body = await readJson(request);
  const name = String(body.item_name || "").trim();
  const dosage = String(body.dosage || "").trim();
  const qty = Number(body.qty_tablets);

  if (!name) return jsonResponse({ ok: false, error: "Missing item_name" }, 400, corsOkHeaders);
  if (!Number.isFinite(qty) || qty < 0) return jsonResponse({ ok: false, error: "Invalid qty_tablets (>= 0)" }, 400, corsOkHeaders);

  const row = await dbFirst(env, `
    INSERT INTO dda_stocktake_items (org_id, location_id, stocktake_id, item_name, dosage, qty_tablets, created_at, updated_at)
    VALUES (?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
    RETURNING id
  `, [authUser.org_id, authUser.location_id, stocktakeId, name, dosage, Math.floor(qty)]);

  await dbRun(env, `UPDATE dda_stocktakes SET updated_at = datetime('now') WHERE id = ? AND org_id = ? AND location_id = ?`, [stocktakeId, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_STOCKTAKE_ITEM_ADD", "dda_stocktake_items", String(row.id), { stocktake_id: stocktakeId, item_name: name, dosage, qty_tablets: Math.floor(qty) });

  return jsonResponse({ ok: true, item_id: row.id }, 200, corsOkHeaders);
}

async function handleDdaStockTakeItemUpdate(request, env, corsOkHeaders, authUser, itemId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const existing = await dbFirst(env, `
    SELECT id, stocktake_id
    FROM dda_stocktake_items
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [itemId, authUser.org_id, authUser.location_id]);

  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const body = await readJson(request);
  const name = String(body.item_name || "").trim();
  const dosage = String(body.dosage || "").trim();
  const qty = Number(body.qty_tablets);

  if (!name) return jsonResponse({ ok: false, error: "Missing item_name" }, 400, corsOkHeaders);
  if (!Number.isFinite(qty) || qty < 0) return jsonResponse({ ok: false, error: "Invalid qty_tablets (>= 0)" }, 400, corsOkHeaders);

  await dbRun(env, `
    UPDATE dda_stocktake_items
    SET item_name = ?, dosage = ?, qty_tablets = ?, updated_at = datetime('now')
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [name, dosage, Math.floor(qty), itemId, authUser.org_id, authUser.location_id]);

  await dbRun(env, `UPDATE dda_stocktakes SET updated_at = datetime('now') WHERE id = ? AND org_id = ? AND location_id = ?`, [existing.stocktake_id, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_STOCKTAKE_ITEM_UPDATE", "dda_stocktake_items", String(itemId), { item_name: name, dosage, qty_tablets: Math.floor(qty) });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleDdaStockTakeItemDelete(request, env, corsOkHeaders, authUser, itemId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const existing = await dbFirst(env, `
    SELECT id, stocktake_id, item_name
    FROM dda_stocktake_items
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [itemId, authUser.org_id, authUser.location_id]);

  if (!existing) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  await dbRun(env, `DELETE FROM dda_stocktake_items WHERE id = ? AND org_id = ? AND location_id = ?`, [itemId, authUser.org_id, authUser.location_id]);
  await dbRun(env, `UPDATE dda_stocktakes SET updated_at = datetime('now') WHERE id = ? AND org_id = ? AND location_id = ?`, [existing.stocktake_id, authUser.org_id, authUser.location_id]);
  await writeAudit(env, authUser.org_id, authUser.user_id, "DDA_STOCKTAKE_ITEM_DELETE", "dda_stocktake_items", String(itemId), { item_name: existing.item_name });

  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleDdaStockTakeReportHtml(request, env, corsOkHeaders, authUser, stocktakeId) {
  if (!requireRole(authUser, ["admin", "staff"])) return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  await ensureDdaStockTakesSchema(env);

  const st = await dbFirst(env, `
    SELECT id, created_at, closed_at
    FROM dda_stocktakes
    WHERE id = ? AND org_id = ? AND location_id = ?
  `, [stocktakeId, authUser.org_id, authUser.location_id]);

  if (!st) return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);

  const items = await dbAll(env, `
    SELECT item_name, dosage, qty_tablets
    FROM dda_stocktake_items
    WHERE stocktake_id = ? AND org_id = ? AND location_id = ?
    ORDER BY item_name COLLATE NOCASE ASC, id ASC
  `, [stocktakeId, authUser.org_id, authUser.location_id]);

  let body = "";
  body += `<h1>${escapeHtml(authUser.org_name || "Pharmacy")} â€” DDA Stock Take</h1>`;
  body += `<div class="meta">Location: ${escapeHtml(authUser.location_name || "")}<br>
    Stock Take ID: ${escapeHtml(String(st.id))}<br>
    Created: ${escapeHtml(String(st.created_at || ""))}${st.closed_at ? `<br>Closed: ${escapeHtml(String(st.closed_at))}` : ""}</div>`;

  body += `<table><thead><tr><th>Name</th><th>Dosage</th><th>Quantity of Tablets</th></tr></thead><tbody>`;
  if (!items.length) {
    body += `<tr><td colspan="3">No items.</td></tr>`;
  } else {
    for (const it of items) {
      body += `<tr><td>${escapeHtml(it.item_name || "")}</td><td>${escapeHtml(it.dosage || "")}</td><td>${escapeHtml(String(it.qty_tablets == null ? "" : it.qty_tablets))}</td></tr>`;
    }
  }
  body += `</tbody></table>`;

  body += `<div class="meta">Generated: ${escapeHtml(nowIso())}</div>`;
  return htmlReportPage("DDA Stock Take", body);
}


/* =========================
   CERTIFICATES MODULE (API)
   ========================= */

function addMonthsToYmd(ymd, months) {
  const s = String(ymd || "").trim();
  if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return null;

  const y = parseInt(s.slice(0, 4), 10);
  const m = parseInt(s.slice(5, 7), 10);
  const d = parseInt(s.slice(8, 10), 10);

  if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return null;

  const targetMonthIndex = (m - 1) + Number(months || 0);
  const ty = y + Math.floor(targetMonthIndex / 12);
  const tm = (targetMonthIndex % 12 + 12) % 12; // 0..11

  // Clamp day to end of month
  const lastDay = new Date(Date.UTC(ty, tm + 1, 0)).getUTCDate();
  const td = Math.min(d, lastDay);

  const dt = new Date(Date.UTC(ty, tm, td));
  return dt.toISOString().slice(0, 10);
}

async function ensureCertificatesSchema(env) {
  console.log("[certificates] ensureCertificatesSchema() start");

  await dbRun(
    env,
    `CREATE TABLE IF NOT EXISTS certificates_items (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      org_id INTEGER NOT NULL,
      location_id INTEGER NOT NULL,
      item_key TEXT NOT NULL,
      title TEXT NOT NULL,
      subtitle TEXT NOT NULL,
      last_label TEXT NOT NULL,
      next_label TEXT NOT NULL,
      interval_months INTEGER NOT NULL DEFAULT 12,
      last_date TEXT,
      certified_person TEXT,
      requires_person INTEGER NOT NULL DEFAULT 0,
      file_name TEXT,
      file_mime TEXT,
      file_size INTEGER,
      file_uploaded_at TEXT,
      file_r2_key TEXT,
      file_b64 TEXT,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      updated_at TEXT NOT NULL DEFAULT (datetime('now')),
      created_by INTEGER,
      updated_by INTEGER,
      UNIQUE(org_id, location_id, item_key)
    )`,
    []
  );

  await dbRun(
    env,
    "CREATE INDEX IF NOT EXISTS idx_certificates_items_org_loc ON certificates_items (org_id, location_id)",
    []
  );

  console.log("[certificates] ensureCertificatesSchema() done");
}

async function ensureDefaultCertificatesIfMissing(env, authUser) {
  await ensureCertificatesSchema(env);

  const existing = await dbFirst(
    env,
    "SELECT COUNT(*) AS c FROM certificates_items WHERE org_id = ? AND location_id = ?",
    [authUser.org_id, authUser.location_id]
  );

  const c = existing && existing.c ? Number(existing.c) : 0;
  console.log("[certificates] ensureDefaultCertificatesIfMissing() existing count=", c);

  if (c > 0) return;

  if (!requireRole(authUser, ["admin"])) return;

  const defaults = [
    {
      item_key: "thermometer_calibration",
      title: "Thermometer Calibration",
      subtitle: "Yearly calibration",
      last_label: "Last Calibration",
      next_label: "Next Due",
      interval_months: 12,
      requires_person: 0
    },
    {
      item_key: "ac_maintenance",
      title: "AC Maintenance",
      subtitle: "Yearly service",
      last_label: "Last Service",
      next_label: "Next Due",
      interval_months: 12,
      requires_person: 0
    },
    {
      item_key: "first_aid_certificate",
      title: "First Aid Certificate",
      subtitle: "3 year renewal",
      last_label: "Issued / Last Renewal",
      next_label: "Renew By",
      interval_months: 36,
      requires_person: 1
    },
    {
      item_key: "dispensary_licence",
      title: "Dispensary Licence",
      subtitle: "Yearly renewal",
      last_label: "Last Renewal",
      next_label: "Renew By",
      interval_months: 12,
      requires_person: 0
    },
    {
      item_key: "fire_extinguisher",
      title: "Fire Extinguisher",
      subtitle: "Yearly renewal",
      last_label: "Last Renewal",
      next_label: "Renew By",
      interval_months: 12,
      requires_person: 0
    },
    {
      item_key: "pest_control",
      title: "Pest Control",
      subtitle: "Yearly service",
      last_label: "Last Service",
      next_label: "Next Due",
      interval_months: 12,
      requires_person: 0
    },
    {
      item_key: "fire_training",
      title: "Fire Training",
      subtitle: "3 year renewal",
      last_label: "Issued / Last Renewal",
      next_label: "Renew By",
      interval_months: 36,
      requires_person: 1
    },
    {
      item_key: "reverse_osmosis_system",
      title: "Reverse Osmmosis System",
      subtitle: "Yearly service",
      last_label: "Last Service",
      next_label: "Next Due",
      interval_months: 12,
      requires_person: 0
    }
  ];

  for (const it of defaults) {
    console.log("[certificates] inserting default item", it.item_key);
    await dbRun(
      env,
      `INSERT INTO certificates_items
        (org_id, location_id, item_key, title, subtitle, last_label, next_label, interval_months, requires_person, created_at, updated_at, created_by, updated_by)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'), ?, ?)
       ON CONFLICT(org_id, location_id, item_key)
       DO NOTHING`,
      [
        authUser.org_id,
        authUser.location_id,
        it.item_key,
        it.title,
        it.subtitle,
        it.last_label,
        it.next_label,
        it.interval_months,
        it.requires_person ? 1 : 0,
        authUser.user_id,
        authUser.user_id
      ]
    );
  }

  await writeAudit(env, authUser.org_id, authUser.user_id, "CERT_DEFAULT_ITEMS_CREATE", "location", String(authUser.location_id), {});
  console.log("[certificates] default items ensured");
}

async function getCertificateItemByIdOrKey(env, authUser, idOrKey) {
  const raw = String(idOrKey || "").trim();
  if (!raw) return null;

  let row = null;

  if (/^\d+$/.test(raw)) {
    const id = parseInt(raw, 10);
    row = await dbFirst(
      env,
      `SELECT *
       FROM certificates_items
       WHERE id = ? AND org_id = ? AND location_id = ?`,
      [id, authUser.org_id, authUser.location_id]
    );
    if (row) return row;
  }

  row = await dbFirst(
    env,
    `SELECT *
     FROM certificates_items
     WHERE item_key = ? AND org_id = ? AND location_id = ?`,
    [raw, authUser.org_id, authUser.location_id]
  );

  return row || null;
}

async function handleCertificatesItemsList(request, env, corsOkHeaders, authUser) {
  console.log("[certificates] LIST start", { org_id: authUser.org_id, location_id: authUser.location_id });

  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDefaultCertificatesIfMissing(env, authUser);

  const items = await dbAll(
    env,
    `SELECT
       id,
       item_key,
       title,
       subtitle,
       last_label,
       next_label,
       interval_months,
       last_date,
       certified_person,
       requires_person,
       file_name,
       file_mime,
       file_size,
       file_uploaded_at,
       file_r2_key,
       created_at,
       updated_at
     FROM certificates_items
     WHERE org_id = ? AND location_id = ?
     ORDER BY id ASC`,
    [authUser.org_id, authUser.location_id]
  );

  const out = [];
  for (const it of items) {
    const next_due = (it.last_date && it.interval_months)
      ? addMonthsToYmd(it.last_date, Number(it.interval_months))
      : null;

    out.push({
      id: it.id,
      item_key: it.item_key,
      title: it.title,
      subtitle: it.subtitle,
      last_label: it.last_label,
      next_label: it.next_label,
      interval_months: Number(it.interval_months || 12),
      last_date: it.last_date || null,
      next_due: next_due,
      certified_person: it.certified_person || "",
      requires_person: it.requires_person ? 1 : 0,
      file_name: it.file_name || "",
      file_uploaded_at: it.file_uploaded_at || "",
      file_mime: it.file_mime || "",
      file_size: it.file_size === null || it.file_size === undefined ? null : Number(it.file_size),
      file_r2_key: it.file_r2_key || ""
    });
  }

  console.log("[certificates] LIST done count=", out.length);
  return jsonResponse({ ok: true, items: out }, 200, corsOkHeaders);
}

async function handleCertificatesItemUpdate(request, env, corsOkHeaders, authUser, idOrKey) {
  console.log("[certificates] UPDATE start", { idOrKey: String(idOrKey), org_id: authUser.org_id, location_id: authUser.location_id });

  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDefaultCertificatesIfMissing(env, authUser);

  const existing = await getCertificateItemByIdOrKey(env, authUser, idOrKey);
  if (!existing) {
    console.log("[certificates] UPDATE not found", { idOrKey: String(idOrKey) });
    return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
  }

  const body = await readJson(request);

  const lastDate = body.last_date === null || body.last_date === undefined ? undefined : String(body.last_date || "").trim();
  const intervalMonths = body.interval_months === null || body.interval_months === undefined ? undefined : parseInt(body.interval_months, 10);
  const certifiedPerson = body.certified_person === undefined ? undefined : String(body.certified_person || "").trim();

  if (lastDate !== undefined) {
    if (lastDate && !isValidYmd(lastDate)) {
      return jsonResponse({ ok: false, error: "Invalid last_date (YYYY-MM-DD or null)" }, 400, corsOkHeaders);
    }
  }

  let newInterval = existing.interval_months;
  if (intervalMonths !== undefined) {
    if (!Number.isFinite(intervalMonths) || intervalMonths < 1 || intervalMonths > 240) {
      return jsonResponse({ ok: false, error: "Invalid interval_months (1..240)" }, 400, corsOkHeaders);
    }
    newInterval = intervalMonths;
  }

  let newLast = existing.last_date;
  if (lastDate !== undefined) {
    newLast = lastDate ? lastDate : null;
  }

  let newPerson = existing.certified_person;
  if (existing.requires_person === 1) {
    if (certifiedPerson !== undefined) newPerson = certifiedPerson;
  } else {
    if (certifiedPerson !== undefined) {
      console.log("[certificates] UPDATE: ignoring certified_person (requires_person=0)");
    }
  }

  await dbRun(
    env,
    `UPDATE certificates_items
     SET last_date = ?, interval_months = ?, certified_person = ?, updated_at = datetime('now'), updated_by = ?
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      newLast,
      newInterval,
      existing.requires_person === 1 ? (newPerson || "") : (existing.certified_person || ""),
      authUser.user_id,
      existing.id,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CERT_ITEM_UPDATE", "certificates_items", String(existing.id), {
    id: existing.id,
    item_key: existing.item_key,
    last_date: newLast,
    interval_months: newInterval,
    certified_person: (existing.requires_person === 1 ? (newPerson || "") : "")
  });

  console.log("[certificates] UPDATE done", { id: existing.id, item_key: existing.item_key });
  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

async function handleCertificatesUpload(request, env, corsOkHeaders, authUser, idOrKey) {
  console.log("[certificates] UPLOAD start", { idOrKey: String(idOrKey), ct: request.headers.get("Content-Type") || "" });

  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDefaultCertificatesIfMissing(env, authUser);

  const existing = await getCertificateItemByIdOrKey(env, authUser, idOrKey);
  if (!existing) {
    console.log("[certificates] UPLOAD not found", { idOrKey: String(idOrKey) });
    return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
  }

  const ct = (request.headers.get("Content-Type") || "").toLowerCase();

  let fileName = "";
  let fileMime = "application/octet-stream";
  let fileSize = 0;
  let bytes = null;

  if (ct.includes("multipart/form-data")) {
    const form = await request.formData();
    const f = form.get("file");

    if (!f) return jsonResponse({ ok: false, error: "Missing form field: file" }, 400, corsOkHeaders);
    if (!(f instanceof File)) return jsonResponse({ ok: false, error: "Invalid file upload" }, 400, corsOkHeaders);

    fileName = String(f.name || "upload.bin");
    fileMime = String(f.type || "application/octet-stream");
    fileSize = Number(f.size || 0);

    const ab = await f.arrayBuffer();
    bytes = new Uint8Array(ab);

    console.log("[certificates] UPLOAD multipart received", { fileName, fileMime, fileSize });
  } else if (ct.includes("application/json")) {
    const body = await readJson(request);

    fileName = String(body.file_name || "").trim();
    fileMime = String(body.file_mime || "application/octet-stream").trim() || "application/octet-stream";
    const b64 = String(body.file_b64 || "").trim();

    if (!fileName) return jsonResponse({ ok: false, error: "Missing file_name" }, 400, corsOkHeaders);
    if (!b64) return jsonResponse({ ok: false, error: "Missing file_b64" }, 400, corsOkHeaders);

    try {
      bytes = bytesFromBase64(b64);
    } catch (e) {
      console.log("[certificates] UPLOAD json base64 decode failed", e && (e.stack || e.message || String(e)));
      return jsonResponse({ ok: false, error: "Invalid base64" }, 400, corsOkHeaders);
    }

    fileSize = bytes.length;

    console.log("[certificates] UPLOAD json received", { fileName, fileMime, fileSize });
  } else {
    return jsonResponse({ ok: false, error: "Unsupported Content-Type for upload" }, 415, corsOkHeaders);
  }

  const maxBytes = parseInt((env.CERT_UPLOAD_MAX_BYTES || "800000").trim(), 10);
  const hasR2 = !!env.CERTS_R2;

  if (!hasR2 && fileSize > maxBytes) {
    console.log("[certificates] UPLOAD too large for D1 base64", { fileSize, maxBytes });
    return jsonResponse({ ok: false, error: `File too large (${fileSize} bytes). Max without R2 is ${maxBytes}.` }, 413, corsOkHeaders);
  }

  let fileR2Key = null;
  let fileB64 = null;

  if (hasR2) {
    const safeName = fileName.replace(/[^\w.\-() ]+/g, "_").slice(0, 120) || "upload.bin";
    fileR2Key = `certificates/org_${authUser.org_id}/loc_${authUser.location_id}/${existing.item_key}/${Date.now()}_${safeName}`;

    console.log("[certificates] UPLOAD storing in R2", { fileR2Key });

    await env.CERTS_R2.put(fileR2Key, bytes, {
      httpMetadata: {
        contentType: fileMime
      }
    });

    fileB64 = null;
  } else {
    fileB64 = base64FromBytes(bytes);
    fileR2Key = null;

    console.log("[certificates] UPLOAD storing in D1 (base64)", { fileSize });
  }

  await dbRun(
    env,
    `UPDATE certificates_items
     SET file_name = ?, file_mime = ?, file_size = ?, file_uploaded_at = datetime('now'),
         file_r2_key = ?, file_b64 = ?, updated_at = datetime('now'), updated_by = ?
     WHERE id = ? AND org_id = ? AND location_id = ?`,
    [
      fileName,
      fileMime,
      fileSize,
      fileR2Key,
      fileB64,
      authUser.user_id,
      existing.id,
      authUser.org_id,
      authUser.location_id
    ]
  );

  await writeAudit(env, authUser.org_id, authUser.user_id, "CERT_FILE_UPLOAD", "certificates_items", String(existing.id), {
    id: existing.id,
    item_key: existing.item_key,
    file_name: fileName,
    file_mime: fileMime,
    file_size: fileSize,
    stored: hasR2 ? "r2" : "d1_base64"
  });

  console.log("[certificates] UPLOAD done", { id: existing.id, item_key: existing.item_key });
  return jsonResponse({ ok: true }, 200, corsOkHeaders);
}

/* ===== CERTIFICATES: DOWNLOAD ENDPOINT PATCH ===== */

function sanitizeFilenameForHeader(name) {
  let s = String(name || "").trim();
  if (!s) s = "download.bin";
  s = s.replace(/[/\\]+/g, "_");
  s = s.replace(/[\x00-\x1F\x7F]/g, "_");
  s = s.replace(/\s+/g, " ").trim();
  if (s.length > 180) s = s.slice(0, 180);
  return s;
}

function contentDispositionHeader(filename, inline) {
  const safe = sanitizeFilenameForHeader(filename);
  const asciiFallback = safe.replace(/[^A-Za-z0-9._-]/g, "_") || "download.bin";
  const utf8 = encodeURIComponent(safe)
    .replace(/'/g, "%27")
    .replace(/\(/g, "%28")
    .replace(/\)/g, "%29")
    .replace(/\*/g, "%2A");

  return `${inline ? "inline" : "attachment"}; filename="${asciiFallback}"; filename*=UTF-8''${utf8}`;
}

async function handleCertificatesDownload(request, env, corsOkHeaders, authUser, idOrKey) {
  console.log("[certificates] DOWNLOAD start", { idOrKey: String(idOrKey), org_id: authUser.org_id, location_id: authUser.location_id });

  if (!requireRole(authUser, ["admin", "staff"])) {
    return jsonResponse({ ok: false, error: "Forbidden" }, 403, corsOkHeaders);
  }

  await ensureDefaultCertificatesIfMissing(env, authUser);

  const existing = await getCertificateItemByIdOrKey(env, authUser, idOrKey);
  if (!existing) {
    console.log("[certificates] DOWNLOAD not found item", { idOrKey: String(idOrKey) });
    return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
  }

  const hasFile = !!(existing.file_r2_key || existing.file_b64);
  if (!hasFile) {
    return jsonResponse({ ok: false, error: "No file uploaded" }, 404, corsOkHeaders);
  }

  const url = new URL(request.url);
  const inline = url.searchParams.get("inline") === "1";

  const fileName = existing.file_name || `${existing.item_key || "certificate"}.bin`;
  const fileMime = (existing.file_mime || "application/octet-stream").trim() || "application/octet-stream";

  const headers = {
    ...corsOkHeaders,
    "Content-Type": fileMime,
    "Content-Disposition": contentDispositionHeader(fileName, inline),
    "Cache-Control": "no-store",
    "X-Content-Type-Options": "nosniff",
    "Access-Control-Expose-Headers": "Content-Disposition, Content-Type, Content-Length"
  };

  // Prefer R2
  if (existing.file_r2_key && env.CERTS_R2) {
    const obj = await env.CERTS_R2.get(existing.file_r2_key);
    if (!obj) {
      console.log("[certificates] DOWNLOAD missing R2 object", { key: existing.file_r2_key });
      return jsonResponse({ ok: false, error: "File missing" }, 404, corsOkHeaders);
    }
    return new Response(obj.body, { status: 200, headers });
  }

  // Fallback to D1 base64
  if (existing.file_b64) {
    let bytes;
    try {
      bytes = bytesFromBase64(String(existing.file_b64 || "").trim());
    } catch (e) {
      console.log("[certificates] DOWNLOAD base64 decode failed", e && (e.stack || e.message || String(e)));
      return jsonResponse({ ok: false, error: "Corrupt stored file" }, 500, corsOkHeaders);
    }

    headers["Content-Length"] = String(bytes.length);
    return new Response(bytes, { status: 200, headers });
  }

  return jsonResponse({ ok: false, error: "File missing" }, 404, corsOkHeaders);
}

/* =========================
   UI FILE SERVING (/ui/*)
   ========================= */

function contentTypeForPath(pathname) {
  const p = String(pathname || "").toLowerCase();
  if (p.endsWith(".css")) return "text/css; charset=utf-8";
  if (p.endsWith(".js")) return "application/javascript; charset=utf-8";
  if (p.endsWith(".html")) return "text/html; charset=utf-8";
  if (p.endsWith(".json")) return "application/json; charset=utf-8";
  if (p.endsWith(".svg")) return "image/svg+xml";
  if (p.endsWith(".png")) return "image/png";
  if (p.endsWith(".jpg") || p.endsWith(".jpeg")) return "image/jpeg";
  if (p.endsWith(".webp")) return "image/webp";
  if (p.endsWith(".txt")) return "text/plain; charset=utf-8";
  return "application/octet-stream";
}

function buildGithubRawUrl(env, uiPath) {
  const owner = (env.UI_GITHUB_OWNER || "").trim() || "johnagius";
  const repo = (env.UI_GITHUB_REPO || "").trim() || "eikon-ui";
  const branch = (env.UI_GITHUB_BRANCH || "").trim() || "main";
  const dir = (env.UI_GITHUB_DIR || "").trim() || "ui";

  const safe = uiPath.replace(/^\/+/, "").replace(/\.\.+/g, ".");
  return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${dir}/${safe}`;
}

function sanitizeJsSourceText(s) {
  return String(s || "")
    .replace(/\uFEFF/g, "")
    .replace(/\u0000/g, "")
    .replace(/\u2028/g, "\n")
    .replace(/\u2029/g, "\n");
}

async function handleUiAsset(request, env, url) {
  const p = url.pathname;
  const rel = p.replace(/^\/ui\/?/, "");
  if (!rel || rel.endsWith("/")) {
    return new Response("Not found", { status: 404, headers: { "Content-Type": "text/plain; charset=utf-8" } });
  }

  const cacheSeconds = parseInt((env.UI_CACHE_SECONDS || "300").trim(), 10);
  const ct = contentTypeForPath(rel);

  const cache = caches.default;

  const cachingEnabled = Number.isFinite(cacheSeconds) && cacheSeconds > 0;

  if (cachingEnabled) {
    const cached = await cache.match(request);
    if (cached) return cached;
  }

  const ghUrl = buildGithubRawUrl(env, rel);
  const ghRes = await fetch(ghUrl, {
    method: "GET",
    headers: {
      "User-Agent": "eikon-worker-ui-proxy",
      "Cache-Control": "no-cache"
    }
  });

  if (!ghRes.ok) {
    return new Response("Not found", {
      status: 404,
      headers: { "Content-Type": "text/plain; charset=utf-8" }
    });
  }

  let body = await ghRes.arrayBuffer();

  // Patch: sanitize problematic Unicode that can cause "Invalid or unexpected token"
  if (rel.toLowerCase().endsWith(".js")) {
    try {
      const dec = new TextDecoder("utf-8");
      const txt = dec.decode(body);
      const clean = sanitizeJsSourceText(txt);
      if (clean !== txt) {
        body = new TextEncoder().encode(clean).buffer;
      }
    } catch (e) {
      // serve original bytes if sanitize fails
    }
  }

  const headers = new Headers();
  headers.set("Content-Type", ct);
  headers.set("Cache-Control", cachingEnabled ? `public, max-age=${cacheSeconds}` : "no-store");
  headers.set("X-Source", "github-raw");
  headers.set("Access-Control-Allow-Origin", "*");

  const out = new Response(body, { status: 200, headers });

  if (cachingEnabled) {
    await cache.put(request, out.clone());
  }

  return out;
}

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);

    // UI assets
    if (url.pathname.startsWith("/ui/")) {
      return await handleUiAsset(request, env, url);
    }

    if (url.pathname === "/health") {
      return jsonResponse({ ok: true, time: nowIso() }, 200, { "Cache-Control": "no-store" });
    }

    if (url.pathname === "/bootstrap" && request.method === "GET") return await handleBootstrapGet(request, env);
    if (url.pathname === "/bootstrap" && request.method === "POST") return await handleBootstrapPost(request, env);

    const cors = corsHeadersForRequest(request, env);
    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: cors.headers });
    }
    const corsOkHeaders = cors.ok ? cors.headers : { "Vary": "Origin" };

    if (url.pathname === "/auth/login" && request.method === "POST") {
      if (!cors.ok) return jsonResponse({ ok: false, error: "CORS blocked" }, 403, corsOkHeaders);
      return await handleLogin(request, env, corsOkHeaders);
    }

    const authUser = await authFromRequest(request, env);
    if (!authUser) return jsonResponse({ ok: false, error: "Unauthorized" }, 401, corsOkHeaders);
    if (!cors.ok) return jsonResponse({ ok: false, error: "CORS blocked" }, 403, corsOkHeaders);

    if (url.pathname === "/auth/me" && request.method === "GET") {
      return await handleMe(env, corsOkHeaders, authUser);
    }

    // End Of Day (EOD) â€” GET record (all paths the UI may try)
    if (request.method === "GET" && (url.pathname === "/eod/get" || url.pathname === "/eod/record" || url.pathname === "/eod" || url.pathname === "/endofday/record" || url.pathname === "/endofday")) {
      return await handleEodGet(request, env, corsOkHeaders, authUser, url);
    }
    // EOD â€” upsert record (POST or PUT, all paths the UI may try)
    if ((request.method === "POST" || request.method === "PUT") && (url.pathname === "/eod/upsert" || url.pathname === "/eod/record" || url.pathname === "/eod" || url.pathname === "/endofday/record" || url.pathname === "/endofday")) {
      return await handleEodUpsert(request, env, corsOkHeaders, authUser);
    }
    // EOD â€” lock
    if (url.pathname === "/eod/lock" && request.method === "POST") return await handleEodLock(request, env, corsOkHeaders, authUser);
    // EOD â€” list dates for month (all paths the UI may try)
    if (request.method === "GET" && (url.pathname === "/eod/dates" || url.pathname === "/eod/month" || url.pathname === "/eod/list" || url.pathname === "/endofday/dates" || url.pathname === "/endofday/month" || url.pathname === "/endofday/list")) {
      return await handleEodListDates(request, env, corsOkHeaders, authUser, url);
    }
    // EOD Contacts â€” list (GET, all paths the UI may try)
    if (request.method === "GET" && (url.pathname === "/eod/contacts" || url.pathname === "/endofday/contacts" || url.pathname === "/eod/contact" || url.pathname === "/endofday/contact")) {
      return await handleEodContactsList(request, env, corsOkHeaders, authUser);
    }
    // EOD Contacts â€” bulk save (PUT, all paths)
    if (request.method === "PUT" && (url.pathname === "/eod/contacts" || url.pathname === "/endofday/contacts")) {
      return await handleEodContactsBulkPut(request, env, corsOkHeaders, authUser);
    }
    // EOD Contacts â€” create (POST, all paths)
    if (request.method === "POST" && (url.pathname === "/eod/contacts" || url.pathname === "/endofday/contacts")) {
      return await handleEodContactsCreate(request, env, corsOkHeaders, authUser);
    }
    // EOD Contacts â€” update/delete individual
    { const m = url.pathname.match(/^\/(?:eod|endofday)\/contacts\/(\d+)$/); if (m && request.method === "PUT") return await handleEodContactsUpdate(request, env, corsOkHeaders, authUser, Number(m[1])); if (m && request.method === "DELETE") return await handleEodContactsDeactivate(request, env, corsOkHeaders, authUser, Number(m[1])); }

    // Temperature
    if (url.pathname === "/temperature/devices" && request.method === "GET") {
      return await handleTempDevicesList(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname === "/temperature/devices" && request.method === "POST") {
      return await handleTempDevicesCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/temperature/devices/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid device id" }, 400, corsOkHeaders);
      return await handleTempDevicesUpdate(request, env, corsOkHeaders, authUser, id);
    }

    if (url.pathname === "/temperature/entries" && request.method === "GET") {
      return await handleTempEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/temperature/entries" && request.method === "POST") {
      return await handleTempEntriesUpsert(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/temperature/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleTempEntryDelete(request, env, corsOkHeaders, authUser, id);
    }

    if (url.pathname === "/temperature/report" && request.method === "GET") {
      return await handleTempReport(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/temperature/report/html" && request.method === "GET") {
      return await handleTempReportHtml(request, env, corsOkHeaders, authUser, url);
    }

// Client Orders
if (url.pathname === "/client-orders/entries" && request.method === "GET") {
  return await handleClientOrdersEntriesList(request, env, corsOkHeaders, authUser, url);
}
if (url.pathname === "/client-orders/entries" && request.method === "POST") {
  return await handleClientOrdersEntryCreate(request, env, corsOkHeaders, authUser);
}
if (url.pathname.startsWith("/client-orders/entries/") && request.method === "PUT") {
  const parts = url.pathname.split("/").filter(Boolean);
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  return await handleClientOrdersEntryUpdate(request, env, corsOkHeaders, authUser, id);
}
if (url.pathname.startsWith("/client-orders/entries/") && request.method === "DELETE") {
  const parts = url.pathname.split("/").filter(Boolean);
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  return await handleClientOrdersEntryDelete(request, env, corsOkHeaders, authUser, id);
}

    // Cleaning
    if (url.pathname === "/cleaning/entries" && request.method === "GET") {
      return await handleCleaningEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/cleaning/entries" && request.method === "POST") {
      return await handleCleaningEntryCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/cleaning/entries/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleCleaningEntryUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/cleaning/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleCleaningEntryDelete(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname === "/cleaning/report" && request.method === "GET") {
      return await handleCleaningReport(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/cleaning/report/html" && request.method === "GET") {
      return await handleCleaningReportHtml(request, env, corsOkHeaders, authUser, url);
    }

    // Locum Register
    if (url.pathname === "/locumregister/entries" && request.method === "GET") {
      return await handleLocumRegisterEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/locumregister/entries" && request.method === "POST") {
      return await handleLocumRegisterEntryCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/locumregister/entries/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleLocumRegisterEntryUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/locumregister/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleLocumRegisterEntryDelete(request, env, corsOkHeaders, authUser, id);
    }


    // Daily Register (PATCH: use /daily-register/* not /daily_register/*)
    if (url.pathname === "/daily-register/entries" && request.method === "GET") {
      return await handleDailyRegisterEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/daily-register/entries" && request.method === "POST") {
      return await handleDailyRegisterEntryCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/daily-register/entries/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDailyRegisterEntryUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/daily-register/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDailyRegisterEntryDelete(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname === "/daily-register/report" && request.method === "GET") {
      return await handleDailyRegisterReport(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/daily-register/report/html" && request.method === "GET") {
      return await handleDailyRegisterReportHtml(request, env, corsOkHeaders, authUser, url);
    }

    // DDA Sales  <-- ADDED ROUTES
    if (url.pathname === "/dda-sales/entries" && request.method === "GET") {
      return await handleDdaSalesEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/dda-sales/entries" && request.method === "POST") {
      return await handleDdaSalesEntryCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/dda-sales/entries/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDdaSalesEntryUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/dda-sales/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDdaSalesEntryDelete(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname === "/dda-sales/report" && request.method === "GET") {
      return await handleDdaSalesReport(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/dda-sales/report/html" && request.method === "GET") {
      return await handleDdaSalesReportHtml(request, env, corsOkHeaders, authUser, url);
    }

    // Repeat Prescriptions
    if (url.pathname === "/repeat-prescriptions/entries" && request.method === "GET") {
      return await handleRepeatPrescriptionsEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/repeat-prescriptions/entries" && request.method === "POST") {
      return await handleRepeatPrescriptionsEntryCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/repeat-prescriptions/entries/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleRepeatPrescriptionsEntryUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/repeat-prescriptions/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleRepeatPrescriptionsEntryDelete(request, env, corsOkHeaders, authUser, id);
    }


    // DDA POYC  <-- ADDED ROUTES (NEW)
    if (url.pathname === "/dda-poyc/entries" && request.method === "GET") {
      return await handleDdaPoycEntriesList(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/dda-poyc/entries" && request.method === "POST") {
      return await handleDdaPoycEntryCreate(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/dda-poyc/entries/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDdaPoycEntryUpdate(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname.startsWith("/dda-poyc/entries/") && request.method === "DELETE") {
      const parts = url.pathname.split("/").filter(Boolean);
      const id = parseInt(parts[2], 10);
      if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
      return await handleDdaPoycEntryDelete(request, env, corsOkHeaders, authUser, id);
    }
    if (url.pathname === "/dda-poyc/report" && request.method === "GET") {
      return await handleDdaPoycReport(request, env, corsOkHeaders, authUser, url);
    }
    if (url.pathname === "/dda-poyc/report/html" && request.method === "GET") {
      return await handleDdaPoycReportHtml(request, env, corsOkHeaders, authUser, url);
    }

    // DDA Purchases  <-- NEW ROUTES
if (url.pathname === "/dda-purchases/entries" && request.method === "GET") {
  return await handleDdaPurchasesEntriesList(request, env, corsOkHeaders, authUser, url);
}
if (url.pathname === "/dda-purchases/entries" && request.method === "POST") {
  return await handleDdaPurchasesEntryCreate(request, env, corsOkHeaders, authUser);
}
if (url.pathname.startsWith("/dda-purchases/entries/") && request.method === "PUT") {
  const parts = url.pathname.split("/").filter(Boolean);
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  return await handleDdaPurchasesEntryUpdate(request, env, corsOkHeaders, authUser, id);
}
if (url.pathname.startsWith("/dda-purchases/entries/") && request.method === "DELETE") {
  const parts = url.pathname.split("/").filter(Boolean);
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid entry id" }, 400, corsOkHeaders);
  return await handleDdaPurchasesEntryDelete(request, env, corsOkHeaders, authUser, id);
}
if (url.pathname === "/dda-purchases/report" && request.method === "GET") {
  return await handleDdaPurchasesReport(request, env, corsOkHeaders, authUser, url);
}
if (url.pathname === "/dda-purchases/report/html" && request.method === "GET") {
  return await handleDdaPurchasesReportHtml(request, env, corsOkHeaders, authUser, url);
}

    // âœ… DDA Stock Takes (NEW)
if (url.pathname === "/dda-stocktakes/stocktakes" && request.method === "GET")
  return await handleDdaStockTakesList(request, env, corsOkHeaders, authUser);

if (url.pathname === "/dda-stocktakes/stocktakes" && request.method === "POST")
  return await handleDdaStockTakeCreate(request, env, corsOkHeaders, authUser);

if (url.pathname.startsWith("/dda-stocktakes/stocktakes/")) {
  const parts = url.pathname.split("/").filter(Boolean); // ["dda-stocktakes","stocktakes",":id", ...]
  const id = parseInt(parts[2], 10);
  if (!id) return jsonResponse({ ok: false, error: "Invalid stocktake id" }, 400, corsOkHeaders);

  // /dda-stocktakes/stocktakes/:id
  if (parts.length === 3 && request.method === "GET")
    return await handleDdaStockTakeGet(request, env, corsOkHeaders, authUser, id);

  if (parts.length === 3 && request.method === "PUT")
    return await handleDdaStockTakeUpdate(request, env, corsOkHeaders, authUser, id);

  // /dda-stocktakes/stocktakes/:id/items
  if (parts.length === 4 && parts[3] === "items" && request.method === "POST")
    return await handleDdaStockTakeItemAdd(request, env, corsOkHeaders, authUser, id);

  // /dda-stocktakes/stocktakes/:id/report/html
  if (parts.length === 5 && parts[3] === "report" && parts[4] === "html" && request.method === "GET")
    return await handleDdaStockTakeReportHtml(request, env, corsOkHeaders, authUser, id);
}

if (url.pathname.startsWith("/dda-stocktakes/items/")) {
  const parts = url.pathname.split("/").filter(Boolean); // ["dda-stocktakes","items",":itemId"]
  const itemId = parseInt(parts[2], 10);
  if (!itemId) return jsonResponse({ ok: false, error: "Invalid item id" }, 400, corsOkHeaders);

  if (request.method === "PUT")
    return await handleDdaStockTakeItemUpdate(request, env, corsOkHeaders, authUser, itemId);

  if (request.method === "DELETE")
    return await handleDdaStockTakeItemDelete(request, env, corsOkHeaders, authUser, itemId);
}


    // Certificates (DOWNLOAD) - PATCH
    if (url.pathname.startsWith("/certificates/items/") && (request.method === "GET" || request.method === "HEAD")) {
      const parts = url.pathname.split("/").filter(Boolean);
      const idOrKey = parts[2];
      const tail = parts[3] || "";

      if ((tail === "download" || tail === "file") && idOrKey) {
        const res = await handleCertificatesDownload(request, env, corsOkHeaders, authUser, idOrKey);
        if (request.method === "HEAD") {
          const h = new Headers(res.headers);
          return new Response(null, { status: res.status, headers: h });
        }
        return res;
      }
    }

    // Certificates
    if (url.pathname === "/certificates/items" && request.method === "GET") {
      return await handleCertificatesItemsList(request, env, corsOkHeaders, authUser);
    }
    if (url.pathname.startsWith("/certificates/items/") && request.method === "PUT") {
      const parts = url.pathname.split("/").filter(Boolean);
      const idOrKey = parts[2]; // /certificates/items/:idOrKey
      if (!idOrKey) return jsonResponse({ ok: false, error: "Invalid item id/key" }, 400, corsOkHeaders);
      return await handleCertificatesItemUpdate(request, env, corsOkHeaders, authUser, idOrKey);
    }
    if (url.pathname.startsWith("/certificates/items/") && request.method === "POST") {
      const parts = url.pathname.split("/").filter(Boolean);
      const idOrKey = parts[2]; // /certificates/items/:idOrKey/upload
      const tail = parts[3] || "";
      if (tail !== "upload") return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
      if (!idOrKey) return jsonResponse({ ok: false, error: "Invalid item id/key" }, 400, corsOkHeaders);
      return await handleCertificatesUpload(request, env, corsOkHeaders, authUser, idOrKey);
    }

    return jsonResponse({ ok: false, error: "Not found" }, 404, corsOkHeaders);
    } catch (e) {
      // Never let an exception become Cloudflare 1101 HTML again.
      console.log("[worker] exception", e && (e.stack || e.message || String(e)));

      let corsHeaders = { "Vary": "Origin" };
      try {
        const cors = corsHeadersForRequest(request, env);
        corsHeaders = cors.ok ? cors.headers : { "Vary": "Origin" };
      } catch {}

      const debugStack = String(env.DEBUG_STACK || "").trim() === "1";
      const payload = {
        ok: false,
        error: "Worker threw exception",
        message: (e && e.message) ? e.message : String(e)
      };
      if (debugStack) payload.stack = e && e.stack ? e.stack : "";

      return jsonResponse(payload, 500, corsHeaders);
    }
  }
};
